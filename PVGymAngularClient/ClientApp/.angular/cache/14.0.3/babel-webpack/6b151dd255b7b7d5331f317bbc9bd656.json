{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Directive, ElementRef, Inject, InjectionToken, NgZone, TemplateRef, ChangeDetectionStrategy, Component, ContentChild, Input, ViewChild, ViewContainerRef, ViewEncapsulation, ChangeDetectorRef, Output, EventEmitter, Optional, ComponentFactoryResolver, forwardRef, ContentChildren, Attribute, NgModule } from '@angular/core';\nimport { CdkPortal, TemplatePortal, CdkPortalOutlet, PortalHostDirective, PortalModule } from '@angular/cdk/portal';\nimport { mixinDisabled, mixinDisableRipple, mixinColor, MAT_RIPPLE_GLOBAL_OPTIONS, mixinTabIndex, RippleRenderer, MatCommonModule, MatRippleModule } from '@angular/material/core';\nimport { Subject, Subscription, merge, of } from 'rxjs';\nimport { animate, state, style, transition, trigger } from '@angular/animations';\nimport { Directionality } from '@angular/cdk/bidi';\nimport { startWith, takeUntil } from 'rxjs/operators';\nimport { coerceNumberProperty, coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { END, ENTER, HOME, SPACE } from '@angular/cdk/keycodes';\nimport { ViewportRuler } from '@angular/cdk/scrolling';\nimport { FocusKeyManager, FocusMonitor, A11yModule } from '@angular/cdk/a11y';\nimport { Platform } from '@angular/cdk/platform';\nimport { ObserversModule } from '@angular/cdk/observers';\nimport { CommonModule } from '@angular/common';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/** *\n * Injection token for the MatInkBar's Positioner.\n  @type {?} */\n\nconst _MAT_INK_BAR_POSITIONER = new InjectionToken('MatInkBarPositioner', {\n  providedIn: 'root',\n  factory: _MAT_INK_BAR_POSITIONER_FACTORY\n});\n/**\n * The default positioner function for the MatInkBar.\n * \\@docs-private\n * @return {?}\n */\n\n\nfunction _MAT_INK_BAR_POSITIONER_FACTORY() {\n  /** @type {?} */\n  const method = element => ({\n    left: element ? (element.offsetLeft || 0) + 'px' : '0',\n    width: element ? (element.offsetWidth || 0) + 'px' : '0'\n  });\n\n  return method;\n}\n/**\n * The ink-bar is used to display and animate the line underneath the current active tab label.\n * \\@docs-private\n */\n\n\nclass MatInkBar {\n  /**\n   * @param {?} _elementRef\n   * @param {?} _ngZone\n   * @param {?} _inkBarPositioner\n   */\n  constructor(_elementRef, _ngZone, _inkBarPositioner) {\n    this._elementRef = _elementRef;\n    this._ngZone = _ngZone;\n    this._inkBarPositioner = _inkBarPositioner;\n  }\n  /**\n   * Calculates the styles from the provided element in order to align the ink-bar to that element.\n   * Shows the ink bar if previously set as hidden.\n   * @param {?} element\n   * @return {?}\n   */\n\n\n  alignToElement(element) {\n    this.show();\n\n    if (typeof requestAnimationFrame !== 'undefined') {\n      this._ngZone.runOutsideAngular(() => {\n        requestAnimationFrame(() => this._setStyles(element));\n      });\n    } else {\n      this._setStyles(element);\n    }\n  }\n  /**\n   * Shows the ink bar.\n   * @return {?}\n   */\n\n\n  show() {\n    this._elementRef.nativeElement.style.visibility = 'visible';\n  }\n  /**\n   * Hides the ink bar.\n   * @return {?}\n   */\n\n\n  hide() {\n    this._elementRef.nativeElement.style.visibility = 'hidden';\n  }\n  /**\n   * Sets the proper styles to the ink bar element.\n   * @param {?} element\n   * @return {?}\n   */\n\n\n  _setStyles(element) {\n    /** @type {?} */\n    const positions = this._inkBarPositioner(element);\n    /** @type {?} */\n\n\n    const inkBar = this._elementRef.nativeElement;\n    inkBar.style.left = positions.left;\n    inkBar.style.width = positions.width;\n  }\n\n}\n\nMatInkBar.decorators = [{\n  type: Directive,\n  args: [{\n    selector: 'mat-ink-bar',\n    host: {\n      'class': 'mat-ink-bar'\n    }\n  }]\n}];\n/** @nocollapse */\n\nMatInkBar.ctorParameters = () => [{\n  type: ElementRef\n}, {\n  type: NgZone\n}, {\n  type: undefined,\n  decorators: [{\n    type: Inject,\n    args: [_MAT_INK_BAR_POSITIONER]\n  }]\n}];\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * Decorates the `ng-template` tags and reads out the template from it.\n */\n\n\nclass MatTabContent {\n  /**\n   * @param {?} template\n   */\n  constructor(template) {\n    this.template = template;\n  }\n\n}\n\nMatTabContent.decorators = [{\n  type: Directive,\n  args: [{\n    selector: '[matTabContent]'\n  }]\n}];\n/** @nocollapse */\n\nMatTabContent.ctorParameters = () => [{\n  type: TemplateRef\n}];\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/** @type {?} */\n\n\nconst _CdkPortal = CdkPortal;\n/**\n * Used to flag tab labels for use with the portal directive\n */\n\nclass MatTabLabel extends _CdkPortal {}\n\nMatTabLabel.decorators = [{\n  type: Directive,\n  args: [{\n    selector: '[mat-tab-label], [matTabLabel]'\n  }]\n}];\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * \\@docs-private\n */\n\nclass MatTabBase {}\n/** @type {?} */\n\n\nconst _MatTabMixinBase = mixinDisabled(MatTabBase);\n\nclass MatTab extends _MatTabMixinBase {\n  /**\n   * @param {?} _viewContainerRef\n   */\n  constructor(_viewContainerRef) {\n    super();\n    this._viewContainerRef = _viewContainerRef;\n    /**\n     * Plain text label for the tab, used when there is no template label.\n     */\n\n    this.textLabel = '';\n    /**\n     * Portal that will be the hosted content of the tab\n     */\n\n    this._contentPortal = null;\n    /**\n     * Emits whenever the internal state of the tab changes.\n     */\n\n    this._stateChanges = new Subject();\n    /**\n     * The relatively indexed position where 0 represents the center, negative is left, and positive\n     * represents the right.\n     */\n\n    this.position = null;\n    /**\n     * The initial relatively index origin of the tab if it was created and selected after there\n     * was already a selected tab. Provides context of what position the tab should originate from.\n     */\n\n    this.origin = null;\n    /**\n     * Whether the tab is currently active.\n     */\n\n    this.isActive = false;\n  }\n  /**\n   * \\@docs-private\n   * @return {?}\n   */\n\n\n  get content() {\n    return this._contentPortal;\n  }\n  /**\n   * @param {?} changes\n   * @return {?}\n   */\n\n\n  ngOnChanges(changes) {\n    if (changes.hasOwnProperty('textLabel') || changes.hasOwnProperty('disabled')) {\n      this._stateChanges.next();\n    }\n  }\n  /**\n   * @return {?}\n   */\n\n\n  ngOnDestroy() {\n    this._stateChanges.complete();\n  }\n  /**\n   * @return {?}\n   */\n\n\n  ngOnInit() {\n    this._contentPortal = new TemplatePortal(this._explicitContent || this._implicitContent, this._viewContainerRef);\n  }\n\n}\n\nMatTab.decorators = [{\n  type: Component,\n  args: [{\n    selector: 'mat-tab',\n    template: \"<ng-template><ng-content></ng-content></ng-template>\",\n    inputs: ['disabled'],\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    encapsulation: ViewEncapsulation.None,\n    exportAs: 'matTab'\n  }]\n}];\n/** @nocollapse */\n\nMatTab.ctorParameters = () => [{\n  type: ViewContainerRef\n}];\n\nMatTab.propDecorators = {\n  templateLabel: [{\n    type: ContentChild,\n    args: [MatTabLabel]\n  }],\n  _explicitContent: [{\n    type: ContentChild,\n    args: [MatTabContent, {\n      read: TemplateRef\n    }]\n  }],\n  _implicitContent: [{\n    type: ViewChild,\n    args: [TemplateRef]\n  }],\n  textLabel: [{\n    type: Input,\n    args: ['label']\n  }],\n  ariaLabel: [{\n    type: Input,\n    args: ['aria-label']\n  }],\n  ariaLabelledby: [{\n    type: Input,\n    args: ['aria-labelledby']\n  }]\n};\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/** *\n * Animations used by the Material tabs.\n * \\@docs-private\n  @type {?} */\n\nconst matTabsAnimations = {\n  /** Animation translates a tab along the X axis. */\n  translateTab: trigger('translateTab', [// Note: transitions to `none` instead of 0, because some browsers might blur the content.\n  state('center, void, left-origin-center, right-origin-center', style({\n    transform: 'none'\n  })), // If the tab is either on the left or right, we additionally add a `min-height` of 1px\n  // in order to ensure that the element has a height before its state changes. This is\n  // necessary because Chrome does seem to skip the transition in RTL mode if the element does\n  // not have a static height and is not rendered. See related issue: #9465\n  state('left', style({\n    transform: 'translate3d(-100%, 0, 0)',\n    minHeight: '1px'\n  })), state('right', style({\n    transform: 'translate3d(100%, 0, 0)',\n    minHeight: '1px'\n  })), transition('* => left, * => right, left => center, right => center', animate('500ms cubic-bezier(0.35, 0, 0.25, 1)')), transition('void => left-origin-center', [style({\n    transform: 'translate3d(-100%, 0, 0)'\n  }), animate('500ms cubic-bezier(0.35, 0, 0.25, 1)')]), transition('void => right-origin-center', [style({\n    transform: 'translate3d(100%, 0, 0)'\n  }), animate('500ms cubic-bezier(0.35, 0, 0.25, 1)')])])\n};\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * The portal host directive for the contents of the tab.\n * \\@docs-private\n */\n\nclass MatTabBodyPortal extends CdkPortalOutlet {\n  /**\n   * @param {?} componentFactoryResolver\n   * @param {?} viewContainerRef\n   * @param {?} _host\n   */\n  constructor(componentFactoryResolver, viewContainerRef, _host) {\n    super(componentFactoryResolver, viewContainerRef);\n    this._host = _host;\n    /**\n     * Subscription to events for when the tab body begins centering.\n     */\n\n    this._centeringSub = Subscription.EMPTY;\n    /**\n     * Subscription to events for when the tab body finishes leaving from center position.\n     */\n\n    this._leavingSub = Subscription.EMPTY;\n  }\n  /**\n   * Set initial visibility or set up subscription for changing visibility.\n   * @return {?}\n   */\n\n\n  ngOnInit() {\n    super.ngOnInit();\n    this._centeringSub = this._host._beforeCentering.pipe(startWith(this._host._isCenterPosition(this._host._position))).subscribe(isCentering => {\n      if (isCentering && !this.hasAttached()) {\n        this.attach(this._host._content);\n      }\n    });\n    this._leavingSub = this._host._afterLeavingCenter.subscribe(() => {\n      this.detach();\n    });\n  }\n  /**\n   * Clean up centering subscription.\n   * @return {?}\n   */\n\n\n  ngOnDestroy() {\n    super.ngOnDestroy();\n\n    this._centeringSub.unsubscribe();\n\n    this._leavingSub.unsubscribe();\n  }\n\n}\n\nMatTabBodyPortal.decorators = [{\n  type: Directive,\n  args: [{\n    selector: '[matTabBodyHost]'\n  }]\n}];\n/** @nocollapse */\n\nMatTabBodyPortal.ctorParameters = () => [{\n  type: ComponentFactoryResolver\n}, {\n  type: ViewContainerRef\n}, {\n  type: MatTabBody,\n  decorators: [{\n    type: Inject,\n    args: [forwardRef(() => MatTabBody)]\n  }]\n}];\n/**\n * Wrapper for the contents of a tab.\n * \\@docs-private\n */\n\n\nclass MatTabBody {\n  /**\n   * @param {?} _elementRef\n   * @param {?} _dir\n   * @param {?=} changeDetectorRef\n   */\n  constructor(_elementRef, _dir,\n  /**\n  * @breaking-change 8.0.0 changeDetectorRef to be made required.\n  */\n  changeDetectorRef) {\n    this._elementRef = _elementRef;\n    this._dir = _dir;\n    /**\n     * Subscription to the directionality change observable.\n     */\n\n    this._dirChangeSubscription = Subscription.EMPTY;\n    /**\n     * Event emitted when the tab begins to animate towards the center as the active tab.\n     */\n\n    this._onCentering = new EventEmitter();\n    /**\n     * Event emitted before the centering of the tab begins.\n     */\n\n    this._beforeCentering = new EventEmitter();\n    /**\n     * Event emitted before the centering of the tab begins.\n     */\n\n    this._afterLeavingCenter = new EventEmitter();\n    /**\n     * Event emitted when the tab completes its animation towards the center.\n     */\n\n    this._onCentered = new EventEmitter(true);\n\n    if (this._dir && changeDetectorRef) {\n      this._dirChangeSubscription = this._dir.change.subscribe(dir => {\n        this._computePositionAnimationState(dir);\n\n        changeDetectorRef.markForCheck();\n      });\n    }\n  }\n  /**\n   * The shifted index position of the tab body, where zero represents the active center tab.\n   * @param {?} position\n   * @return {?}\n   */\n\n\n  set position(position) {\n    this._positionIndex = position;\n\n    this._computePositionAnimationState();\n  }\n  /**\n   * After initialized, check if the content is centered and has an origin. If so, set the\n   * special position states that transition the tab from the left or right before centering.\n   * @return {?}\n   */\n\n\n  ngOnInit() {\n    if (this._position == 'center' && this.origin != null) {\n      this._position = this._computePositionFromOrigin();\n    }\n  }\n  /**\n   * @return {?}\n   */\n\n\n  ngOnDestroy() {\n    this._dirChangeSubscription.unsubscribe();\n  }\n  /**\n   * @param {?} e\n   * @return {?}\n   */\n\n\n  _onTranslateTabStarted(e) {\n    /** @type {?} */\n    const isCentering = this._isCenterPosition(e.toState);\n\n    this._beforeCentering.emit(isCentering);\n\n    if (isCentering) {\n      this._onCentering.emit(this._elementRef.nativeElement.clientHeight);\n    }\n  }\n  /**\n   * @param {?} e\n   * @return {?}\n   */\n\n\n  _onTranslateTabComplete(e) {\n    // If the transition to the center is complete, emit an event.\n    if (this._isCenterPosition(e.toState) && this._isCenterPosition(this._position)) {\n      this._onCentered.emit();\n    }\n\n    if (this._isCenterPosition(e.fromState) && !this._isCenterPosition(this._position)) {\n      this._afterLeavingCenter.emit();\n    }\n  }\n  /**\n   * The text direction of the containing app.\n   * @return {?}\n   */\n\n\n  _getLayoutDirection() {\n    return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';\n  }\n  /**\n   * Whether the provided position state is considered center, regardless of origin.\n   * @param {?} position\n   * @return {?}\n   */\n\n\n  _isCenterPosition(position) {\n    return position == 'center' || position == 'left-origin-center' || position == 'right-origin-center';\n  }\n  /**\n   * Computes the position state that will be used for the tab-body animation trigger.\n   * @param {?=} dir\n   * @return {?}\n   */\n\n\n  _computePositionAnimationState(dir = this._getLayoutDirection()) {\n    if (this._positionIndex < 0) {\n      this._position = dir == 'ltr' ? 'left' : 'right';\n    } else if (this._positionIndex > 0) {\n      this._position = dir == 'ltr' ? 'right' : 'left';\n    } else {\n      this._position = 'center';\n    }\n  }\n  /**\n   * Computes the position state based on the specified origin position. This is used if the\n   * tab is becoming visible immediately after creation.\n   * @return {?}\n   */\n\n\n  _computePositionFromOrigin() {\n    /** @type {?} */\n    const dir = this._getLayoutDirection();\n\n    if (dir == 'ltr' && this.origin <= 0 || dir == 'rtl' && this.origin > 0) {\n      return 'left-origin-center';\n    }\n\n    return 'right-origin-center';\n  }\n\n}\n\nMatTabBody.decorators = [{\n  type: Component,\n  args: [{\n    selector: 'mat-tab-body',\n    template: \"<div class=\\\"mat-tab-body-content\\\" #content [@translateTab]=\\\"_position\\\" (@translateTab.start)=\\\"_onTranslateTabStarted($event)\\\" (@translateTab.done)=\\\"_onTranslateTabComplete($event)\\\"><ng-template matTabBodyHost></ng-template></div>\",\n    styles: [\".mat-tab-body-content{height:100%;overflow:auto}.mat-tab-group-dynamic-height .mat-tab-body-content{overflow:hidden}\"],\n    encapsulation: ViewEncapsulation.None,\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    animations: [matTabsAnimations.translateTab],\n    host: {\n      'class': 'mat-tab-body'\n    }\n  }]\n}];\n/** @nocollapse */\n\nMatTabBody.ctorParameters = () => [{\n  type: ElementRef\n}, {\n  type: Directionality,\n  decorators: [{\n    type: Optional\n  }]\n}, {\n  type: ChangeDetectorRef\n}];\n\nMatTabBody.propDecorators = {\n  _onCentering: [{\n    type: Output\n  }],\n  _beforeCentering: [{\n    type: Output\n  }],\n  _afterLeavingCenter: [{\n    type: Output\n  }],\n  _onCentered: [{\n    type: Output\n  }],\n  _portalHost: [{\n    type: ViewChild,\n    args: [PortalHostDirective]\n  }],\n  _content: [{\n    type: Input,\n    args: ['content']\n  }],\n  origin: [{\n    type: Input\n  }],\n  position: [{\n    type: Input\n  }]\n};\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * \\@docs-private\n */\n\nclass MatTabLabelWrapperBase {}\n/** @type {?} */\n\n\nconst _MatTabLabelWrapperMixinBase = mixinDisabled(MatTabLabelWrapperBase);\n/**\n * Used in the `mat-tab-group` view to display tab labels.\n * \\@docs-private\n */\n\n\nclass MatTabLabelWrapper extends _MatTabLabelWrapperMixinBase {\n  /**\n   * @param {?} elementRef\n   */\n  constructor(elementRef) {\n    super();\n    this.elementRef = elementRef;\n  }\n  /**\n   * Sets focus on the wrapper element\n   * @return {?}\n   */\n\n\n  focus() {\n    this.elementRef.nativeElement.focus();\n  }\n  /**\n   * @return {?}\n   */\n\n\n  getOffsetLeft() {\n    return this.elementRef.nativeElement.offsetLeft;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  getOffsetWidth() {\n    return this.elementRef.nativeElement.offsetWidth;\n  }\n\n}\n\nMatTabLabelWrapper.decorators = [{\n  type: Directive,\n  args: [{\n    selector: '[matTabLabelWrapper]',\n    inputs: ['disabled'],\n    host: {\n      '[class.mat-tab-disabled]': 'disabled',\n      '[attr.aria-disabled]': '!!disabled'\n    }\n  }]\n}];\n/** @nocollapse */\n\nMatTabLabelWrapper.ctorParameters = () => [{\n  type: ElementRef\n}];\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/** *\n * The distance in pixels that will be overshot when scrolling a tab label into view. This helps\n * provide a small affordance to the label next to it.\n  @type {?} */\n\n\nconst EXAGGERATED_OVERSCROLL = 60;\n/**\n * \\@docs-private\n */\n\nclass MatTabHeaderBase {}\n/** @type {?} */\n\n\nconst _MatTabHeaderMixinBase = mixinDisableRipple(MatTabHeaderBase);\n/**\n * The header of the tab group which displays a list of all the tabs in the tab group. Includes\n * an ink bar that follows the currently selected tab. When the tabs list's width exceeds the\n * width of the header container, then arrows will be displayed to allow the user to scroll\n * left and right across the header.\n * \\@docs-private\n */\n\n\nclass MatTabHeader extends _MatTabHeaderMixinBase {\n  /**\n   * @param {?} _elementRef\n   * @param {?} _changeDetectorRef\n   * @param {?} _viewportRuler\n   * @param {?} _dir\n   * @param {?=} _ngZone\n   */\n  constructor(_elementRef, _changeDetectorRef, _viewportRuler, _dir, _ngZone) {\n    super();\n    this._elementRef = _elementRef;\n    this._changeDetectorRef = _changeDetectorRef;\n    this._viewportRuler = _viewportRuler;\n    this._dir = _dir;\n    this._ngZone = _ngZone;\n    /**\n     * The distance in pixels that the tab labels should be translated to the left.\n     */\n\n    this._scrollDistance = 0;\n    /**\n     * Whether the header should scroll to the selected index after the view has been checked.\n     */\n\n    this._selectedIndexChanged = false;\n    /**\n     * Emits when the component is destroyed.\n     */\n\n    this._destroyed = new Subject();\n    /**\n     * Whether the controls for pagination should be displayed\n     */\n\n    this._showPaginationControls = false;\n    /**\n     * Whether the tab list can be scrolled more towards the end of the tab label list.\n     */\n\n    this._disableScrollAfter = true;\n    /**\n     * Whether the tab list can be scrolled more towards the beginning of the tab label list.\n     */\n\n    this._disableScrollBefore = true;\n    this._selectedIndex = 0;\n    /**\n     * Event emitted when the option is selected.\n     */\n\n    this.selectFocusedIndex = new EventEmitter();\n    /**\n     * Event emitted when a label is focused.\n     */\n\n    this.indexFocused = new EventEmitter();\n  }\n  /**\n   * The index of the active tab.\n   * @return {?}\n   */\n\n\n  get selectedIndex() {\n    return this._selectedIndex;\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n\n\n  set selectedIndex(value) {\n    value = coerceNumberProperty(value);\n    this._selectedIndexChanged = this._selectedIndex != value;\n    this._selectedIndex = value;\n\n    if (this._keyManager) {\n      this._keyManager.updateActiveItemIndex(value);\n    }\n  }\n  /**\n   * @return {?}\n   */\n\n\n  ngAfterContentChecked() {\n    // If the number of tab labels have changed, check if scrolling should be enabled\n    if (this._tabLabelCount != this._labelWrappers.length) {\n      this._updatePagination();\n\n      this._tabLabelCount = this._labelWrappers.length;\n\n      this._changeDetectorRef.markForCheck();\n    } // If the selected index has changed, scroll to the label and check if the scrolling controls\n    // should be disabled.\n\n\n    if (this._selectedIndexChanged) {\n      this._scrollToLabel(this._selectedIndex);\n\n      this._checkScrollingControls();\n\n      this._alignInkBarToSelectedTab();\n\n      this._selectedIndexChanged = false;\n\n      this._changeDetectorRef.markForCheck();\n    } // If the scroll distance has been changed (tab selected, focused, scroll controls activated),\n    // then translate the header to reflect this.\n\n\n    if (this._scrollDistanceChanged) {\n      this._updateTabScrollPosition();\n\n      this._scrollDistanceChanged = false;\n\n      this._changeDetectorRef.markForCheck();\n    }\n  }\n  /**\n   * @param {?} event\n   * @return {?}\n   */\n\n\n  _handleKeydown(event) {\n    switch (event.keyCode) {\n      case HOME:\n        this._keyManager.setFirstItemActive();\n\n        event.preventDefault();\n        break;\n\n      case END:\n        this._keyManager.setLastItemActive();\n\n        event.preventDefault();\n        break;\n\n      case ENTER:\n      case SPACE:\n        this.selectFocusedIndex.emit(this.focusIndex);\n        event.preventDefault();\n        break;\n\n      default:\n        this._keyManager.onKeydown(event);\n\n    }\n  }\n  /**\n   * Aligns the ink bar to the selected tab on load.\n   * @return {?}\n   */\n\n\n  ngAfterContentInit() {\n    /** @type {?} */\n    const dirChange = this._dir ? this._dir.change : of(null);\n    /** @type {?} */\n\n    const resize = this._viewportRuler.change(150);\n    /** @type {?} */\n\n\n    const realign = () => {\n      this._updatePagination();\n\n      this._alignInkBarToSelectedTab();\n    };\n\n    this._keyManager = new FocusKeyManager(this._labelWrappers).withHorizontalOrientation(this._getLayoutDirection()).withWrap();\n\n    this._keyManager.updateActiveItem(0); // Defer the first call in order to allow for slower browsers to lay out the elements.\n    // This helps in cases where the user lands directly on a page with paginated tabs.\n\n\n    typeof requestAnimationFrame !== 'undefined' ? requestAnimationFrame(realign) : realign(); // On dir change or window resize, realign the ink bar and update the orientation of\n    // the key manager if the direction has changed.\n\n    merge(dirChange, resize).pipe(takeUntil(this._destroyed)).subscribe(() => {\n      realign();\n\n      this._keyManager.withHorizontalOrientation(this._getLayoutDirection());\n    }); // If there is a change in the focus key manager we need to emit the `indexFocused`\n    // event in order to provide a public event that notifies about focus changes. Also we realign\n    // the tabs container by scrolling the new focused tab into the visible section.\n\n    this._keyManager.change.pipe(takeUntil(this._destroyed)).subscribe(newFocusIndex => {\n      this.indexFocused.emit(newFocusIndex);\n\n      this._setTabFocus(newFocusIndex);\n    });\n  }\n  /**\n   * @return {?}\n   */\n\n\n  ngOnDestroy() {\n    this._destroyed.next();\n\n    this._destroyed.complete();\n  }\n  /**\n   * Callback for when the MutationObserver detects that the content has changed.\n   * @return {?}\n   */\n\n\n  _onContentChanges() {\n    /** @type {?} */\n    const zoneCallback = () => {\n      this._updatePagination();\n\n      this._alignInkBarToSelectedTab();\n\n      this._changeDetectorRef.markForCheck();\n    }; // The content observer runs outside the `NgZone` by default, which\n    // means that we need to bring the callback back in ourselves.\n    // @breaking-change 8.0.0 Remove null check for `_ngZone` once it's a required parameter.\n\n\n    this._ngZone ? this._ngZone.run(zoneCallback) : zoneCallback();\n  }\n  /**\n   * Updating the view whether pagination should be enabled or not\n   * @return {?}\n   */\n\n\n  _updatePagination() {\n    this._checkPaginationEnabled();\n\n    this._checkScrollingControls();\n\n    this._updateTabScrollPosition();\n  }\n  /**\n   * Tracks which element has focus; used for keyboard navigation\n   * @return {?}\n   */\n\n\n  get focusIndex() {\n    return this._keyManager ?\n    /** @type {?} */\n    this._keyManager.activeItemIndex : 0;\n  }\n  /**\n   * When the focus index is set, we must manually send focus to the correct label\n   * @param {?} value\n   * @return {?}\n   */\n\n\n  set focusIndex(value) {\n    if (!this._isValidIndex(value) || this.focusIndex === value || !this._keyManager) {\n      return;\n    }\n\n    this._keyManager.setActiveItem(value);\n  }\n  /**\n   * Determines if an index is valid.  If the tabs are not ready yet, we assume that the user is\n   * providing a valid index and return true.\n   * @param {?} index\n   * @return {?}\n   */\n\n\n  _isValidIndex(index) {\n    if (!this._labelWrappers) {\n      return true;\n    }\n    /** @type {?} */\n\n\n    const tab = this._labelWrappers ? this._labelWrappers.toArray()[index] : null;\n    return !!tab && !tab.disabled;\n  }\n  /**\n   * Sets focus on the HTML element for the label wrapper and scrolls it into the view if\n   * scrolling is enabled.\n   * @param {?} tabIndex\n   * @return {?}\n   */\n\n\n  _setTabFocus(tabIndex) {\n    if (this._showPaginationControls) {\n      this._scrollToLabel(tabIndex);\n    }\n\n    if (this._labelWrappers && this._labelWrappers.length) {\n      this._labelWrappers.toArray()[tabIndex].focus();\n      /** @type {?} */\n\n\n      const containerEl = this._tabListContainer.nativeElement;\n      /** @type {?} */\n\n      const dir = this._getLayoutDirection();\n\n      if (dir == 'ltr') {\n        containerEl.scrollLeft = 0;\n      } else {\n        containerEl.scrollLeft = containerEl.scrollWidth - containerEl.offsetWidth;\n      }\n    }\n  }\n  /**\n   * The layout direction of the containing app.\n   * @return {?}\n   */\n\n\n  _getLayoutDirection() {\n    return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';\n  }\n  /**\n   * Performs the CSS transformation on the tab list that will cause the list to scroll.\n   * @return {?}\n   */\n\n\n  _updateTabScrollPosition() {\n    /** @type {?} */\n    const scrollDistance = this.scrollDistance;\n    /** @type {?} */\n\n    const translateX = this._getLayoutDirection() === 'ltr' ? -scrollDistance : scrollDistance; // Don't use `translate3d` here because we don't want to create a new layer. A new layer\n    // seems to cause flickering and overflow in Internet Explorer. For example, the ink bar\n    // and ripples will exceed the boundaries of the visible tab bar.\n    // See: https://github.com/angular/material2/issues/10276\n\n    this._tabList.nativeElement.style.transform = `translateX(${translateX}px)`;\n  }\n  /**\n   * Sets the distance in pixels that the tab header should be transformed in the X-axis.\n   * @return {?}\n   */\n\n\n  get scrollDistance() {\n    return this._scrollDistance;\n  }\n  /**\n   * @param {?} v\n   * @return {?}\n   */\n\n\n  set scrollDistance(v) {\n    this._scrollDistance = Math.max(0, Math.min(this._getMaxScrollDistance(), v)); // Mark that the scroll distance has changed so that after the view is checked, the CSS\n    // transformation can move the header.\n\n    this._scrollDistanceChanged = true;\n\n    this._checkScrollingControls();\n  }\n  /**\n   * Moves the tab list in the 'before' or 'after' direction (towards the beginning of the list or\n   * the end of the list, respectively). The distance to scroll is computed to be a third of the\n   * length of the tab list view window.\n   *\n   * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n   * should be called sparingly.\n   * @param {?} scrollDir\n   * @return {?}\n   */\n\n\n  _scrollHeader(scrollDir) {\n    /** @type {?} */\n    const viewLength = this._tabListContainer.nativeElement.offsetWidth; // Move the scroll distance one-third the length of the tab list's viewport.\n\n    this.scrollDistance += (scrollDir == 'before' ? -1 : 1) * viewLength / 3;\n  }\n  /**\n   * Moves the tab list such that the desired tab label (marked by index) is moved into view.\n   *\n   * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n   * should be called sparingly.\n   * @param {?} labelIndex\n   * @return {?}\n   */\n\n\n  _scrollToLabel(labelIndex) {\n    /** @type {?} */\n    const selectedLabel = this._labelWrappers ? this._labelWrappers.toArray()[labelIndex] : null;\n\n    if (!selectedLabel) {\n      return;\n    }\n    /** @type {?} */\n\n\n    const viewLength = this._tabListContainer.nativeElement.offsetWidth;\n    /** @type {?} */\n\n    let labelBeforePos;\n    /** @type {?} */\n\n    let labelAfterPos;\n\n    if (this._getLayoutDirection() == 'ltr') {\n      labelBeforePos = selectedLabel.getOffsetLeft();\n      labelAfterPos = labelBeforePos + selectedLabel.getOffsetWidth();\n    } else {\n      labelAfterPos = this._tabList.nativeElement.offsetWidth - selectedLabel.getOffsetLeft();\n      labelBeforePos = labelAfterPos - selectedLabel.getOffsetWidth();\n    }\n    /** @type {?} */\n\n\n    const beforeVisiblePos = this.scrollDistance;\n    /** @type {?} */\n\n    const afterVisiblePos = this.scrollDistance + viewLength;\n\n    if (labelBeforePos < beforeVisiblePos) {\n      // Scroll header to move label to the before direction\n      this.scrollDistance -= beforeVisiblePos - labelBeforePos + EXAGGERATED_OVERSCROLL;\n    } else if (labelAfterPos > afterVisiblePos) {\n      // Scroll header to move label to the after direction\n      this.scrollDistance += labelAfterPos - afterVisiblePos + EXAGGERATED_OVERSCROLL;\n    }\n  }\n  /**\n   * Evaluate whether the pagination controls should be displayed. If the scroll width of the\n   * tab list is wider than the size of the header container, then the pagination controls should\n   * be shown.\n   *\n   * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n   * should be called sparingly.\n   * @return {?}\n   */\n\n\n  _checkPaginationEnabled() {\n    /** @type {?} */\n    const isEnabled = this._tabList.nativeElement.scrollWidth > this._elementRef.nativeElement.offsetWidth;\n\n    if (!isEnabled) {\n      this.scrollDistance = 0;\n    }\n\n    if (isEnabled !== this._showPaginationControls) {\n      this._changeDetectorRef.markForCheck();\n    }\n\n    this._showPaginationControls = isEnabled;\n  }\n  /**\n   * Evaluate whether the before and after controls should be enabled or disabled.\n   * If the header is at the beginning of the list (scroll distance is equal to 0) then disable the\n   * before button. If the header is at the end of the list (scroll distance is equal to the\n   * maximum distance we can scroll), then disable the after button.\n   *\n   * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n   * should be called sparingly.\n   * @return {?}\n   */\n\n\n  _checkScrollingControls() {\n    // Check if the pagination arrows should be activated.\n    this._disableScrollBefore = this.scrollDistance == 0;\n    this._disableScrollAfter = this.scrollDistance == this._getMaxScrollDistance();\n\n    this._changeDetectorRef.markForCheck();\n  }\n  /**\n   * Determines what is the maximum length in pixels that can be set for the scroll distance. This\n   * is equal to the difference in width between the tab list container and tab header container.\n   *\n   * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n   * should be called sparingly.\n   * @return {?}\n   */\n\n\n  _getMaxScrollDistance() {\n    /** @type {?} */\n    const lengthOfTabList = this._tabList.nativeElement.scrollWidth;\n    /** @type {?} */\n\n    const viewLength = this._tabListContainer.nativeElement.offsetWidth;\n    return lengthOfTabList - viewLength || 0;\n  }\n  /**\n   * Tells the ink-bar to align itself to the current label wrapper\n   * @return {?}\n   */\n\n\n  _alignInkBarToSelectedTab() {\n    /** @type {?} */\n    const selectedLabelWrapper = this._labelWrappers && this._labelWrappers.length ? this._labelWrappers.toArray()[this.selectedIndex].elementRef.nativeElement : null;\n\n    this._inkBar.alignToElement(\n    /** @type {?} */\n    selectedLabelWrapper);\n  }\n\n}\n\nMatTabHeader.decorators = [{\n  type: Component,\n  args: [{\n    selector: 'mat-tab-header',\n    template: \"<div class=\\\"mat-tab-header-pagination mat-tab-header-pagination-before mat-elevation-z4\\\" aria-hidden=\\\"true\\\" mat-ripple [matRippleDisabled]=\\\"_disableScrollBefore || disableRipple\\\" [class.mat-tab-header-pagination-disabled]=\\\"_disableScrollBefore\\\" (click)=\\\"_scrollHeader('before')\\\"><div class=\\\"mat-tab-header-pagination-chevron\\\"></div></div><div class=\\\"mat-tab-label-container\\\" #tabListContainer (keydown)=\\\"_handleKeydown($event)\\\"><div class=\\\"mat-tab-list\\\" #tabList role=\\\"tablist\\\" (cdkObserveContent)=\\\"_onContentChanges()\\\"><div class=\\\"mat-tab-labels\\\"><ng-content></ng-content></div><mat-ink-bar></mat-ink-bar></div></div><div class=\\\"mat-tab-header-pagination mat-tab-header-pagination-after mat-elevation-z4\\\" aria-hidden=\\\"true\\\" mat-ripple [matRippleDisabled]=\\\"_disableScrollAfter || disableRipple\\\" [class.mat-tab-header-pagination-disabled]=\\\"_disableScrollAfter\\\" (click)=\\\"_scrollHeader('after')\\\"><div class=\\\"mat-tab-header-pagination-chevron\\\"></div></div>\",\n    styles: [\".mat-tab-header{display:flex;overflow:hidden;position:relative;flex-shrink:0}.mat-tab-label{height:48px;padding:0 24px;cursor:pointer;box-sizing:border-box;opacity:.6;min-width:160px;text-align:center;display:inline-flex;justify-content:center;align-items:center;white-space:nowrap;position:relative}.mat-tab-label:focus{outline:0}.mat-tab-label:focus:not(.mat-tab-disabled){opacity:1}@media screen and (-ms-high-contrast:active){.mat-tab-label:focus{outline:dotted 2px}}.mat-tab-label.mat-tab-disabled{cursor:default}@media screen and (-ms-high-contrast:active){.mat-tab-label.mat-tab-disabled{opacity:.5}}.mat-tab-label .mat-tab-label-content{display:inline-flex;justify-content:center;align-items:center;white-space:nowrap}@media screen and (-ms-high-contrast:active){.mat-tab-label{opacity:1}}@media (max-width:599px){.mat-tab-label{min-width:72px}}.mat-ink-bar{position:absolute;bottom:0;height:2px;transition:.5s cubic-bezier(.35,0,.25,1)}.mat-tab-group-inverted-header .mat-ink-bar{bottom:auto;top:0}@media screen and (-ms-high-contrast:active){.mat-ink-bar{outline:solid 2px;height:0}}.mat-tab-header-pagination{position:relative;display:none;justify-content:center;align-items:center;min-width:32px;cursor:pointer;z-index:2}.mat-tab-header-pagination-controls-enabled .mat-tab-header-pagination{display:flex}.mat-tab-header-pagination-before,.mat-tab-header-rtl .mat-tab-header-pagination-after{padding-left:4px}.mat-tab-header-pagination-before .mat-tab-header-pagination-chevron,.mat-tab-header-rtl .mat-tab-header-pagination-after .mat-tab-header-pagination-chevron{transform:rotate(-135deg)}.mat-tab-header-pagination-after,.mat-tab-header-rtl .mat-tab-header-pagination-before{padding-right:4px}.mat-tab-header-pagination-after .mat-tab-header-pagination-chevron,.mat-tab-header-rtl .mat-tab-header-pagination-before .mat-tab-header-pagination-chevron{transform:rotate(45deg)}.mat-tab-header-pagination-chevron{border-style:solid;border-width:2px 2px 0 0;content:'';height:8px;width:8px}.mat-tab-header-pagination-disabled{box-shadow:none;cursor:default}.mat-tab-label-container{display:flex;flex-grow:1;overflow:hidden;z-index:1}.mat-tab-list{flex-grow:1;position:relative;transition:transform .5s cubic-bezier(.35,0,.25,1)}.mat-tab-labels{display:flex}[mat-align-tabs=center] .mat-tab-labels{justify-content:center}[mat-align-tabs=end] .mat-tab-labels{justify-content:flex-end}\"],\n    inputs: ['disableRipple'],\n    encapsulation: ViewEncapsulation.None,\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    host: {\n      'class': 'mat-tab-header',\n      '[class.mat-tab-header-pagination-controls-enabled]': '_showPaginationControls',\n      '[class.mat-tab-header-rtl]': \"_getLayoutDirection() == 'rtl'\"\n    }\n  }]\n}];\n/** @nocollapse */\n\nMatTabHeader.ctorParameters = () => [{\n  type: ElementRef\n}, {\n  type: ChangeDetectorRef\n}, {\n  type: ViewportRuler\n}, {\n  type: Directionality,\n  decorators: [{\n    type: Optional\n  }]\n}, {\n  type: NgZone\n}];\n\nMatTabHeader.propDecorators = {\n  _labelWrappers: [{\n    type: ContentChildren,\n    args: [MatTabLabelWrapper]\n  }],\n  _inkBar: [{\n    type: ViewChild,\n    args: [MatInkBar]\n  }],\n  _tabListContainer: [{\n    type: ViewChild,\n    args: ['tabListContainer']\n  }],\n  _tabList: [{\n    type: ViewChild,\n    args: ['tabList']\n  }],\n  selectedIndex: [{\n    type: Input\n  }],\n  selectFocusedIndex: [{\n    type: Output\n  }],\n  indexFocused: [{\n    type: Output\n  }]\n};\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/** *\n * Used to generate unique ID's for each tab component\n  @type {?} */\n\nlet nextId = 0;\n/**\n * A simple change event emitted on focus or selection changes.\n */\n\nclass MatTabChangeEvent {}\n/**\n * \\@docs-private\n */\n\n\nclass MatTabGroupBase {\n  /**\n   * @param {?} _elementRef\n   */\n  constructor(_elementRef) {\n    this._elementRef = _elementRef;\n  }\n\n}\n/** @type {?} */\n\n\nconst _MatTabGroupMixinBase = mixinColor(mixinDisableRipple(MatTabGroupBase), 'primary');\n/**\n * Material design tab-group component.  Supports basic tab pairs (label + content) and includes\n * animated ink-bar, keyboard navigation, and screen reader.\n * See: https://material.io/design/components/tabs.html\n */\n\n\nclass MatTabGroup extends _MatTabGroupMixinBase {\n  /**\n   * @param {?} elementRef\n   * @param {?} _changeDetectorRef\n   */\n  constructor(elementRef, _changeDetectorRef) {\n    super(elementRef);\n    this._changeDetectorRef = _changeDetectorRef;\n    /**\n     * The tab index that should be selected after the content has been checked.\n     */\n\n    this._indexToSelect = 0;\n    /**\n     * Snapshot of the height of the tab body wrapper before another tab is activated.\n     */\n\n    this._tabBodyWrapperHeight = 0;\n    /**\n     * Subscription to tabs being added/removed.\n     */\n\n    this._tabsSubscription = Subscription.EMPTY;\n    /**\n     * Subscription to changes in the tab labels.\n     */\n\n    this._tabLabelSubscription = Subscription.EMPTY;\n    this._dynamicHeight = false;\n    this._selectedIndex = null;\n    /**\n     * Position of the tab header.\n     */\n\n    this.headerPosition = 'above';\n    /**\n     * Output to enable support for two-way binding on `[(selectedIndex)]`\n     */\n\n    this.selectedIndexChange = new EventEmitter();\n    /**\n     * Event emitted when focus has changed within a tab group.\n     */\n\n    this.focusChange = new EventEmitter();\n    /**\n     * Event emitted when the body animation has completed\n     */\n\n    this.animationDone = new EventEmitter();\n    /**\n     * Event emitted when the tab selection has changed.\n     */\n\n    this.selectedTabChange = new EventEmitter(true);\n    this._groupId = nextId++;\n  }\n  /**\n   * Whether the tab group should grow to the size of the active tab.\n   * @return {?}\n   */\n\n\n  get dynamicHeight() {\n    return this._dynamicHeight;\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n\n\n  set dynamicHeight(value) {\n    this._dynamicHeight = coerceBooleanProperty(value);\n  }\n  /**\n   * The index of the active tab.\n   * @return {?}\n   */\n\n\n  get selectedIndex() {\n    return this._selectedIndex;\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n\n\n  set selectedIndex(value) {\n    this._indexToSelect = coerceNumberProperty(value, null);\n  }\n  /**\n   * Background color of the tab group.\n   * @return {?}\n   */\n\n\n  get backgroundColor() {\n    return this._backgroundColor;\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n\n\n  set backgroundColor(value) {\n    /** @type {?} */\n    const nativeElement = this._elementRef.nativeElement;\n    nativeElement.classList.remove(`mat-background-${this.backgroundColor}`);\n\n    if (value) {\n      nativeElement.classList.add(`mat-background-${value}`);\n    }\n\n    this._backgroundColor = value;\n  }\n  /**\n   * After the content is checked, this component knows what tabs have been defined\n   * and what the selected index should be. This is where we can know exactly what position\n   * each tab should be in according to the new selected index, and additionally we know how\n   * a new selected tab should transition in (from the left or right).\n   * @return {?}\n   */\n\n\n  ngAfterContentChecked() {\n    /** @type {?} */\n    const indexToSelect = this._indexToSelect = this._clampTabIndex(this._indexToSelect); // If there is a change in selected index, emit a change event. Should not trigger if\n    // the selected index has not yet been initialized.\n\n\n    if (this._selectedIndex != indexToSelect) {\n      /** @type {?} */\n      const isFirstRun = this._selectedIndex == null;\n\n      if (!isFirstRun) {\n        this.selectedTabChange.emit(this._createChangeEvent(indexToSelect));\n      } // Changing these values after change detection has run\n      // since the checked content may contain references to them.\n\n\n      Promise.resolve().then(() => {\n        this._tabs.forEach((tab, index) => tab.isActive = index === indexToSelect);\n\n        if (!isFirstRun) {\n          this.selectedIndexChange.emit(indexToSelect);\n        }\n      });\n    } // Setup the position for each tab and optionally setup an origin on the next selected tab.\n\n\n    this._tabs.forEach((tab, index) => {\n      tab.position = index - indexToSelect; // If there is already a selected tab, then set up an origin for the next selected tab\n      // if it doesn't have one already.\n\n      if (this._selectedIndex != null && tab.position == 0 && !tab.origin) {\n        tab.origin = indexToSelect - this._selectedIndex;\n      }\n    });\n\n    if (this._selectedIndex !== indexToSelect) {\n      this._selectedIndex = indexToSelect;\n\n      this._changeDetectorRef.markForCheck();\n    }\n  }\n  /**\n   * @return {?}\n   */\n\n\n  ngAfterContentInit() {\n    this._subscribeToTabLabels(); // Subscribe to changes in the amount of tabs, in order to be\n    // able to re-render the content as new tabs are added or removed.\n\n\n    this._tabsSubscription = this._tabs.changes.subscribe(() => {\n      /** @type {?} */\n      const indexToSelect = this._clampTabIndex(this._indexToSelect); // Maintain the previously-selected tab if a new tab is added or removed and there is no\n      // explicit change that selects a different tab.\n\n\n      if (indexToSelect === this._selectedIndex) {\n        /** @type {?} */\n        const tabs = this._tabs.toArray();\n\n        for (let i = 0; i < tabs.length; i++) {\n          if (tabs[i].isActive) {\n            // Assign both to the `_indexToSelect` and `_selectedIndex` so we don't fire a changed\n            // event, otherwise the consumer may end up in an infinite loop in some edge cases like\n            // adding a tab within the `selectedIndexChange` event.\n            this._indexToSelect = this._selectedIndex = i;\n            break;\n          }\n        }\n      }\n\n      this._subscribeToTabLabels();\n\n      this._changeDetectorRef.markForCheck();\n    });\n  }\n  /**\n   * @return {?}\n   */\n\n\n  ngOnDestroy() {\n    this._tabsSubscription.unsubscribe();\n\n    this._tabLabelSubscription.unsubscribe();\n  }\n  /**\n   * Re-aligns the ink bar to the selected tab element.\n   * @return {?}\n   */\n\n\n  realignInkBar() {\n    if (this._tabHeader) {\n      this._tabHeader._alignInkBarToSelectedTab();\n    }\n  }\n  /**\n   * @param {?} index\n   * @return {?}\n   */\n\n\n  _focusChanged(index) {\n    this.focusChange.emit(this._createChangeEvent(index));\n  }\n  /**\n   * @param {?} index\n   * @return {?}\n   */\n\n\n  _createChangeEvent(index) {\n    /** @type {?} */\n    const event = new MatTabChangeEvent();\n    event.index = index;\n\n    if (this._tabs && this._tabs.length) {\n      event.tab = this._tabs.toArray()[index];\n    }\n\n    return event;\n  }\n  /**\n   * Subscribes to changes in the tab labels. This is needed, because the \\@Input for the label is\n   * on the MatTab component, whereas the data binding is inside the MatTabGroup. In order for the\n   * binding to be updated, we need to subscribe to changes in it and trigger change detection\n   * manually.\n   * @return {?}\n   */\n\n\n  _subscribeToTabLabels() {\n    if (this._tabLabelSubscription) {\n      this._tabLabelSubscription.unsubscribe();\n    }\n\n    this._tabLabelSubscription = merge(...this._tabs.map(tab => tab._stateChanges)).subscribe(() => this._changeDetectorRef.markForCheck());\n  }\n  /**\n   * Clamps the given index to the bounds of 0 and the tabs length.\n   * @param {?} index\n   * @return {?}\n   */\n\n\n  _clampTabIndex(index) {\n    // Note the `|| 0`, which ensures that values like NaN can't get through\n    // and which would otherwise throw the component into an infinite loop\n    // (since Math.max(NaN, 0) === NaN).\n    return Math.min(this._tabs.length - 1, Math.max(index || 0, 0));\n  }\n  /**\n   * Returns a unique id for each tab label element\n   * @param {?} i\n   * @return {?}\n   */\n\n\n  _getTabLabelId(i) {\n    return `mat-tab-label-${this._groupId}-${i}`;\n  }\n  /**\n   * Returns a unique id for each tab content element\n   * @param {?} i\n   * @return {?}\n   */\n\n\n  _getTabContentId(i) {\n    return `mat-tab-content-${this._groupId}-${i}`;\n  }\n  /**\n   * Sets the height of the body wrapper to the height of the activating tab if dynamic\n   * height property is true.\n   * @param {?} tabHeight\n   * @return {?}\n   */\n\n\n  _setTabBodyWrapperHeight(tabHeight) {\n    if (!this._dynamicHeight || !this._tabBodyWrapperHeight) {\n      return;\n    }\n    /** @type {?} */\n\n\n    const wrapper = this._tabBodyWrapper.nativeElement;\n    wrapper.style.height = this._tabBodyWrapperHeight + 'px'; // This conditional forces the browser to paint the height so that\n    // the animation to the new height can have an origin.\n\n    if (this._tabBodyWrapper.nativeElement.offsetHeight) {\n      wrapper.style.height = tabHeight + 'px';\n    }\n  }\n  /**\n   * Removes the height of the tab body wrapper.\n   * @return {?}\n   */\n\n\n  _removeTabBodyWrapperHeight() {\n    this._tabBodyWrapperHeight = this._tabBodyWrapper.nativeElement.clientHeight;\n    this._tabBodyWrapper.nativeElement.style.height = '';\n    this.animationDone.emit();\n  }\n  /**\n   * Handle click events, setting new selected index if appropriate.\n   * @param {?} tab\n   * @param {?} tabHeader\n   * @param {?} idx\n   * @return {?}\n   */\n\n\n  _handleClick(tab, tabHeader, idx) {\n    if (!tab.disabled) {\n      this.selectedIndex = tabHeader.focusIndex = idx;\n    }\n  }\n  /**\n   * Retrieves the tabindex for the tab.\n   * @param {?} tab\n   * @param {?} idx\n   * @return {?}\n   */\n\n\n  _getTabIndex(tab, idx) {\n    if (tab.disabled) {\n      return null;\n    }\n\n    return this.selectedIndex === idx ? 0 : -1;\n  }\n\n}\n\nMatTabGroup.decorators = [{\n  type: Component,\n  args: [{\n    selector: 'mat-tab-group',\n    exportAs: 'matTabGroup',\n    template: \"<mat-tab-header #tabHeader [selectedIndex]=\\\"selectedIndex\\\" [disableRipple]=\\\"disableRipple\\\" (indexFocused)=\\\"_focusChanged($event)\\\" (selectFocusedIndex)=\\\"selectedIndex = $event\\\"><div class=\\\"mat-tab-label\\\" role=\\\"tab\\\" matTabLabelWrapper mat-ripple cdkMonitorElementFocus *ngFor=\\\"let tab of _tabs; let i = index\\\" [id]=\\\"_getTabLabelId(i)\\\" [attr.tabIndex]=\\\"_getTabIndex(tab, i)\\\" [attr.aria-posinset]=\\\"i + 1\\\" [attr.aria-setsize]=\\\"_tabs.length\\\" [attr.aria-controls]=\\\"_getTabContentId(i)\\\" [attr.aria-selected]=\\\"selectedIndex == i\\\" [attr.aria-label]=\\\"tab.ariaLabel || null\\\" [attr.aria-labelledby]=\\\"(!tab.ariaLabel && tab.ariaLabelledby) ? tab.ariaLabelledby : null\\\" [class.mat-tab-label-active]=\\\"selectedIndex == i\\\" [disabled]=\\\"tab.disabled\\\" [matRippleDisabled]=\\\"tab.disabled || disableRipple\\\" (click)=\\\"_handleClick(tab, tabHeader, i)\\\"><div class=\\\"mat-tab-label-content\\\"><ng-template [ngIf]=\\\"tab.templateLabel\\\"><ng-template [cdkPortalOutlet]=\\\"tab.templateLabel\\\"></ng-template></ng-template><ng-template [ngIf]=\\\"!tab.templateLabel\\\">{{tab.textLabel}}</ng-template></div></div></mat-tab-header><div class=\\\"mat-tab-body-wrapper\\\" #tabBodyWrapper><mat-tab-body role=\\\"tabpanel\\\" *ngFor=\\\"let tab of _tabs; let i = index\\\" [id]=\\\"_getTabContentId(i)\\\" [attr.aria-labelledby]=\\\"_getTabLabelId(i)\\\" [class.mat-tab-body-active]=\\\"selectedIndex == i\\\" [content]=\\\"tab.content\\\" [position]=\\\"tab.position\\\" [origin]=\\\"tab.origin\\\" (_onCentered)=\\\"_removeTabBodyWrapperHeight()\\\" (_onCentering)=\\\"_setTabBodyWrapperHeight($event)\\\"></mat-tab-body></div>\",\n    styles: [\".mat-tab-group{display:flex;flex-direction:column}.mat-tab-group.mat-tab-group-inverted-header{flex-direction:column-reverse}.mat-tab-label{height:48px;padding:0 24px;cursor:pointer;box-sizing:border-box;opacity:.6;min-width:160px;text-align:center;display:inline-flex;justify-content:center;align-items:center;white-space:nowrap;position:relative}.mat-tab-label:focus{outline:0}.mat-tab-label:focus:not(.mat-tab-disabled){opacity:1}@media screen and (-ms-high-contrast:active){.mat-tab-label:focus{outline:dotted 2px}}.mat-tab-label.mat-tab-disabled{cursor:default}@media screen and (-ms-high-contrast:active){.mat-tab-label.mat-tab-disabled{opacity:.5}}.mat-tab-label .mat-tab-label-content{display:inline-flex;justify-content:center;align-items:center;white-space:nowrap}@media screen and (-ms-high-contrast:active){.mat-tab-label{opacity:1}}@media (max-width:599px){.mat-tab-label{padding:0 12px}}@media (max-width:959px){.mat-tab-label{padding:0 12px}}.mat-tab-group[mat-stretch-tabs]>.mat-tab-header .mat-tab-label{flex-basis:0;flex-grow:1}.mat-tab-body-wrapper{position:relative;overflow:hidden;display:flex;transition:height .5s cubic-bezier(.35,0,.25,1)}.mat-tab-body{top:0;left:0;right:0;bottom:0;position:absolute;display:block;overflow:hidden;flex-basis:100%}.mat-tab-body.mat-tab-body-active{position:relative;overflow-x:hidden;overflow-y:auto;z-index:1;flex-grow:1}.mat-tab-group.mat-tab-group-dynamic-height .mat-tab-body.mat-tab-body-active{overflow-y:hidden}\"],\n    encapsulation: ViewEncapsulation.None,\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    inputs: ['color', 'disableRipple'],\n    host: {\n      'class': 'mat-tab-group',\n      '[class.mat-tab-group-dynamic-height]': 'dynamicHeight',\n      '[class.mat-tab-group-inverted-header]': 'headerPosition === \"below\"'\n    }\n  }]\n}];\n/** @nocollapse */\n\nMatTabGroup.ctorParameters = () => [{\n  type: ElementRef\n}, {\n  type: ChangeDetectorRef\n}];\n\nMatTabGroup.propDecorators = {\n  _tabs: [{\n    type: ContentChildren,\n    args: [MatTab]\n  }],\n  _tabBodyWrapper: [{\n    type: ViewChild,\n    args: ['tabBodyWrapper']\n  }],\n  _tabHeader: [{\n    type: ViewChild,\n    args: ['tabHeader']\n  }],\n  dynamicHeight: [{\n    type: Input\n  }],\n  selectedIndex: [{\n    type: Input\n  }],\n  headerPosition: [{\n    type: Input\n  }],\n  backgroundColor: [{\n    type: Input\n  }],\n  selectedIndexChange: [{\n    type: Output\n  }],\n  focusChange: [{\n    type: Output\n  }],\n  animationDone: [{\n    type: Output\n  }],\n  selectedTabChange: [{\n    type: Output\n  }]\n};\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * \\@docs-private\n */\n\nclass MatTabNavBase {\n  /**\n   * @param {?} _elementRef\n   */\n  constructor(_elementRef) {\n    this._elementRef = _elementRef;\n  }\n\n}\n/** @type {?} */\n\n\nconst _MatTabNavMixinBase = mixinDisableRipple(mixinColor(MatTabNavBase, 'primary'));\n/**\n * Navigation component matching the styles of the tab group header.\n * Provides anchored navigation with animated ink bar.\n */\n\n\nclass MatTabNav extends _MatTabNavMixinBase {\n  /**\n   * @param {?} elementRef\n   * @param {?} _dir\n   * @param {?} _ngZone\n   * @param {?} _changeDetectorRef\n   * @param {?} _viewportRuler\n   */\n  constructor(elementRef, _dir, _ngZone, _changeDetectorRef, _viewportRuler) {\n    super(elementRef);\n    this._dir = _dir;\n    this._ngZone = _ngZone;\n    this._changeDetectorRef = _changeDetectorRef;\n    this._viewportRuler = _viewportRuler;\n    /**\n     * Subject that emits when the component has been destroyed.\n     */\n\n    this._onDestroy = new Subject();\n  }\n  /**\n   * Background color of the tab nav.\n   * @return {?}\n   */\n\n\n  get backgroundColor() {\n    return this._backgroundColor;\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n\n\n  set backgroundColor(value) {\n    /** @type {?} */\n    const nativeElement = this._elementRef.nativeElement;\n    nativeElement.classList.remove(`mat-background-${this.backgroundColor}`);\n\n    if (value) {\n      nativeElement.classList.add(`mat-background-${value}`);\n    }\n\n    this._backgroundColor = value;\n  }\n  /**\n   * Notifies the component that the active link has been changed.\n   * \\@breaking-change 8.0.0 `element` parameter to be removed.\n   * @param {?} element\n   * @return {?}\n   */\n\n\n  updateActiveLink(element) {\n    // Note: keeping the `element` for backwards-compat, but isn't being used for anything.\n    // @breaking-change 8.0.0\n    this._activeLinkChanged = !!element;\n\n    this._changeDetectorRef.markForCheck();\n  }\n  /**\n   * @return {?}\n   */\n\n\n  ngAfterContentInit() {\n    this._ngZone.runOutsideAngular(() => {\n      /** @type {?} */\n      const dirChange = this._dir ? this._dir.change : of(null);\n      return merge(dirChange, this._viewportRuler.change(10)).pipe(takeUntil(this._onDestroy)).subscribe(() => this._alignInkBar());\n    });\n  }\n  /**\n   * Checks if the active link has been changed and, if so, will update the ink bar.\n   * @return {?}\n   */\n\n\n  ngAfterContentChecked() {\n    if (this._activeLinkChanged) {\n      /** @type {?} */\n      const activeTab = this._tabLinks.find(tab => tab.active);\n\n      this._activeLinkElement = activeTab ? activeTab._elementRef : null;\n\n      this._alignInkBar();\n\n      this._activeLinkChanged = false;\n    }\n  }\n  /**\n   * @return {?}\n   */\n\n\n  ngOnDestroy() {\n    this._onDestroy.next();\n\n    this._onDestroy.complete();\n  }\n  /**\n   * Aligns the ink bar to the active link.\n   * @return {?}\n   */\n\n\n  _alignInkBar() {\n    if (this._activeLinkElement) {\n      this._inkBar.show();\n\n      this._inkBar.alignToElement(this._activeLinkElement.nativeElement);\n    } else {\n      this._inkBar.hide();\n    }\n  }\n\n}\n\nMatTabNav.decorators = [{\n  type: Component,\n  args: [{\n    selector: '[mat-tab-nav-bar]',\n    exportAs: 'matTabNavBar, matTabNav',\n    inputs: ['color', 'disableRipple'],\n    template: \"<div class=\\\"mat-tab-links\\\" (cdkObserveContent)=\\\"_alignInkBar()\\\"><ng-content></ng-content><mat-ink-bar></mat-ink-bar></div>\",\n    styles: [\".mat-tab-nav-bar{overflow:hidden;position:relative;flex-shrink:0}.mat-tab-links{position:relative;display:flex}.mat-tab-link{height:48px;padding:0 24px;cursor:pointer;box-sizing:border-box;opacity:.6;min-width:160px;text-align:center;display:inline-flex;justify-content:center;align-items:center;white-space:nowrap;vertical-align:top;text-decoration:none;position:relative;overflow:hidden;-webkit-tap-highlight-color:transparent}.mat-tab-link:focus{outline:0}.mat-tab-link:focus:not(.mat-tab-disabled){opacity:1}@media screen and (-ms-high-contrast:active){.mat-tab-link:focus{outline:dotted 2px}}.mat-tab-link.mat-tab-disabled{cursor:default}@media screen and (-ms-high-contrast:active){.mat-tab-link.mat-tab-disabled{opacity:.5}}.mat-tab-link .mat-tab-label-content{display:inline-flex;justify-content:center;align-items:center;white-space:nowrap}@media screen and (-ms-high-contrast:active){.mat-tab-link{opacity:1}}[mat-stretch-tabs] .mat-tab-link{flex-basis:0;flex-grow:1}.mat-tab-link.mat-tab-disabled{pointer-events:none}@media (max-width:599px){.mat-tab-link{min-width:72px}}.mat-ink-bar{position:absolute;bottom:0;height:2px;transition:.5s cubic-bezier(.35,0,.25,1)}.mat-tab-group-inverted-header .mat-ink-bar{bottom:auto;top:0}@media screen and (-ms-high-contrast:active){.mat-ink-bar{outline:solid 2px;height:0}}\"],\n    host: {\n      'class': 'mat-tab-nav-bar'\n    },\n    encapsulation: ViewEncapsulation.None,\n    changeDetection: ChangeDetectionStrategy.OnPush\n  }]\n}];\n/** @nocollapse */\n\nMatTabNav.ctorParameters = () => [{\n  type: ElementRef\n}, {\n  type: Directionality,\n  decorators: [{\n    type: Optional\n  }]\n}, {\n  type: NgZone\n}, {\n  type: ChangeDetectorRef\n}, {\n  type: ViewportRuler\n}];\n\nMatTabNav.propDecorators = {\n  _inkBar: [{\n    type: ViewChild,\n    args: [MatInkBar]\n  }],\n  _tabLinks: [{\n    type: ContentChildren,\n    args: [forwardRef(() => MatTabLink), {\n      descendants: true\n    }]\n  }],\n  backgroundColor: [{\n    type: Input\n  }]\n};\n\nclass MatTabLinkBase {}\n/** @type {?} */\n\n\nconst _MatTabLinkMixinBase = mixinTabIndex(mixinDisableRipple(mixinDisabled(MatTabLinkBase)));\n/**\n * Link inside of a `mat-tab-nav-bar`.\n */\n\n\nclass MatTabLink extends _MatTabLinkMixinBase {\n  /**\n   * @param {?} _tabNavBar\n   * @param {?} _elementRef\n   * @param {?} ngZone\n   * @param {?} platform\n   * @param {?} globalOptions\n   * @param {?} tabIndex\n   * @param {?=} _focusMonitor\n   */\n  constructor(_tabNavBar, _elementRef, ngZone, platform, globalOptions, tabIndex, _focusMonitor) {\n    super();\n    this._tabNavBar = _tabNavBar;\n    this._elementRef = _elementRef;\n    this._focusMonitor = _focusMonitor;\n    /**\n     * Whether the tab link is active or not.\n     */\n\n    this._isActive = false;\n    /**\n     * Whether the ripples are globally disabled through the RippleGlobalOptions\n     */\n\n    this._ripplesGloballyDisabled = false;\n    /**\n     * Ripple configuration for ripples that are launched on pointer down.\n     * \\@docs-private\n     */\n\n    this.rippleConfig = {};\n    this._tabLinkRipple = new RippleRenderer(this, ngZone, _elementRef, platform);\n\n    this._tabLinkRipple.setupTriggerEvents(_elementRef.nativeElement);\n\n    this.tabIndex = parseInt(tabIndex) || 0;\n\n    if (globalOptions) {\n      // TODO(paul): Do not copy each option manually. Allow dynamic global option changes: #9729\n      this._ripplesGloballyDisabled = !!globalOptions.disabled;\n      this.rippleConfig = {\n        terminateOnPointerUp: globalOptions.terminateOnPointerUp,\n        animation: globalOptions.animation\n      };\n    }\n\n    if (_focusMonitor) {\n      _focusMonitor.monitor(_elementRef);\n    }\n  }\n  /**\n   * Whether the link is active.\n   * @return {?}\n   */\n\n\n  get active() {\n    return this._isActive;\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n\n\n  set active(value) {\n    if (value !== this._isActive) {\n      this._isActive = value;\n\n      this._tabNavBar.updateActiveLink(this._elementRef);\n    }\n  }\n  /**\n   * Whether ripples are disabled on interaction\n   * \\@docs-private\n   * @return {?}\n   */\n\n\n  get rippleDisabled() {\n    return this.disabled || this.disableRipple || this._tabNavBar.disableRipple || this._ripplesGloballyDisabled;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  ngOnDestroy() {\n    this._tabLinkRipple._removeTriggerEvents();\n\n    if (this._focusMonitor) {\n      this._focusMonitor.stopMonitoring(this._elementRef);\n    }\n  }\n\n}\n\nMatTabLink.decorators = [{\n  type: Directive,\n  args: [{\n    selector: '[mat-tab-link], [matTabLink]',\n    exportAs: 'matTabLink',\n    inputs: ['disabled', 'disableRipple', 'tabIndex'],\n    host: {\n      'class': 'mat-tab-link',\n      '[attr.aria-current]': 'active',\n      '[attr.aria-disabled]': 'disabled.toString()',\n      '[attr.tabIndex]': 'tabIndex',\n      '[class.mat-tab-disabled]': 'disabled',\n      '[class.mat-tab-label-active]': 'active'\n    }\n  }]\n}];\n/** @nocollapse */\n\nMatTabLink.ctorParameters = () => [{\n  type: MatTabNav\n}, {\n  type: ElementRef\n}, {\n  type: NgZone\n}, {\n  type: Platform\n}, {\n  type: undefined,\n  decorators: [{\n    type: Optional\n  }, {\n    type: Inject,\n    args: [MAT_RIPPLE_GLOBAL_OPTIONS]\n  }]\n}, {\n  type: String,\n  decorators: [{\n    type: Attribute,\n    args: ['tabindex']\n  }]\n}, {\n  type: FocusMonitor\n}];\n\nMatTabLink.propDecorators = {\n  active: [{\n    type: Input\n  }]\n};\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\nclass MatTabsModule {}\n\nMatTabsModule.decorators = [{\n  type: NgModule,\n  args: [{\n    imports: [CommonModule, MatCommonModule, PortalModule, MatRippleModule, ObserversModule, A11yModule],\n    // Don't export all components because some are only to be used internally.\n    exports: [MatCommonModule, MatTabGroup, MatTabLabel, MatTab, MatTabNav, MatTabLink, MatTabContent],\n    declarations: [MatTabGroup, MatTabLabel, MatTab, MatInkBar, MatTabLabelWrapper, MatTabNav, MatTabLink, MatTabBody, MatTabBodyPortal, MatTabHeader, MatTabContent]\n  }]\n}];\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\nexport { MatInkBar, _MAT_INK_BAR_POSITIONER, MatTabBody, MatTabBodyPortal, MatTabHeader, MatTabLabelWrapper, MatTab, MatTabLabel, MatTabNav, MatTabLink, MatTabContent, MatTabsModule, MatTabChangeEvent, MatTabGroupBase, _MatTabGroupMixinBase, MatTabGroup, matTabsAnimations, _MAT_INK_BAR_POSITIONER_FACTORY as a23, MatTabBase as f23, _MatTabMixinBase as g23, MatTabHeaderBase as b23, _MatTabHeaderMixinBase as c23, MatTabLabelWrapperBase as d23, _MatTabLabelWrapperMixinBase as e23, MatTabLinkBase as j23, MatTabNavBase as h23, _MatTabLinkMixinBase as k23, _MatTabNavMixinBase as i23 };","map":{"version":3,"names":["Directive","ElementRef","Inject","InjectionToken","NgZone","TemplateRef","ChangeDetectionStrategy","Component","ContentChild","Input","ViewChild","ViewContainerRef","ViewEncapsulation","ChangeDetectorRef","Output","EventEmitter","Optional","ComponentFactoryResolver","forwardRef","ContentChildren","Attribute","NgModule","CdkPortal","TemplatePortal","CdkPortalOutlet","PortalHostDirective","PortalModule","mixinDisabled","mixinDisableRipple","mixinColor","MAT_RIPPLE_GLOBAL_OPTIONS","mixinTabIndex","RippleRenderer","MatCommonModule","MatRippleModule","Subject","Subscription","merge","of","animate","state","style","transition","trigger","Directionality","startWith","takeUntil","coerceNumberProperty","coerceBooleanProperty","END","ENTER","HOME","SPACE","ViewportRuler","FocusKeyManager","FocusMonitor","A11yModule","Platform","ObserversModule","CommonModule","_MAT_INK_BAR_POSITIONER","providedIn","factory","_MAT_INK_BAR_POSITIONER_FACTORY","method","element","left","offsetLeft","width","offsetWidth","MatInkBar","constructor","_elementRef","_ngZone","_inkBarPositioner","alignToElement","show","requestAnimationFrame","runOutsideAngular","_setStyles","nativeElement","visibility","hide","positions","inkBar","decorators","type","args","selector","host","ctorParameters","undefined","MatTabContent","template","_CdkPortal","MatTabLabel","MatTabBase","_MatTabMixinBase","MatTab","_viewContainerRef","textLabel","_contentPortal","_stateChanges","position","origin","isActive","content","ngOnChanges","changes","hasOwnProperty","next","ngOnDestroy","complete","ngOnInit","_explicitContent","_implicitContent","inputs","changeDetection","OnPush","encapsulation","None","exportAs","propDecorators","templateLabel","read","ariaLabel","ariaLabelledby","matTabsAnimations","translateTab","transform","minHeight","MatTabBodyPortal","componentFactoryResolver","viewContainerRef","_host","_centeringSub","EMPTY","_leavingSub","_beforeCentering","pipe","_isCenterPosition","_position","subscribe","isCentering","hasAttached","attach","_content","_afterLeavingCenter","detach","unsubscribe","MatTabBody","_dir","changeDetectorRef","_dirChangeSubscription","_onCentering","_onCentered","change","dir","_computePositionAnimationState","markForCheck","_positionIndex","_computePositionFromOrigin","_onTranslateTabStarted","e","toState","emit","clientHeight","_onTranslateTabComplete","fromState","_getLayoutDirection","value","styles","animations","_portalHost","MatTabLabelWrapperBase","_MatTabLabelWrapperMixinBase","MatTabLabelWrapper","elementRef","focus","getOffsetLeft","getOffsetWidth","EXAGGERATED_OVERSCROLL","MatTabHeaderBase","_MatTabHeaderMixinBase","MatTabHeader","_changeDetectorRef","_viewportRuler","_scrollDistance","_selectedIndexChanged","_destroyed","_showPaginationControls","_disableScrollAfter","_disableScrollBefore","_selectedIndex","selectFocusedIndex","indexFocused","selectedIndex","_keyManager","updateActiveItemIndex","ngAfterContentChecked","_tabLabelCount","_labelWrappers","length","_updatePagination","_scrollToLabel","_checkScrollingControls","_alignInkBarToSelectedTab","_scrollDistanceChanged","_updateTabScrollPosition","_handleKeydown","event","keyCode","setFirstItemActive","preventDefault","setLastItemActive","focusIndex","onKeydown","ngAfterContentInit","dirChange","resize","realign","withHorizontalOrientation","withWrap","updateActiveItem","newFocusIndex","_setTabFocus","_onContentChanges","zoneCallback","run","_checkPaginationEnabled","activeItemIndex","_isValidIndex","setActiveItem","index","tab","toArray","disabled","tabIndex","containerEl","_tabListContainer","scrollLeft","scrollWidth","scrollDistance","translateX","_tabList","v","Math","max","min","_getMaxScrollDistance","_scrollHeader","scrollDir","viewLength","labelIndex","selectedLabel","labelBeforePos","labelAfterPos","beforeVisiblePos","afterVisiblePos","isEnabled","lengthOfTabList","selectedLabelWrapper","_inkBar","nextId","MatTabChangeEvent","MatTabGroupBase","_MatTabGroupMixinBase","MatTabGroup","_indexToSelect","_tabBodyWrapperHeight","_tabsSubscription","_tabLabelSubscription","_dynamicHeight","headerPosition","selectedIndexChange","focusChange","animationDone","selectedTabChange","_groupId","dynamicHeight","backgroundColor","_backgroundColor","classList","remove","add","indexToSelect","_clampTabIndex","isFirstRun","_createChangeEvent","Promise","resolve","then","_tabs","forEach","_subscribeToTabLabels","tabs","i","realignInkBar","_tabHeader","_focusChanged","map","_getTabLabelId","_getTabContentId","_setTabBodyWrapperHeight","tabHeight","wrapper","_tabBodyWrapper","height","offsetHeight","_removeTabBodyWrapperHeight","_handleClick","tabHeader","idx","_getTabIndex","MatTabNavBase","_MatTabNavMixinBase","MatTabNav","_onDestroy","updateActiveLink","_activeLinkChanged","_alignInkBar","activeTab","_tabLinks","find","active","_activeLinkElement","MatTabLink","descendants","MatTabLinkBase","_MatTabLinkMixinBase","_tabNavBar","ngZone","platform","globalOptions","_focusMonitor","_isActive","_ripplesGloballyDisabled","rippleConfig","_tabLinkRipple","setupTriggerEvents","parseInt","terminateOnPointerUp","animation","monitor","rippleDisabled","disableRipple","_removeTriggerEvents","stopMonitoring","String","MatTabsModule","imports","exports","declarations","a23","f23","g23","b23","c23","d23","e23","j23","h23","k23","i23"],"sources":["C:/Users/ismae/Desktop/PVGym/PVGymAngularClient/ClientApp/node_modules/@angular/material/esm2015/tabs.js"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Directive, ElementRef, Inject, InjectionToken, NgZone, TemplateRef, ChangeDetectionStrategy, Component, ContentChild, Input, ViewChild, ViewContainerRef, ViewEncapsulation, ChangeDetectorRef, Output, EventEmitter, Optional, ComponentFactoryResolver, forwardRef, ContentChildren, Attribute, NgModule } from '@angular/core';\nimport { CdkPortal, TemplatePortal, CdkPortalOutlet, PortalHostDirective, PortalModule } from '@angular/cdk/portal';\nimport { mixinDisabled, mixinDisableRipple, mixinColor, MAT_RIPPLE_GLOBAL_OPTIONS, mixinTabIndex, RippleRenderer, MatCommonModule, MatRippleModule } from '@angular/material/core';\nimport { Subject, Subscription, merge, of } from 'rxjs';\nimport { animate, state, style, transition, trigger } from '@angular/animations';\nimport { Directionality } from '@angular/cdk/bidi';\nimport { startWith, takeUntil } from 'rxjs/operators';\nimport { coerceNumberProperty, coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { END, ENTER, HOME, SPACE } from '@angular/cdk/keycodes';\nimport { ViewportRuler } from '@angular/cdk/scrolling';\nimport { FocusKeyManager, FocusMonitor, A11yModule } from '@angular/cdk/a11y';\nimport { Platform } from '@angular/cdk/platform';\nimport { ObserversModule } from '@angular/cdk/observers';\nimport { CommonModule } from '@angular/common';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/** *\n * Injection token for the MatInkBar's Positioner.\n  @type {?} */\nconst _MAT_INK_BAR_POSITIONER = new InjectionToken('MatInkBarPositioner', {\n    providedIn: 'root',\n    factory: _MAT_INK_BAR_POSITIONER_FACTORY\n});\n/**\n * The default positioner function for the MatInkBar.\n * \\@docs-private\n * @return {?}\n */\nfunction _MAT_INK_BAR_POSITIONER_FACTORY() {\n    /** @type {?} */\n    const method = (element) => ({\n        left: element ? (element.offsetLeft || 0) + 'px' : '0',\n        width: element ? (element.offsetWidth || 0) + 'px' : '0',\n    });\n    return method;\n}\n/**\n * The ink-bar is used to display and animate the line underneath the current active tab label.\n * \\@docs-private\n */\nclass MatInkBar {\n    /**\n     * @param {?} _elementRef\n     * @param {?} _ngZone\n     * @param {?} _inkBarPositioner\n     */\n    constructor(_elementRef, _ngZone, _inkBarPositioner) {\n        this._elementRef = _elementRef;\n        this._ngZone = _ngZone;\n        this._inkBarPositioner = _inkBarPositioner;\n    }\n    /**\n     * Calculates the styles from the provided element in order to align the ink-bar to that element.\n     * Shows the ink bar if previously set as hidden.\n     * @param {?} element\n     * @return {?}\n     */\n    alignToElement(element) {\n        this.show();\n        if (typeof requestAnimationFrame !== 'undefined') {\n            this._ngZone.runOutsideAngular(() => {\n                requestAnimationFrame(() => this._setStyles(element));\n            });\n        }\n        else {\n            this._setStyles(element);\n        }\n    }\n    /**\n     * Shows the ink bar.\n     * @return {?}\n     */\n    show() {\n        this._elementRef.nativeElement.style.visibility = 'visible';\n    }\n    /**\n     * Hides the ink bar.\n     * @return {?}\n     */\n    hide() {\n        this._elementRef.nativeElement.style.visibility = 'hidden';\n    }\n    /**\n     * Sets the proper styles to the ink bar element.\n     * @param {?} element\n     * @return {?}\n     */\n    _setStyles(element) {\n        /** @type {?} */\n        const positions = this._inkBarPositioner(element);\n        /** @type {?} */\n        const inkBar = this._elementRef.nativeElement;\n        inkBar.style.left = positions.left;\n        inkBar.style.width = positions.width;\n    }\n}\nMatInkBar.decorators = [\n    { type: Directive, args: [{\n                selector: 'mat-ink-bar',\n                host: {\n                    'class': 'mat-ink-bar',\n                },\n            },] },\n];\n/** @nocollapse */\nMatInkBar.ctorParameters = () => [\n    { type: ElementRef },\n    { type: NgZone },\n    { type: undefined, decorators: [{ type: Inject, args: [_MAT_INK_BAR_POSITIONER,] }] }\n];\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * Decorates the `ng-template` tags and reads out the template from it.\n */\nclass MatTabContent {\n    /**\n     * @param {?} template\n     */\n    constructor(template) {\n        this.template = template;\n    }\n}\nMatTabContent.decorators = [\n    { type: Directive, args: [{ selector: '[matTabContent]' },] },\n];\n/** @nocollapse */\nMatTabContent.ctorParameters = () => [\n    { type: TemplateRef }\n];\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst _CdkPortal = CdkPortal;\n/**\n * Used to flag tab labels for use with the portal directive\n */\nclass MatTabLabel extends _CdkPortal {\n}\nMatTabLabel.decorators = [\n    { type: Directive, args: [{\n                selector: '[mat-tab-label], [matTabLabel]',\n            },] },\n];\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * \\@docs-private\n */\nclass MatTabBase {\n}\n/** @type {?} */\nconst _MatTabMixinBase = mixinDisabled(MatTabBase);\nclass MatTab extends _MatTabMixinBase {\n    /**\n     * @param {?} _viewContainerRef\n     */\n    constructor(_viewContainerRef) {\n        super();\n        this._viewContainerRef = _viewContainerRef;\n        /**\n         * Plain text label for the tab, used when there is no template label.\n         */\n        this.textLabel = '';\n        /**\n         * Portal that will be the hosted content of the tab\n         */\n        this._contentPortal = null;\n        /**\n         * Emits whenever the internal state of the tab changes.\n         */\n        this._stateChanges = new Subject();\n        /**\n         * The relatively indexed position where 0 represents the center, negative is left, and positive\n         * represents the right.\n         */\n        this.position = null;\n        /**\n         * The initial relatively index origin of the tab if it was created and selected after there\n         * was already a selected tab. Provides context of what position the tab should originate from.\n         */\n        this.origin = null;\n        /**\n         * Whether the tab is currently active.\n         */\n        this.isActive = false;\n    }\n    /**\n     * \\@docs-private\n     * @return {?}\n     */\n    get content() {\n        return this._contentPortal;\n    }\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n    ngOnChanges(changes) {\n        if (changes.hasOwnProperty('textLabel') || changes.hasOwnProperty('disabled')) {\n            this._stateChanges.next();\n        }\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this._stateChanges.complete();\n    }\n    /**\n     * @return {?}\n     */\n    ngOnInit() {\n        this._contentPortal = new TemplatePortal(this._explicitContent || this._implicitContent, this._viewContainerRef);\n    }\n}\nMatTab.decorators = [\n    { type: Component, args: [{selector: 'mat-tab',\n                template: \"<ng-template><ng-content></ng-content></ng-template>\",\n                inputs: ['disabled'],\n                changeDetection: ChangeDetectionStrategy.OnPush,\n                encapsulation: ViewEncapsulation.None,\n                exportAs: 'matTab',\n            },] },\n];\n/** @nocollapse */\nMatTab.ctorParameters = () => [\n    { type: ViewContainerRef }\n];\nMatTab.propDecorators = {\n    templateLabel: [{ type: ContentChild, args: [MatTabLabel,] }],\n    _explicitContent: [{ type: ContentChild, args: [MatTabContent, { read: TemplateRef },] }],\n    _implicitContent: [{ type: ViewChild, args: [TemplateRef,] }],\n    textLabel: [{ type: Input, args: ['label',] }],\n    ariaLabel: [{ type: Input, args: ['aria-label',] }],\n    ariaLabelledby: [{ type: Input, args: ['aria-labelledby',] }]\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/** *\n * Animations used by the Material tabs.\n * \\@docs-private\n  @type {?} */\nconst matTabsAnimations = {\n    /** Animation translates a tab along the X axis. */\n    translateTab: trigger('translateTab', [\n        // Note: transitions to `none` instead of 0, because some browsers might blur the content.\n        state('center, void, left-origin-center, right-origin-center', style({ transform: 'none' })),\n        // If the tab is either on the left or right, we additionally add a `min-height` of 1px\n        // in order to ensure that the element has a height before its state changes. This is\n        // necessary because Chrome does seem to skip the transition in RTL mode if the element does\n        // not have a static height and is not rendered. See related issue: #9465\n        state('left', style({ transform: 'translate3d(-100%, 0, 0)', minHeight: '1px' })),\n        state('right', style({ transform: 'translate3d(100%, 0, 0)', minHeight: '1px' })),\n        transition('* => left, * => right, left => center, right => center', animate('500ms cubic-bezier(0.35, 0, 0.25, 1)')),\n        transition('void => left-origin-center', [\n            style({ transform: 'translate3d(-100%, 0, 0)' }),\n            animate('500ms cubic-bezier(0.35, 0, 0.25, 1)')\n        ]),\n        transition('void => right-origin-center', [\n            style({ transform: 'translate3d(100%, 0, 0)' }),\n            animate('500ms cubic-bezier(0.35, 0, 0.25, 1)')\n        ])\n    ])\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * The portal host directive for the contents of the tab.\n * \\@docs-private\n */\nclass MatTabBodyPortal extends CdkPortalOutlet {\n    /**\n     * @param {?} componentFactoryResolver\n     * @param {?} viewContainerRef\n     * @param {?} _host\n     */\n    constructor(componentFactoryResolver, viewContainerRef, _host) {\n        super(componentFactoryResolver, viewContainerRef);\n        this._host = _host;\n        /**\n         * Subscription to events for when the tab body begins centering.\n         */\n        this._centeringSub = Subscription.EMPTY;\n        /**\n         * Subscription to events for when the tab body finishes leaving from center position.\n         */\n        this._leavingSub = Subscription.EMPTY;\n    }\n    /**\n     * Set initial visibility or set up subscription for changing visibility.\n     * @return {?}\n     */\n    ngOnInit() {\n        super.ngOnInit();\n        this._centeringSub = this._host._beforeCentering\n            .pipe(startWith(this._host._isCenterPosition(this._host._position)))\n            .subscribe((isCentering) => {\n            if (isCentering && !this.hasAttached()) {\n                this.attach(this._host._content);\n            }\n        });\n        this._leavingSub = this._host._afterLeavingCenter.subscribe(() => {\n            this.detach();\n        });\n    }\n    /**\n     * Clean up centering subscription.\n     * @return {?}\n     */\n    ngOnDestroy() {\n        super.ngOnDestroy();\n        this._centeringSub.unsubscribe();\n        this._leavingSub.unsubscribe();\n    }\n}\nMatTabBodyPortal.decorators = [\n    { type: Directive, args: [{\n                selector: '[matTabBodyHost]'\n            },] },\n];\n/** @nocollapse */\nMatTabBodyPortal.ctorParameters = () => [\n    { type: ComponentFactoryResolver },\n    { type: ViewContainerRef },\n    { type: MatTabBody, decorators: [{ type: Inject, args: [forwardRef(() => MatTabBody),] }] }\n];\n/**\n * Wrapper for the contents of a tab.\n * \\@docs-private\n */\nclass MatTabBody {\n    /**\n     * @param {?} _elementRef\n     * @param {?} _dir\n     * @param {?=} changeDetectorRef\n     */\n    constructor(_elementRef, _dir, /**\n                   * @breaking-change 8.0.0 changeDetectorRef to be made required.\n                   */\n    changeDetectorRef) {\n        this._elementRef = _elementRef;\n        this._dir = _dir;\n        /**\n         * Subscription to the directionality change observable.\n         */\n        this._dirChangeSubscription = Subscription.EMPTY;\n        /**\n         * Event emitted when the tab begins to animate towards the center as the active tab.\n         */\n        this._onCentering = new EventEmitter();\n        /**\n         * Event emitted before the centering of the tab begins.\n         */\n        this._beforeCentering = new EventEmitter();\n        /**\n         * Event emitted before the centering of the tab begins.\n         */\n        this._afterLeavingCenter = new EventEmitter();\n        /**\n         * Event emitted when the tab completes its animation towards the center.\n         */\n        this._onCentered = new EventEmitter(true);\n        if (this._dir && changeDetectorRef) {\n            this._dirChangeSubscription = this._dir.change.subscribe((dir) => {\n                this._computePositionAnimationState(dir);\n                changeDetectorRef.markForCheck();\n            });\n        }\n    }\n    /**\n     * The shifted index position of the tab body, where zero represents the active center tab.\n     * @param {?} position\n     * @return {?}\n     */\n    set position(position) {\n        this._positionIndex = position;\n        this._computePositionAnimationState();\n    }\n    /**\n     * After initialized, check if the content is centered and has an origin. If so, set the\n     * special position states that transition the tab from the left or right before centering.\n     * @return {?}\n     */\n    ngOnInit() {\n        if (this._position == 'center' && this.origin != null) {\n            this._position = this._computePositionFromOrigin();\n        }\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this._dirChangeSubscription.unsubscribe();\n    }\n    /**\n     * @param {?} e\n     * @return {?}\n     */\n    _onTranslateTabStarted(e) {\n        /** @type {?} */\n        const isCentering = this._isCenterPosition(e.toState);\n        this._beforeCentering.emit(isCentering);\n        if (isCentering) {\n            this._onCentering.emit(this._elementRef.nativeElement.clientHeight);\n        }\n    }\n    /**\n     * @param {?} e\n     * @return {?}\n     */\n    _onTranslateTabComplete(e) {\n        // If the transition to the center is complete, emit an event.\n        if (this._isCenterPosition(e.toState) && this._isCenterPosition(this._position)) {\n            this._onCentered.emit();\n        }\n        if (this._isCenterPosition(e.fromState) && !this._isCenterPosition(this._position)) {\n            this._afterLeavingCenter.emit();\n        }\n    }\n    /**\n     * The text direction of the containing app.\n     * @return {?}\n     */\n    _getLayoutDirection() {\n        return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';\n    }\n    /**\n     * Whether the provided position state is considered center, regardless of origin.\n     * @param {?} position\n     * @return {?}\n     */\n    _isCenterPosition(position) {\n        return position == 'center' ||\n            position == 'left-origin-center' ||\n            position == 'right-origin-center';\n    }\n    /**\n     * Computes the position state that will be used for the tab-body animation trigger.\n     * @param {?=} dir\n     * @return {?}\n     */\n    _computePositionAnimationState(dir = this._getLayoutDirection()) {\n        if (this._positionIndex < 0) {\n            this._position = dir == 'ltr' ? 'left' : 'right';\n        }\n        else if (this._positionIndex > 0) {\n            this._position = dir == 'ltr' ? 'right' : 'left';\n        }\n        else {\n            this._position = 'center';\n        }\n    }\n    /**\n     * Computes the position state based on the specified origin position. This is used if the\n     * tab is becoming visible immediately after creation.\n     * @return {?}\n     */\n    _computePositionFromOrigin() {\n        /** @type {?} */\n        const dir = this._getLayoutDirection();\n        if ((dir == 'ltr' && this.origin <= 0) || (dir == 'rtl' && this.origin > 0)) {\n            return 'left-origin-center';\n        }\n        return 'right-origin-center';\n    }\n}\nMatTabBody.decorators = [\n    { type: Component, args: [{selector: 'mat-tab-body',\n                template: \"<div class=\\\"mat-tab-body-content\\\" #content [@translateTab]=\\\"_position\\\" (@translateTab.start)=\\\"_onTranslateTabStarted($event)\\\" (@translateTab.done)=\\\"_onTranslateTabComplete($event)\\\"><ng-template matTabBodyHost></ng-template></div>\",\n                styles: [\".mat-tab-body-content{height:100%;overflow:auto}.mat-tab-group-dynamic-height .mat-tab-body-content{overflow:hidden}\"],\n                encapsulation: ViewEncapsulation.None,\n                changeDetection: ChangeDetectionStrategy.OnPush,\n                animations: [matTabsAnimations.translateTab],\n                host: {\n                    'class': 'mat-tab-body',\n                },\n            },] },\n];\n/** @nocollapse */\nMatTabBody.ctorParameters = () => [\n    { type: ElementRef },\n    { type: Directionality, decorators: [{ type: Optional }] },\n    { type: ChangeDetectorRef }\n];\nMatTabBody.propDecorators = {\n    _onCentering: [{ type: Output }],\n    _beforeCentering: [{ type: Output }],\n    _afterLeavingCenter: [{ type: Output }],\n    _onCentered: [{ type: Output }],\n    _portalHost: [{ type: ViewChild, args: [PortalHostDirective,] }],\n    _content: [{ type: Input, args: ['content',] }],\n    origin: [{ type: Input }],\n    position: [{ type: Input }]\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * \\@docs-private\n */\nclass MatTabLabelWrapperBase {\n}\n/** @type {?} */\nconst _MatTabLabelWrapperMixinBase = mixinDisabled(MatTabLabelWrapperBase);\n/**\n * Used in the `mat-tab-group` view to display tab labels.\n * \\@docs-private\n */\nclass MatTabLabelWrapper extends _MatTabLabelWrapperMixinBase {\n    /**\n     * @param {?} elementRef\n     */\n    constructor(elementRef) {\n        super();\n        this.elementRef = elementRef;\n    }\n    /**\n     * Sets focus on the wrapper element\n     * @return {?}\n     */\n    focus() {\n        this.elementRef.nativeElement.focus();\n    }\n    /**\n     * @return {?}\n     */\n    getOffsetLeft() {\n        return this.elementRef.nativeElement.offsetLeft;\n    }\n    /**\n     * @return {?}\n     */\n    getOffsetWidth() {\n        return this.elementRef.nativeElement.offsetWidth;\n    }\n}\nMatTabLabelWrapper.decorators = [\n    { type: Directive, args: [{\n                selector: '[matTabLabelWrapper]',\n                inputs: ['disabled'],\n                host: {\n                    '[class.mat-tab-disabled]': 'disabled',\n                    '[attr.aria-disabled]': '!!disabled',\n                }\n            },] },\n];\n/** @nocollapse */\nMatTabLabelWrapper.ctorParameters = () => [\n    { type: ElementRef }\n];\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/** *\n * The distance in pixels that will be overshot when scrolling a tab label into view. This helps\n * provide a small affordance to the label next to it.\n  @type {?} */\nconst EXAGGERATED_OVERSCROLL = 60;\n/**\n * \\@docs-private\n */\nclass MatTabHeaderBase {\n}\n/** @type {?} */\nconst _MatTabHeaderMixinBase = mixinDisableRipple(MatTabHeaderBase);\n/**\n * The header of the tab group which displays a list of all the tabs in the tab group. Includes\n * an ink bar that follows the currently selected tab. When the tabs list's width exceeds the\n * width of the header container, then arrows will be displayed to allow the user to scroll\n * left and right across the header.\n * \\@docs-private\n */\nclass MatTabHeader extends _MatTabHeaderMixinBase {\n    /**\n     * @param {?} _elementRef\n     * @param {?} _changeDetectorRef\n     * @param {?} _viewportRuler\n     * @param {?} _dir\n     * @param {?=} _ngZone\n     */\n    constructor(_elementRef, _changeDetectorRef, _viewportRuler, _dir, _ngZone) {\n        super();\n        this._elementRef = _elementRef;\n        this._changeDetectorRef = _changeDetectorRef;\n        this._viewportRuler = _viewportRuler;\n        this._dir = _dir;\n        this._ngZone = _ngZone;\n        /**\n         * The distance in pixels that the tab labels should be translated to the left.\n         */\n        this._scrollDistance = 0;\n        /**\n         * Whether the header should scroll to the selected index after the view has been checked.\n         */\n        this._selectedIndexChanged = false;\n        /**\n         * Emits when the component is destroyed.\n         */\n        this._destroyed = new Subject();\n        /**\n         * Whether the controls for pagination should be displayed\n         */\n        this._showPaginationControls = false;\n        /**\n         * Whether the tab list can be scrolled more towards the end of the tab label list.\n         */\n        this._disableScrollAfter = true;\n        /**\n         * Whether the tab list can be scrolled more towards the beginning of the tab label list.\n         */\n        this._disableScrollBefore = true;\n        this._selectedIndex = 0;\n        /**\n         * Event emitted when the option is selected.\n         */\n        this.selectFocusedIndex = new EventEmitter();\n        /**\n         * Event emitted when a label is focused.\n         */\n        this.indexFocused = new EventEmitter();\n    }\n    /**\n     * The index of the active tab.\n     * @return {?}\n     */\n    get selectedIndex() { return this._selectedIndex; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set selectedIndex(value) {\n        value = coerceNumberProperty(value);\n        this._selectedIndexChanged = this._selectedIndex != value;\n        this._selectedIndex = value;\n        if (this._keyManager) {\n            this._keyManager.updateActiveItemIndex(value);\n        }\n    }\n    /**\n     * @return {?}\n     */\n    ngAfterContentChecked() {\n        // If the number of tab labels have changed, check if scrolling should be enabled\n        if (this._tabLabelCount != this._labelWrappers.length) {\n            this._updatePagination();\n            this._tabLabelCount = this._labelWrappers.length;\n            this._changeDetectorRef.markForCheck();\n        }\n        // If the selected index has changed, scroll to the label and check if the scrolling controls\n        // should be disabled.\n        if (this._selectedIndexChanged) {\n            this._scrollToLabel(this._selectedIndex);\n            this._checkScrollingControls();\n            this._alignInkBarToSelectedTab();\n            this._selectedIndexChanged = false;\n            this._changeDetectorRef.markForCheck();\n        }\n        // If the scroll distance has been changed (tab selected, focused, scroll controls activated),\n        // then translate the header to reflect this.\n        if (this._scrollDistanceChanged) {\n            this._updateTabScrollPosition();\n            this._scrollDistanceChanged = false;\n            this._changeDetectorRef.markForCheck();\n        }\n    }\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n    _handleKeydown(event) {\n        switch (event.keyCode) {\n            case HOME:\n                this._keyManager.setFirstItemActive();\n                event.preventDefault();\n                break;\n            case END:\n                this._keyManager.setLastItemActive();\n                event.preventDefault();\n                break;\n            case ENTER:\n            case SPACE:\n                this.selectFocusedIndex.emit(this.focusIndex);\n                event.preventDefault();\n                break;\n            default:\n                this._keyManager.onKeydown(event);\n        }\n    }\n    /**\n     * Aligns the ink bar to the selected tab on load.\n     * @return {?}\n     */\n    ngAfterContentInit() {\n        /** @type {?} */\n        const dirChange = this._dir ? this._dir.change : of(null);\n        /** @type {?} */\n        const resize = this._viewportRuler.change(150);\n        /** @type {?} */\n        const realign = () => {\n            this._updatePagination();\n            this._alignInkBarToSelectedTab();\n        };\n        this._keyManager = new FocusKeyManager(this._labelWrappers)\n            .withHorizontalOrientation(this._getLayoutDirection())\n            .withWrap();\n        this._keyManager.updateActiveItem(0);\n        // Defer the first call in order to allow for slower browsers to lay out the elements.\n        // This helps in cases where the user lands directly on a page with paginated tabs.\n        typeof requestAnimationFrame !== 'undefined' ? requestAnimationFrame(realign) : realign();\n        // On dir change or window resize, realign the ink bar and update the orientation of\n        // the key manager if the direction has changed.\n        merge(dirChange, resize).pipe(takeUntil(this._destroyed)).subscribe(() => {\n            realign();\n            this._keyManager.withHorizontalOrientation(this._getLayoutDirection());\n        });\n        // If there is a change in the focus key manager we need to emit the `indexFocused`\n        // event in order to provide a public event that notifies about focus changes. Also we realign\n        // the tabs container by scrolling the new focused tab into the visible section.\n        this._keyManager.change.pipe(takeUntil(this._destroyed)).subscribe(newFocusIndex => {\n            this.indexFocused.emit(newFocusIndex);\n            this._setTabFocus(newFocusIndex);\n        });\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this._destroyed.next();\n        this._destroyed.complete();\n    }\n    /**\n     * Callback for when the MutationObserver detects that the content has changed.\n     * @return {?}\n     */\n    _onContentChanges() {\n        /** @type {?} */\n        const zoneCallback = () => {\n            this._updatePagination();\n            this._alignInkBarToSelectedTab();\n            this._changeDetectorRef.markForCheck();\n        };\n        // The content observer runs outside the `NgZone` by default, which\n        // means that we need to bring the callback back in ourselves.\n        // @breaking-change 8.0.0 Remove null check for `_ngZone` once it's a required parameter.\n        this._ngZone ? this._ngZone.run(zoneCallback) : zoneCallback();\n    }\n    /**\n     * Updating the view whether pagination should be enabled or not\n     * @return {?}\n     */\n    _updatePagination() {\n        this._checkPaginationEnabled();\n        this._checkScrollingControls();\n        this._updateTabScrollPosition();\n    }\n    /**\n     * Tracks which element has focus; used for keyboard navigation\n     * @return {?}\n     */\n    get focusIndex() {\n        return this._keyManager ? /** @type {?} */ ((this._keyManager.activeItemIndex)) : 0;\n    }\n    /**\n     * When the focus index is set, we must manually send focus to the correct label\n     * @param {?} value\n     * @return {?}\n     */\n    set focusIndex(value) {\n        if (!this._isValidIndex(value) || this.focusIndex === value || !this._keyManager) {\n            return;\n        }\n        this._keyManager.setActiveItem(value);\n    }\n    /**\n     * Determines if an index is valid.  If the tabs are not ready yet, we assume that the user is\n     * providing a valid index and return true.\n     * @param {?} index\n     * @return {?}\n     */\n    _isValidIndex(index) {\n        if (!this._labelWrappers) {\n            return true;\n        }\n        /** @type {?} */\n        const tab = this._labelWrappers ? this._labelWrappers.toArray()[index] : null;\n        return !!tab && !tab.disabled;\n    }\n    /**\n     * Sets focus on the HTML element for the label wrapper and scrolls it into the view if\n     * scrolling is enabled.\n     * @param {?} tabIndex\n     * @return {?}\n     */\n    _setTabFocus(tabIndex) {\n        if (this._showPaginationControls) {\n            this._scrollToLabel(tabIndex);\n        }\n        if (this._labelWrappers && this._labelWrappers.length) {\n            this._labelWrappers.toArray()[tabIndex].focus();\n            /** @type {?} */\n            const containerEl = this._tabListContainer.nativeElement;\n            /** @type {?} */\n            const dir = this._getLayoutDirection();\n            if (dir == 'ltr') {\n                containerEl.scrollLeft = 0;\n            }\n            else {\n                containerEl.scrollLeft = containerEl.scrollWidth - containerEl.offsetWidth;\n            }\n        }\n    }\n    /**\n     * The layout direction of the containing app.\n     * @return {?}\n     */\n    _getLayoutDirection() {\n        return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';\n    }\n    /**\n     * Performs the CSS transformation on the tab list that will cause the list to scroll.\n     * @return {?}\n     */\n    _updateTabScrollPosition() {\n        /** @type {?} */\n        const scrollDistance = this.scrollDistance;\n        /** @type {?} */\n        const translateX = this._getLayoutDirection() === 'ltr' ? -scrollDistance : scrollDistance;\n        // Don't use `translate3d` here because we don't want to create a new layer. A new layer\n        // seems to cause flickering and overflow in Internet Explorer. For example, the ink bar\n        // and ripples will exceed the boundaries of the visible tab bar.\n        // See: https://github.com/angular/material2/issues/10276\n        this._tabList.nativeElement.style.transform = `translateX(${translateX}px)`;\n    }\n    /**\n     * Sets the distance in pixels that the tab header should be transformed in the X-axis.\n     * @return {?}\n     */\n    get scrollDistance() { return this._scrollDistance; }\n    /**\n     * @param {?} v\n     * @return {?}\n     */\n    set scrollDistance(v) {\n        this._scrollDistance = Math.max(0, Math.min(this._getMaxScrollDistance(), v));\n        // Mark that the scroll distance has changed so that after the view is checked, the CSS\n        // transformation can move the header.\n        this._scrollDistanceChanged = true;\n        this._checkScrollingControls();\n    }\n    /**\n     * Moves the tab list in the 'before' or 'after' direction (towards the beginning of the list or\n     * the end of the list, respectively). The distance to scroll is computed to be a third of the\n     * length of the tab list view window.\n     *\n     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n     * should be called sparingly.\n     * @param {?} scrollDir\n     * @return {?}\n     */\n    _scrollHeader(scrollDir) {\n        /** @type {?} */\n        const viewLength = this._tabListContainer.nativeElement.offsetWidth;\n        // Move the scroll distance one-third the length of the tab list's viewport.\n        this.scrollDistance += (scrollDir == 'before' ? -1 : 1) * viewLength / 3;\n    }\n    /**\n     * Moves the tab list such that the desired tab label (marked by index) is moved into view.\n     *\n     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n     * should be called sparingly.\n     * @param {?} labelIndex\n     * @return {?}\n     */\n    _scrollToLabel(labelIndex) {\n        /** @type {?} */\n        const selectedLabel = this._labelWrappers ? this._labelWrappers.toArray()[labelIndex] : null;\n        if (!selectedLabel) {\n            return;\n        }\n        /** @type {?} */\n        const viewLength = this._tabListContainer.nativeElement.offsetWidth;\n        /** @type {?} */\n        let labelBeforePos;\n        /** @type {?} */\n        let labelAfterPos;\n        if (this._getLayoutDirection() == 'ltr') {\n            labelBeforePos = selectedLabel.getOffsetLeft();\n            labelAfterPos = labelBeforePos + selectedLabel.getOffsetWidth();\n        }\n        else {\n            labelAfterPos = this._tabList.nativeElement.offsetWidth - selectedLabel.getOffsetLeft();\n            labelBeforePos = labelAfterPos - selectedLabel.getOffsetWidth();\n        }\n        /** @type {?} */\n        const beforeVisiblePos = this.scrollDistance;\n        /** @type {?} */\n        const afterVisiblePos = this.scrollDistance + viewLength;\n        if (labelBeforePos < beforeVisiblePos) {\n            // Scroll header to move label to the before direction\n            this.scrollDistance -= beforeVisiblePos - labelBeforePos + EXAGGERATED_OVERSCROLL;\n        }\n        else if (labelAfterPos > afterVisiblePos) {\n            // Scroll header to move label to the after direction\n            this.scrollDistance += labelAfterPos - afterVisiblePos + EXAGGERATED_OVERSCROLL;\n        }\n    }\n    /**\n     * Evaluate whether the pagination controls should be displayed. If the scroll width of the\n     * tab list is wider than the size of the header container, then the pagination controls should\n     * be shown.\n     *\n     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n     * should be called sparingly.\n     * @return {?}\n     */\n    _checkPaginationEnabled() {\n        /** @type {?} */\n        const isEnabled = this._tabList.nativeElement.scrollWidth > this._elementRef.nativeElement.offsetWidth;\n        if (!isEnabled) {\n            this.scrollDistance = 0;\n        }\n        if (isEnabled !== this._showPaginationControls) {\n            this._changeDetectorRef.markForCheck();\n        }\n        this._showPaginationControls = isEnabled;\n    }\n    /**\n     * Evaluate whether the before and after controls should be enabled or disabled.\n     * If the header is at the beginning of the list (scroll distance is equal to 0) then disable the\n     * before button. If the header is at the end of the list (scroll distance is equal to the\n     * maximum distance we can scroll), then disable the after button.\n     *\n     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n     * should be called sparingly.\n     * @return {?}\n     */\n    _checkScrollingControls() {\n        // Check if the pagination arrows should be activated.\n        this._disableScrollBefore = this.scrollDistance == 0;\n        this._disableScrollAfter = this.scrollDistance == this._getMaxScrollDistance();\n        this._changeDetectorRef.markForCheck();\n    }\n    /**\n     * Determines what is the maximum length in pixels that can be set for the scroll distance. This\n     * is equal to the difference in width between the tab list container and tab header container.\n     *\n     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n     * should be called sparingly.\n     * @return {?}\n     */\n    _getMaxScrollDistance() {\n        /** @type {?} */\n        const lengthOfTabList = this._tabList.nativeElement.scrollWidth;\n        /** @type {?} */\n        const viewLength = this._tabListContainer.nativeElement.offsetWidth;\n        return (lengthOfTabList - viewLength) || 0;\n    }\n    /**\n     * Tells the ink-bar to align itself to the current label wrapper\n     * @return {?}\n     */\n    _alignInkBarToSelectedTab() {\n        /** @type {?} */\n        const selectedLabelWrapper = this._labelWrappers && this._labelWrappers.length ?\n            this._labelWrappers.toArray()[this.selectedIndex].elementRef.nativeElement :\n            null;\n        this._inkBar.alignToElement(/** @type {?} */ ((selectedLabelWrapper)));\n    }\n}\nMatTabHeader.decorators = [\n    { type: Component, args: [{selector: 'mat-tab-header',\n                template: \"<div class=\\\"mat-tab-header-pagination mat-tab-header-pagination-before mat-elevation-z4\\\" aria-hidden=\\\"true\\\" mat-ripple [matRippleDisabled]=\\\"_disableScrollBefore || disableRipple\\\" [class.mat-tab-header-pagination-disabled]=\\\"_disableScrollBefore\\\" (click)=\\\"_scrollHeader('before')\\\"><div class=\\\"mat-tab-header-pagination-chevron\\\"></div></div><div class=\\\"mat-tab-label-container\\\" #tabListContainer (keydown)=\\\"_handleKeydown($event)\\\"><div class=\\\"mat-tab-list\\\" #tabList role=\\\"tablist\\\" (cdkObserveContent)=\\\"_onContentChanges()\\\"><div class=\\\"mat-tab-labels\\\"><ng-content></ng-content></div><mat-ink-bar></mat-ink-bar></div></div><div class=\\\"mat-tab-header-pagination mat-tab-header-pagination-after mat-elevation-z4\\\" aria-hidden=\\\"true\\\" mat-ripple [matRippleDisabled]=\\\"_disableScrollAfter || disableRipple\\\" [class.mat-tab-header-pagination-disabled]=\\\"_disableScrollAfter\\\" (click)=\\\"_scrollHeader('after')\\\"><div class=\\\"mat-tab-header-pagination-chevron\\\"></div></div>\",\n                styles: [\".mat-tab-header{display:flex;overflow:hidden;position:relative;flex-shrink:0}.mat-tab-label{height:48px;padding:0 24px;cursor:pointer;box-sizing:border-box;opacity:.6;min-width:160px;text-align:center;display:inline-flex;justify-content:center;align-items:center;white-space:nowrap;position:relative}.mat-tab-label:focus{outline:0}.mat-tab-label:focus:not(.mat-tab-disabled){opacity:1}@media screen and (-ms-high-contrast:active){.mat-tab-label:focus{outline:dotted 2px}}.mat-tab-label.mat-tab-disabled{cursor:default}@media screen and (-ms-high-contrast:active){.mat-tab-label.mat-tab-disabled{opacity:.5}}.mat-tab-label .mat-tab-label-content{display:inline-flex;justify-content:center;align-items:center;white-space:nowrap}@media screen and (-ms-high-contrast:active){.mat-tab-label{opacity:1}}@media (max-width:599px){.mat-tab-label{min-width:72px}}.mat-ink-bar{position:absolute;bottom:0;height:2px;transition:.5s cubic-bezier(.35,0,.25,1)}.mat-tab-group-inverted-header .mat-ink-bar{bottom:auto;top:0}@media screen and (-ms-high-contrast:active){.mat-ink-bar{outline:solid 2px;height:0}}.mat-tab-header-pagination{position:relative;display:none;justify-content:center;align-items:center;min-width:32px;cursor:pointer;z-index:2}.mat-tab-header-pagination-controls-enabled .mat-tab-header-pagination{display:flex}.mat-tab-header-pagination-before,.mat-tab-header-rtl .mat-tab-header-pagination-after{padding-left:4px}.mat-tab-header-pagination-before .mat-tab-header-pagination-chevron,.mat-tab-header-rtl .mat-tab-header-pagination-after .mat-tab-header-pagination-chevron{transform:rotate(-135deg)}.mat-tab-header-pagination-after,.mat-tab-header-rtl .mat-tab-header-pagination-before{padding-right:4px}.mat-tab-header-pagination-after .mat-tab-header-pagination-chevron,.mat-tab-header-rtl .mat-tab-header-pagination-before .mat-tab-header-pagination-chevron{transform:rotate(45deg)}.mat-tab-header-pagination-chevron{border-style:solid;border-width:2px 2px 0 0;content:'';height:8px;width:8px}.mat-tab-header-pagination-disabled{box-shadow:none;cursor:default}.mat-tab-label-container{display:flex;flex-grow:1;overflow:hidden;z-index:1}.mat-tab-list{flex-grow:1;position:relative;transition:transform .5s cubic-bezier(.35,0,.25,1)}.mat-tab-labels{display:flex}[mat-align-tabs=center] .mat-tab-labels{justify-content:center}[mat-align-tabs=end] .mat-tab-labels{justify-content:flex-end}\"],\n                inputs: ['disableRipple'],\n                encapsulation: ViewEncapsulation.None,\n                changeDetection: ChangeDetectionStrategy.OnPush,\n                host: {\n                    'class': 'mat-tab-header',\n                    '[class.mat-tab-header-pagination-controls-enabled]': '_showPaginationControls',\n                    '[class.mat-tab-header-rtl]': \"_getLayoutDirection() == 'rtl'\",\n                },\n            },] },\n];\n/** @nocollapse */\nMatTabHeader.ctorParameters = () => [\n    { type: ElementRef },\n    { type: ChangeDetectorRef },\n    { type: ViewportRuler },\n    { type: Directionality, decorators: [{ type: Optional }] },\n    { type: NgZone }\n];\nMatTabHeader.propDecorators = {\n    _labelWrappers: [{ type: ContentChildren, args: [MatTabLabelWrapper,] }],\n    _inkBar: [{ type: ViewChild, args: [MatInkBar,] }],\n    _tabListContainer: [{ type: ViewChild, args: ['tabListContainer',] }],\n    _tabList: [{ type: ViewChild, args: ['tabList',] }],\n    selectedIndex: [{ type: Input }],\n    selectFocusedIndex: [{ type: Output }],\n    indexFocused: [{ type: Output }]\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/** *\n * Used to generate unique ID's for each tab component\n  @type {?} */\nlet nextId = 0;\n/**\n * A simple change event emitted on focus or selection changes.\n */\nclass MatTabChangeEvent {\n}\n/**\n * \\@docs-private\n */\nclass MatTabGroupBase {\n    /**\n     * @param {?} _elementRef\n     */\n    constructor(_elementRef) {\n        this._elementRef = _elementRef;\n    }\n}\n/** @type {?} */\nconst _MatTabGroupMixinBase = mixinColor(mixinDisableRipple(MatTabGroupBase), 'primary');\n/**\n * Material design tab-group component.  Supports basic tab pairs (label + content) and includes\n * animated ink-bar, keyboard navigation, and screen reader.\n * See: https://material.io/design/components/tabs.html\n */\nclass MatTabGroup extends _MatTabGroupMixinBase {\n    /**\n     * @param {?} elementRef\n     * @param {?} _changeDetectorRef\n     */\n    constructor(elementRef, _changeDetectorRef) {\n        super(elementRef);\n        this._changeDetectorRef = _changeDetectorRef;\n        /**\n         * The tab index that should be selected after the content has been checked.\n         */\n        this._indexToSelect = 0;\n        /**\n         * Snapshot of the height of the tab body wrapper before another tab is activated.\n         */\n        this._tabBodyWrapperHeight = 0;\n        /**\n         * Subscription to tabs being added/removed.\n         */\n        this._tabsSubscription = Subscription.EMPTY;\n        /**\n         * Subscription to changes in the tab labels.\n         */\n        this._tabLabelSubscription = Subscription.EMPTY;\n        this._dynamicHeight = false;\n        this._selectedIndex = null;\n        /**\n         * Position of the tab header.\n         */\n        this.headerPosition = 'above';\n        /**\n         * Output to enable support for two-way binding on `[(selectedIndex)]`\n         */\n        this.selectedIndexChange = new EventEmitter();\n        /**\n         * Event emitted when focus has changed within a tab group.\n         */\n        this.focusChange = new EventEmitter();\n        /**\n         * Event emitted when the body animation has completed\n         */\n        this.animationDone = new EventEmitter();\n        /**\n         * Event emitted when the tab selection has changed.\n         */\n        this.selectedTabChange = new EventEmitter(true);\n        this._groupId = nextId++;\n    }\n    /**\n     * Whether the tab group should grow to the size of the active tab.\n     * @return {?}\n     */\n    get dynamicHeight() { return this._dynamicHeight; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set dynamicHeight(value) { this._dynamicHeight = coerceBooleanProperty(value); }\n    /**\n     * The index of the active tab.\n     * @return {?}\n     */\n    get selectedIndex() { return this._selectedIndex; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set selectedIndex(value) {\n        this._indexToSelect = coerceNumberProperty(value, null);\n    }\n    /**\n     * Background color of the tab group.\n     * @return {?}\n     */\n    get backgroundColor() { return this._backgroundColor; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set backgroundColor(value) {\n        /** @type {?} */\n        const nativeElement = this._elementRef.nativeElement;\n        nativeElement.classList.remove(`mat-background-${this.backgroundColor}`);\n        if (value) {\n            nativeElement.classList.add(`mat-background-${value}`);\n        }\n        this._backgroundColor = value;\n    }\n    /**\n     * After the content is checked, this component knows what tabs have been defined\n     * and what the selected index should be. This is where we can know exactly what position\n     * each tab should be in according to the new selected index, and additionally we know how\n     * a new selected tab should transition in (from the left or right).\n     * @return {?}\n     */\n    ngAfterContentChecked() {\n        /** @type {?} */\n        const indexToSelect = this._indexToSelect = this._clampTabIndex(this._indexToSelect);\n        // If there is a change in selected index, emit a change event. Should not trigger if\n        // the selected index has not yet been initialized.\n        if (this._selectedIndex != indexToSelect) {\n            /** @type {?} */\n            const isFirstRun = this._selectedIndex == null;\n            if (!isFirstRun) {\n                this.selectedTabChange.emit(this._createChangeEvent(indexToSelect));\n            }\n            // Changing these values after change detection has run\n            // since the checked content may contain references to them.\n            Promise.resolve().then(() => {\n                this._tabs.forEach((tab, index) => tab.isActive = index === indexToSelect);\n                if (!isFirstRun) {\n                    this.selectedIndexChange.emit(indexToSelect);\n                }\n            });\n        }\n        // Setup the position for each tab and optionally setup an origin on the next selected tab.\n        this._tabs.forEach((tab, index) => {\n            tab.position = index - indexToSelect;\n            // If there is already a selected tab, then set up an origin for the next selected tab\n            // if it doesn't have one already.\n            if (this._selectedIndex != null && tab.position == 0 && !tab.origin) {\n                tab.origin = indexToSelect - this._selectedIndex;\n            }\n        });\n        if (this._selectedIndex !== indexToSelect) {\n            this._selectedIndex = indexToSelect;\n            this._changeDetectorRef.markForCheck();\n        }\n    }\n    /**\n     * @return {?}\n     */\n    ngAfterContentInit() {\n        this._subscribeToTabLabels();\n        // Subscribe to changes in the amount of tabs, in order to be\n        // able to re-render the content as new tabs are added or removed.\n        this._tabsSubscription = this._tabs.changes.subscribe(() => {\n            /** @type {?} */\n            const indexToSelect = this._clampTabIndex(this._indexToSelect);\n            // Maintain the previously-selected tab if a new tab is added or removed and there is no\n            // explicit change that selects a different tab.\n            if (indexToSelect === this._selectedIndex) {\n                /** @type {?} */\n                const tabs = this._tabs.toArray();\n                for (let i = 0; i < tabs.length; i++) {\n                    if (tabs[i].isActive) {\n                        // Assign both to the `_indexToSelect` and `_selectedIndex` so we don't fire a changed\n                        // event, otherwise the consumer may end up in an infinite loop in some edge cases like\n                        // adding a tab within the `selectedIndexChange` event.\n                        this._indexToSelect = this._selectedIndex = i;\n                        break;\n                    }\n                }\n            }\n            this._subscribeToTabLabels();\n            this._changeDetectorRef.markForCheck();\n        });\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this._tabsSubscription.unsubscribe();\n        this._tabLabelSubscription.unsubscribe();\n    }\n    /**\n     * Re-aligns the ink bar to the selected tab element.\n     * @return {?}\n     */\n    realignInkBar() {\n        if (this._tabHeader) {\n            this._tabHeader._alignInkBarToSelectedTab();\n        }\n    }\n    /**\n     * @param {?} index\n     * @return {?}\n     */\n    _focusChanged(index) {\n        this.focusChange.emit(this._createChangeEvent(index));\n    }\n    /**\n     * @param {?} index\n     * @return {?}\n     */\n    _createChangeEvent(index) {\n        /** @type {?} */\n        const event = new MatTabChangeEvent;\n        event.index = index;\n        if (this._tabs && this._tabs.length) {\n            event.tab = this._tabs.toArray()[index];\n        }\n        return event;\n    }\n    /**\n     * Subscribes to changes in the tab labels. This is needed, because the \\@Input for the label is\n     * on the MatTab component, whereas the data binding is inside the MatTabGroup. In order for the\n     * binding to be updated, we need to subscribe to changes in it and trigger change detection\n     * manually.\n     * @return {?}\n     */\n    _subscribeToTabLabels() {\n        if (this._tabLabelSubscription) {\n            this._tabLabelSubscription.unsubscribe();\n        }\n        this._tabLabelSubscription = merge(...this._tabs.map(tab => tab._stateChanges))\n            .subscribe(() => this._changeDetectorRef.markForCheck());\n    }\n    /**\n     * Clamps the given index to the bounds of 0 and the tabs length.\n     * @param {?} index\n     * @return {?}\n     */\n    _clampTabIndex(index) {\n        // Note the `|| 0`, which ensures that values like NaN can't get through\n        // and which would otherwise throw the component into an infinite loop\n        // (since Math.max(NaN, 0) === NaN).\n        return Math.min(this._tabs.length - 1, Math.max(index || 0, 0));\n    }\n    /**\n     * Returns a unique id for each tab label element\n     * @param {?} i\n     * @return {?}\n     */\n    _getTabLabelId(i) {\n        return `mat-tab-label-${this._groupId}-${i}`;\n    }\n    /**\n     * Returns a unique id for each tab content element\n     * @param {?} i\n     * @return {?}\n     */\n    _getTabContentId(i) {\n        return `mat-tab-content-${this._groupId}-${i}`;\n    }\n    /**\n     * Sets the height of the body wrapper to the height of the activating tab if dynamic\n     * height property is true.\n     * @param {?} tabHeight\n     * @return {?}\n     */\n    _setTabBodyWrapperHeight(tabHeight) {\n        if (!this._dynamicHeight || !this._tabBodyWrapperHeight) {\n            return;\n        }\n        /** @type {?} */\n        const wrapper = this._tabBodyWrapper.nativeElement;\n        wrapper.style.height = this._tabBodyWrapperHeight + 'px';\n        // This conditional forces the browser to paint the height so that\n        // the animation to the new height can have an origin.\n        if (this._tabBodyWrapper.nativeElement.offsetHeight) {\n            wrapper.style.height = tabHeight + 'px';\n        }\n    }\n    /**\n     * Removes the height of the tab body wrapper.\n     * @return {?}\n     */\n    _removeTabBodyWrapperHeight() {\n        this._tabBodyWrapperHeight = this._tabBodyWrapper.nativeElement.clientHeight;\n        this._tabBodyWrapper.nativeElement.style.height = '';\n        this.animationDone.emit();\n    }\n    /**\n     * Handle click events, setting new selected index if appropriate.\n     * @param {?} tab\n     * @param {?} tabHeader\n     * @param {?} idx\n     * @return {?}\n     */\n    _handleClick(tab, tabHeader, idx) {\n        if (!tab.disabled) {\n            this.selectedIndex = tabHeader.focusIndex = idx;\n        }\n    }\n    /**\n     * Retrieves the tabindex for the tab.\n     * @param {?} tab\n     * @param {?} idx\n     * @return {?}\n     */\n    _getTabIndex(tab, idx) {\n        if (tab.disabled) {\n            return null;\n        }\n        return this.selectedIndex === idx ? 0 : -1;\n    }\n}\nMatTabGroup.decorators = [\n    { type: Component, args: [{selector: 'mat-tab-group',\n                exportAs: 'matTabGroup',\n                template: \"<mat-tab-header #tabHeader [selectedIndex]=\\\"selectedIndex\\\" [disableRipple]=\\\"disableRipple\\\" (indexFocused)=\\\"_focusChanged($event)\\\" (selectFocusedIndex)=\\\"selectedIndex = $event\\\"><div class=\\\"mat-tab-label\\\" role=\\\"tab\\\" matTabLabelWrapper mat-ripple cdkMonitorElementFocus *ngFor=\\\"let tab of _tabs; let i = index\\\" [id]=\\\"_getTabLabelId(i)\\\" [attr.tabIndex]=\\\"_getTabIndex(tab, i)\\\" [attr.aria-posinset]=\\\"i + 1\\\" [attr.aria-setsize]=\\\"_tabs.length\\\" [attr.aria-controls]=\\\"_getTabContentId(i)\\\" [attr.aria-selected]=\\\"selectedIndex == i\\\" [attr.aria-label]=\\\"tab.ariaLabel || null\\\" [attr.aria-labelledby]=\\\"(!tab.ariaLabel && tab.ariaLabelledby) ? tab.ariaLabelledby : null\\\" [class.mat-tab-label-active]=\\\"selectedIndex == i\\\" [disabled]=\\\"tab.disabled\\\" [matRippleDisabled]=\\\"tab.disabled || disableRipple\\\" (click)=\\\"_handleClick(tab, tabHeader, i)\\\"><div class=\\\"mat-tab-label-content\\\"><ng-template [ngIf]=\\\"tab.templateLabel\\\"><ng-template [cdkPortalOutlet]=\\\"tab.templateLabel\\\"></ng-template></ng-template><ng-template [ngIf]=\\\"!tab.templateLabel\\\">{{tab.textLabel}}</ng-template></div></div></mat-tab-header><div class=\\\"mat-tab-body-wrapper\\\" #tabBodyWrapper><mat-tab-body role=\\\"tabpanel\\\" *ngFor=\\\"let tab of _tabs; let i = index\\\" [id]=\\\"_getTabContentId(i)\\\" [attr.aria-labelledby]=\\\"_getTabLabelId(i)\\\" [class.mat-tab-body-active]=\\\"selectedIndex == i\\\" [content]=\\\"tab.content\\\" [position]=\\\"tab.position\\\" [origin]=\\\"tab.origin\\\" (_onCentered)=\\\"_removeTabBodyWrapperHeight()\\\" (_onCentering)=\\\"_setTabBodyWrapperHeight($event)\\\"></mat-tab-body></div>\",\n                styles: [\".mat-tab-group{display:flex;flex-direction:column}.mat-tab-group.mat-tab-group-inverted-header{flex-direction:column-reverse}.mat-tab-label{height:48px;padding:0 24px;cursor:pointer;box-sizing:border-box;opacity:.6;min-width:160px;text-align:center;display:inline-flex;justify-content:center;align-items:center;white-space:nowrap;position:relative}.mat-tab-label:focus{outline:0}.mat-tab-label:focus:not(.mat-tab-disabled){opacity:1}@media screen and (-ms-high-contrast:active){.mat-tab-label:focus{outline:dotted 2px}}.mat-tab-label.mat-tab-disabled{cursor:default}@media screen and (-ms-high-contrast:active){.mat-tab-label.mat-tab-disabled{opacity:.5}}.mat-tab-label .mat-tab-label-content{display:inline-flex;justify-content:center;align-items:center;white-space:nowrap}@media screen and (-ms-high-contrast:active){.mat-tab-label{opacity:1}}@media (max-width:599px){.mat-tab-label{padding:0 12px}}@media (max-width:959px){.mat-tab-label{padding:0 12px}}.mat-tab-group[mat-stretch-tabs]>.mat-tab-header .mat-tab-label{flex-basis:0;flex-grow:1}.mat-tab-body-wrapper{position:relative;overflow:hidden;display:flex;transition:height .5s cubic-bezier(.35,0,.25,1)}.mat-tab-body{top:0;left:0;right:0;bottom:0;position:absolute;display:block;overflow:hidden;flex-basis:100%}.mat-tab-body.mat-tab-body-active{position:relative;overflow-x:hidden;overflow-y:auto;z-index:1;flex-grow:1}.mat-tab-group.mat-tab-group-dynamic-height .mat-tab-body.mat-tab-body-active{overflow-y:hidden}\"],\n                encapsulation: ViewEncapsulation.None,\n                changeDetection: ChangeDetectionStrategy.OnPush,\n                inputs: ['color', 'disableRipple'],\n                host: {\n                    'class': 'mat-tab-group',\n                    '[class.mat-tab-group-dynamic-height]': 'dynamicHeight',\n                    '[class.mat-tab-group-inverted-header]': 'headerPosition === \"below\"',\n                },\n            },] },\n];\n/** @nocollapse */\nMatTabGroup.ctorParameters = () => [\n    { type: ElementRef },\n    { type: ChangeDetectorRef }\n];\nMatTabGroup.propDecorators = {\n    _tabs: [{ type: ContentChildren, args: [MatTab,] }],\n    _tabBodyWrapper: [{ type: ViewChild, args: ['tabBodyWrapper',] }],\n    _tabHeader: [{ type: ViewChild, args: ['tabHeader',] }],\n    dynamicHeight: [{ type: Input }],\n    selectedIndex: [{ type: Input }],\n    headerPosition: [{ type: Input }],\n    backgroundColor: [{ type: Input }],\n    selectedIndexChange: [{ type: Output }],\n    focusChange: [{ type: Output }],\n    animationDone: [{ type: Output }],\n    selectedTabChange: [{ type: Output }]\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * \\@docs-private\n */\nclass MatTabNavBase {\n    /**\n     * @param {?} _elementRef\n     */\n    constructor(_elementRef) {\n        this._elementRef = _elementRef;\n    }\n}\n/** @type {?} */\nconst _MatTabNavMixinBase = mixinDisableRipple(mixinColor(MatTabNavBase, 'primary'));\n/**\n * Navigation component matching the styles of the tab group header.\n * Provides anchored navigation with animated ink bar.\n */\nclass MatTabNav extends _MatTabNavMixinBase {\n    /**\n     * @param {?} elementRef\n     * @param {?} _dir\n     * @param {?} _ngZone\n     * @param {?} _changeDetectorRef\n     * @param {?} _viewportRuler\n     */\n    constructor(elementRef, _dir, _ngZone, _changeDetectorRef, _viewportRuler) {\n        super(elementRef);\n        this._dir = _dir;\n        this._ngZone = _ngZone;\n        this._changeDetectorRef = _changeDetectorRef;\n        this._viewportRuler = _viewportRuler;\n        /**\n         * Subject that emits when the component has been destroyed.\n         */\n        this._onDestroy = new Subject();\n    }\n    /**\n     * Background color of the tab nav.\n     * @return {?}\n     */\n    get backgroundColor() { return this._backgroundColor; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set backgroundColor(value) {\n        /** @type {?} */\n        const nativeElement = this._elementRef.nativeElement;\n        nativeElement.classList.remove(`mat-background-${this.backgroundColor}`);\n        if (value) {\n            nativeElement.classList.add(`mat-background-${value}`);\n        }\n        this._backgroundColor = value;\n    }\n    /**\n     * Notifies the component that the active link has been changed.\n     * \\@breaking-change 8.0.0 `element` parameter to be removed.\n     * @param {?} element\n     * @return {?}\n     */\n    updateActiveLink(element) {\n        // Note: keeping the `element` for backwards-compat, but isn't being used for anything.\n        // @breaking-change 8.0.0\n        this._activeLinkChanged = !!element;\n        this._changeDetectorRef.markForCheck();\n    }\n    /**\n     * @return {?}\n     */\n    ngAfterContentInit() {\n        this._ngZone.runOutsideAngular(() => {\n            /** @type {?} */\n            const dirChange = this._dir ? this._dir.change : of(null);\n            return merge(dirChange, this._viewportRuler.change(10))\n                .pipe(takeUntil(this._onDestroy))\n                .subscribe(() => this._alignInkBar());\n        });\n    }\n    /**\n     * Checks if the active link has been changed and, if so, will update the ink bar.\n     * @return {?}\n     */\n    ngAfterContentChecked() {\n        if (this._activeLinkChanged) {\n            /** @type {?} */\n            const activeTab = this._tabLinks.find(tab => tab.active);\n            this._activeLinkElement = activeTab ? activeTab._elementRef : null;\n            this._alignInkBar();\n            this._activeLinkChanged = false;\n        }\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this._onDestroy.next();\n        this._onDestroy.complete();\n    }\n    /**\n     * Aligns the ink bar to the active link.\n     * @return {?}\n     */\n    _alignInkBar() {\n        if (this._activeLinkElement) {\n            this._inkBar.show();\n            this._inkBar.alignToElement(this._activeLinkElement.nativeElement);\n        }\n        else {\n            this._inkBar.hide();\n        }\n    }\n}\nMatTabNav.decorators = [\n    { type: Component, args: [{selector: '[mat-tab-nav-bar]',\n                exportAs: 'matTabNavBar, matTabNav',\n                inputs: ['color', 'disableRipple'],\n                template: \"<div class=\\\"mat-tab-links\\\" (cdkObserveContent)=\\\"_alignInkBar()\\\"><ng-content></ng-content><mat-ink-bar></mat-ink-bar></div>\",\n                styles: [\".mat-tab-nav-bar{overflow:hidden;position:relative;flex-shrink:0}.mat-tab-links{position:relative;display:flex}.mat-tab-link{height:48px;padding:0 24px;cursor:pointer;box-sizing:border-box;opacity:.6;min-width:160px;text-align:center;display:inline-flex;justify-content:center;align-items:center;white-space:nowrap;vertical-align:top;text-decoration:none;position:relative;overflow:hidden;-webkit-tap-highlight-color:transparent}.mat-tab-link:focus{outline:0}.mat-tab-link:focus:not(.mat-tab-disabled){opacity:1}@media screen and (-ms-high-contrast:active){.mat-tab-link:focus{outline:dotted 2px}}.mat-tab-link.mat-tab-disabled{cursor:default}@media screen and (-ms-high-contrast:active){.mat-tab-link.mat-tab-disabled{opacity:.5}}.mat-tab-link .mat-tab-label-content{display:inline-flex;justify-content:center;align-items:center;white-space:nowrap}@media screen and (-ms-high-contrast:active){.mat-tab-link{opacity:1}}[mat-stretch-tabs] .mat-tab-link{flex-basis:0;flex-grow:1}.mat-tab-link.mat-tab-disabled{pointer-events:none}@media (max-width:599px){.mat-tab-link{min-width:72px}}.mat-ink-bar{position:absolute;bottom:0;height:2px;transition:.5s cubic-bezier(.35,0,.25,1)}.mat-tab-group-inverted-header .mat-ink-bar{bottom:auto;top:0}@media screen and (-ms-high-contrast:active){.mat-ink-bar{outline:solid 2px;height:0}}\"],\n                host: { 'class': 'mat-tab-nav-bar' },\n                encapsulation: ViewEncapsulation.None,\n                changeDetection: ChangeDetectionStrategy.OnPush,\n            },] },\n];\n/** @nocollapse */\nMatTabNav.ctorParameters = () => [\n    { type: ElementRef },\n    { type: Directionality, decorators: [{ type: Optional }] },\n    { type: NgZone },\n    { type: ChangeDetectorRef },\n    { type: ViewportRuler }\n];\nMatTabNav.propDecorators = {\n    _inkBar: [{ type: ViewChild, args: [MatInkBar,] }],\n    _tabLinks: [{ type: ContentChildren, args: [forwardRef(() => MatTabLink), { descendants: true },] }],\n    backgroundColor: [{ type: Input }]\n};\nclass MatTabLinkBase {\n}\n/** @type {?} */\nconst _MatTabLinkMixinBase = mixinTabIndex(mixinDisableRipple(mixinDisabled(MatTabLinkBase)));\n/**\n * Link inside of a `mat-tab-nav-bar`.\n */\nclass MatTabLink extends _MatTabLinkMixinBase {\n    /**\n     * @param {?} _tabNavBar\n     * @param {?} _elementRef\n     * @param {?} ngZone\n     * @param {?} platform\n     * @param {?} globalOptions\n     * @param {?} tabIndex\n     * @param {?=} _focusMonitor\n     */\n    constructor(_tabNavBar, _elementRef, ngZone, platform, globalOptions, tabIndex, _focusMonitor) {\n        super();\n        this._tabNavBar = _tabNavBar;\n        this._elementRef = _elementRef;\n        this._focusMonitor = _focusMonitor;\n        /**\n         * Whether the tab link is active or not.\n         */\n        this._isActive = false;\n        /**\n         * Whether the ripples are globally disabled through the RippleGlobalOptions\n         */\n        this._ripplesGloballyDisabled = false;\n        /**\n         * Ripple configuration for ripples that are launched on pointer down.\n         * \\@docs-private\n         */\n        this.rippleConfig = {};\n        this._tabLinkRipple = new RippleRenderer(this, ngZone, _elementRef, platform);\n        this._tabLinkRipple.setupTriggerEvents(_elementRef.nativeElement);\n        this.tabIndex = parseInt(tabIndex) || 0;\n        if (globalOptions) {\n            // TODO(paul): Do not copy each option manually. Allow dynamic global option changes: #9729\n            this._ripplesGloballyDisabled = !!globalOptions.disabled;\n            this.rippleConfig = {\n                terminateOnPointerUp: globalOptions.terminateOnPointerUp,\n                animation: globalOptions.animation,\n            };\n        }\n        if (_focusMonitor) {\n            _focusMonitor.monitor(_elementRef);\n        }\n    }\n    /**\n     * Whether the link is active.\n     * @return {?}\n     */\n    get active() { return this._isActive; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set active(value) {\n        if (value !== this._isActive) {\n            this._isActive = value;\n            this._tabNavBar.updateActiveLink(this._elementRef);\n        }\n    }\n    /**\n     * Whether ripples are disabled on interaction\n     * \\@docs-private\n     * @return {?}\n     */\n    get rippleDisabled() {\n        return this.disabled || this.disableRipple || this._tabNavBar.disableRipple ||\n            this._ripplesGloballyDisabled;\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this._tabLinkRipple._removeTriggerEvents();\n        if (this._focusMonitor) {\n            this._focusMonitor.stopMonitoring(this._elementRef);\n        }\n    }\n}\nMatTabLink.decorators = [\n    { type: Directive, args: [{\n                selector: '[mat-tab-link], [matTabLink]',\n                exportAs: 'matTabLink',\n                inputs: ['disabled', 'disableRipple', 'tabIndex'],\n                host: {\n                    'class': 'mat-tab-link',\n                    '[attr.aria-current]': 'active',\n                    '[attr.aria-disabled]': 'disabled.toString()',\n                    '[attr.tabIndex]': 'tabIndex',\n                    '[class.mat-tab-disabled]': 'disabled',\n                    '[class.mat-tab-label-active]': 'active',\n                }\n            },] },\n];\n/** @nocollapse */\nMatTabLink.ctorParameters = () => [\n    { type: MatTabNav },\n    { type: ElementRef },\n    { type: NgZone },\n    { type: Platform },\n    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [MAT_RIPPLE_GLOBAL_OPTIONS,] }] },\n    { type: String, decorators: [{ type: Attribute, args: ['tabindex',] }] },\n    { type: FocusMonitor }\n];\nMatTabLink.propDecorators = {\n    active: [{ type: Input }]\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\nclass MatTabsModule {\n}\nMatTabsModule.decorators = [\n    { type: NgModule, args: [{\n                imports: [\n                    CommonModule,\n                    MatCommonModule,\n                    PortalModule,\n                    MatRippleModule,\n                    ObserversModule,\n                    A11yModule,\n                ],\n                // Don't export all components because some are only to be used internally.\n                exports: [\n                    MatCommonModule,\n                    MatTabGroup,\n                    MatTabLabel,\n                    MatTab,\n                    MatTabNav,\n                    MatTabLink,\n                    MatTabContent,\n                ],\n                declarations: [\n                    MatTabGroup,\n                    MatTabLabel,\n                    MatTab,\n                    MatInkBar,\n                    MatTabLabelWrapper,\n                    MatTabNav,\n                    MatTabLink,\n                    MatTabBody,\n                    MatTabBodyPortal,\n                    MatTabHeader,\n                    MatTabContent,\n                ],\n            },] },\n];\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\nexport { MatInkBar, _MAT_INK_BAR_POSITIONER, MatTabBody, MatTabBodyPortal, MatTabHeader, MatTabLabelWrapper, MatTab, MatTabLabel, MatTabNav, MatTabLink, MatTabContent, MatTabsModule, MatTabChangeEvent, MatTabGroupBase, _MatTabGroupMixinBase, MatTabGroup, matTabsAnimations, _MAT_INK_BAR_POSITIONER_FACTORY as a23, MatTabBase as f23, _MatTabMixinBase as g23, MatTabHeaderBase as b23, _MatTabHeaderMixinBase as c23, MatTabLabelWrapperBase as d23, _MatTabLabelWrapperMixinBase as e23, MatTabLinkBase as j23, MatTabNavBase as h23, _MatTabLinkMixinBase as k23, _MatTabNavMixinBase as i23 };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}