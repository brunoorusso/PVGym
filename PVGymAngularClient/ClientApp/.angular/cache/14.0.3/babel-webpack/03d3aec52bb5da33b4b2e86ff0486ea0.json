{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/cdk/portal'), require('@angular/material/core'), require('rxjs'), require('@angular/animations'), require('@angular/cdk/bidi'), require('rxjs/operators'), require('@angular/cdk/coercion'), require('@angular/cdk/keycodes'), require('@angular/cdk/scrolling'), require('@angular/cdk/a11y'), require('@angular/cdk/platform'), require('@angular/cdk/observers'), require('@angular/common')) : typeof define === 'function' && define.amd ? define('@angular/material/tabs', ['exports', '@angular/core', '@angular/cdk/portal', '@angular/material/core', 'rxjs', '@angular/animations', '@angular/cdk/bidi', 'rxjs/operators', '@angular/cdk/coercion', '@angular/cdk/keycodes', '@angular/cdk/scrolling', '@angular/cdk/a11y', '@angular/cdk/platform', '@angular/cdk/observers', '@angular/common'], factory) : factory((global.ng = global.ng || {}, global.ng.material = global.ng.material || {}, global.ng.material.tabs = {}), global.ng.core, global.ng.cdk.portal, global.ng.material.core, global.rxjs, global.ng.animations, global.ng.cdk.bidi, global.rxjs.operators, global.ng.cdk.coercion, global.ng.cdk.keycodes, global.ng.cdk.scrolling, global.ng.cdk.a11y, global.ng.cdk.platform, global.ng.cdk.observers, global.ng.common);\n})(this, function (exports, core, portal, core$1, rxjs, animations, bidi, operators, coercion, keycodes, scrolling, a11y, platform, observers, common) {\n  'use strict';\n  /*! *****************************************************************************\r\n  Copyright (c) Microsoft Corporation. All rights reserved.\r\n  Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\n  this file except in compliance with the License. You may obtain a copy of the\r\n  License at http://www.apache.org/licenses/LICENSE-2.0\r\n  \r\n  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\n  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\n  MERCHANTABLITY OR NON-INFRINGEMENT.\r\n  \r\n  See the Apache Version 2.0 License for specific language governing permissions\r\n  and limitations under the License.\r\n  ***************************************************************************** */\n\n  /* global Reflect, Promise */\n\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  function __extends(d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  }\n  /**\n   * @fileoverview added by tsickle\n   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n   */\n\n  /**\n   * Injection token for the MatInkBar's Positioner.\n   * @type {?}\n   */\n\n\n  var _MAT_INK_BAR_POSITIONER = new core.InjectionToken('MatInkBarPositioner', {\n    providedIn: 'root',\n    factory: _MAT_INK_BAR_POSITIONER_FACTORY\n  });\n  /**\n   * The default positioner function for the MatInkBar.\n   * \\@docs-private\n   * @return {?}\n   */\n\n\n  function _MAT_INK_BAR_POSITIONER_FACTORY() {\n    /** @type {?} */\n    var method = function (element) {\n      return {\n        left: element ? (element.offsetLeft || 0) + 'px' : '0',\n        width: element ? (element.offsetWidth || 0) + 'px' : '0'\n      };\n    };\n\n    return method;\n  }\n  /**\n   * The ink-bar is used to display and animate the line underneath the current active tab label.\n   * \\@docs-private\n   */\n\n\n  var MatInkBar =\n  /** @class */\n  function () {\n    function MatInkBar(_elementRef, _ngZone, _inkBarPositioner) {\n      this._elementRef = _elementRef;\n      this._ngZone = _ngZone;\n      this._inkBarPositioner = _inkBarPositioner;\n    }\n    /**\n     * Calculates the styles from the provided element in order to align the ink-bar to that element.\n     * Shows the ink bar if previously set as hidden.\n     * @param element\n     */\n\n    /**\n     * Calculates the styles from the provided element in order to align the ink-bar to that element.\n     * Shows the ink bar if previously set as hidden.\n     * @param {?} element\n     * @return {?}\n     */\n\n\n    MatInkBar.prototype.alignToElement =\n    /**\n    * Calculates the styles from the provided element in order to align the ink-bar to that element.\n    * Shows the ink bar if previously set as hidden.\n    * @param {?} element\n    * @return {?}\n    */\n    function (element) {\n      var _this = this;\n\n      this.show();\n\n      if (typeof requestAnimationFrame !== 'undefined') {\n        this._ngZone.runOutsideAngular(function () {\n          requestAnimationFrame(function () {\n            return _this._setStyles(element);\n          });\n        });\n      } else {\n        this._setStyles(element);\n      }\n    };\n    /** Shows the ink bar. */\n\n    /**\n     * Shows the ink bar.\n     * @return {?}\n     */\n\n\n    MatInkBar.prototype.show =\n    /**\n    * Shows the ink bar.\n    * @return {?}\n    */\n    function () {\n      this._elementRef.nativeElement.style.visibility = 'visible';\n    };\n    /** Hides the ink bar. */\n\n    /**\n     * Hides the ink bar.\n     * @return {?}\n     */\n\n\n    MatInkBar.prototype.hide =\n    /**\n    * Hides the ink bar.\n    * @return {?}\n    */\n    function () {\n      this._elementRef.nativeElement.style.visibility = 'hidden';\n    };\n    /**\n     * Sets the proper styles to the ink bar element.\n     * @param element\n     */\n\n    /**\n     * Sets the proper styles to the ink bar element.\n     * @private\n     * @param {?} element\n     * @return {?}\n     */\n\n\n    MatInkBar.prototype._setStyles =\n    /**\n    * Sets the proper styles to the ink bar element.\n    * @private\n    * @param {?} element\n    * @return {?}\n    */\n    function (element) {\n      /** @type {?} */\n      var positions = this._inkBarPositioner(element);\n      /** @type {?} */\n\n\n      var inkBar = this._elementRef.nativeElement;\n      inkBar.style.left = positions.left;\n      inkBar.style.width = positions.width;\n    };\n\n    MatInkBar.decorators = [{\n      type: core.Directive,\n      args: [{\n        selector: 'mat-ink-bar',\n        host: {\n          'class': 'mat-ink-bar'\n        }\n      }]\n    }];\n    /** @nocollapse */\n\n    MatInkBar.ctorParameters = function () {\n      return [{\n        type: core.ElementRef\n      }, {\n        type: core.NgZone\n      }, {\n        type: undefined,\n        decorators: [{\n          type: core.Inject,\n          args: [_MAT_INK_BAR_POSITIONER]\n        }]\n      }];\n    };\n\n    return MatInkBar;\n  }();\n  /**\n   * @fileoverview added by tsickle\n   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n   */\n\n  /**\n   * Decorates the `ng-template` tags and reads out the template from it.\n   */\n\n\n  var MatTabContent =\n  /** @class */\n  function () {\n    function MatTabContent(template) {\n      this.template = template;\n    }\n\n    MatTabContent.decorators = [{\n      type: core.Directive,\n      args: [{\n        selector: '[matTabContent]'\n      }]\n    }];\n    /** @nocollapse */\n\n    MatTabContent.ctorParameters = function () {\n      return [{\n        type: core.TemplateRef\n      }];\n    };\n\n    return MatTabContent;\n  }();\n  /**\n   * @fileoverview added by tsickle\n   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n   */\n\n  /**\n   * Used to flag tab labels for use with the portal directive\n   */\n\n\n  var MatTabLabel =\n  /** @class */\n  function (_super) {\n    __extends(MatTabLabel, _super);\n\n    function MatTabLabel() {\n      return _super !== null && _super.apply(this, arguments) || this;\n    }\n\n    MatTabLabel.decorators = [{\n      type: core.Directive,\n      args: [{\n        selector: '[mat-tab-label], [matTabLabel]'\n      }]\n    }];\n    return MatTabLabel;\n  }(portal.CdkPortal);\n  /**\n   * @fileoverview added by tsickle\n   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n   */\n  // Boilerplate for applying mixins to MatTab.\n\n  /**\n   * \\@docs-private\n   */\n\n\n  var // Boilerplate for applying mixins to MatTab.\n\n  /**\n   * \\@docs-private\n   */\n  MatTabBase =\n  /** @class */\n  function () {\n    function MatTabBase() {}\n\n    return MatTabBase;\n  }();\n  /** @type {?} */\n\n\n  var _MatTabMixinBase = core$1.mixinDisabled(MatTabBase);\n\n  var MatTab =\n  /** @class */\n  function (_super) {\n    __extends(MatTab, _super);\n\n    function MatTab(_viewContainerRef) {\n      var _this = _super.call(this) || this;\n\n      _this._viewContainerRef = _viewContainerRef;\n      /**\n       * Plain text label for the tab, used when there is no template label.\n       */\n\n      _this.textLabel = '';\n      /**\n       * Portal that will be the hosted content of the tab\n       */\n\n      _this._contentPortal = null;\n      /**\n       * Emits whenever the internal state of the tab changes.\n       */\n\n      _this._stateChanges = new rxjs.Subject();\n      /**\n       * The relatively indexed position where 0 represents the center, negative is left, and positive\n       * represents the right.\n       */\n\n      _this.position = null;\n      /**\n       * The initial relatively index origin of the tab if it was created and selected after there\n       * was already a selected tab. Provides context of what position the tab should originate from.\n       */\n\n      _this.origin = null;\n      /**\n       * Whether the tab is currently active.\n       */\n\n      _this.isActive = false;\n      return _this;\n    }\n\n    Object.defineProperty(MatTab.prototype, \"content\", {\n      /** @docs-private */\n      get:\n      /**\n      * \\@docs-private\n      * @return {?}\n      */\n      function () {\n        return this._contentPortal;\n      },\n      enumerable: true,\n      configurable: true\n    });\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n\n    MatTab.prototype.ngOnChanges =\n    /**\n    * @param {?} changes\n    * @return {?}\n    */\n    function (changes) {\n      if (changes.hasOwnProperty('textLabel') || changes.hasOwnProperty('disabled')) {\n        this._stateChanges.next();\n      }\n    };\n    /**\n     * @return {?}\n     */\n\n\n    MatTab.prototype.ngOnDestroy =\n    /**\n    * @return {?}\n    */\n    function () {\n      this._stateChanges.complete();\n    };\n    /**\n     * @return {?}\n     */\n\n\n    MatTab.prototype.ngOnInit =\n    /**\n    * @return {?}\n    */\n    function () {\n      this._contentPortal = new portal.TemplatePortal(this._explicitContent || this._implicitContent, this._viewContainerRef);\n    };\n\n    MatTab.decorators = [{\n      type: core.Component,\n      args: [{\n        selector: 'mat-tab',\n        template: \"<ng-template><ng-content></ng-content></ng-template>\",\n        inputs: ['disabled'],\n        changeDetection: core.ChangeDetectionStrategy.OnPush,\n        encapsulation: core.ViewEncapsulation.None,\n        exportAs: 'matTab'\n      }]\n    }];\n    /** @nocollapse */\n\n    MatTab.ctorParameters = function () {\n      return [{\n        type: core.ViewContainerRef\n      }];\n    };\n\n    MatTab.propDecorators = {\n      templateLabel: [{\n        type: core.ContentChild,\n        args: [MatTabLabel]\n      }],\n      _explicitContent: [{\n        type: core.ContentChild,\n        args: [MatTabContent, {\n          read: core.TemplateRef\n        }]\n      }],\n      _implicitContent: [{\n        type: core.ViewChild,\n        args: [core.TemplateRef]\n      }],\n      textLabel: [{\n        type: core.Input,\n        args: ['label']\n      }],\n      ariaLabel: [{\n        type: core.Input,\n        args: ['aria-label']\n      }],\n      ariaLabelledby: [{\n        type: core.Input,\n        args: ['aria-labelledby']\n      }]\n    };\n    return MatTab;\n  }(_MatTabMixinBase);\n  /**\n   * @fileoverview added by tsickle\n   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n   */\n\n  /**\n   * Animations used by the Material tabs.\n   * \\@docs-private\n   * @type {?}\n   */\n\n\n  var matTabsAnimations = {\n    /**\n     * Animation translates a tab along the X axis.\n     */\n    translateTab: animations.trigger('translateTab', [// Note: transitions to `none` instead of 0, because some browsers might blur the content.\n    animations.state('center, void, left-origin-center, right-origin-center', animations.style({\n      transform: 'none'\n    })), // If the tab is either on the left or right, we additionally add a `min-height` of 1px\n    // in order to ensure that the element has a height before its state changes. This is\n    // necessary because Chrome does seem to skip the transition in RTL mode if the element does\n    // not have a static height and is not rendered. See related issue: #9465\n    animations.state('left', animations.style({\n      transform: 'translate3d(-100%, 0, 0)',\n      minHeight: '1px'\n    })), animations.state('right', animations.style({\n      transform: 'translate3d(100%, 0, 0)',\n      minHeight: '1px'\n    })), animations.transition('* => left, * => right, left => center, right => center', animations.animate('{{animationDuration}} cubic-bezier(0.35, 0, 0.25, 1)')), animations.transition('void => left-origin-center', [animations.style({\n      transform: 'translate3d(-100%, 0, 0)'\n    }), animations.animate('{{animationDuration}} cubic-bezier(0.35, 0, 0.25, 1)')]), animations.transition('void => right-origin-center', [animations.style({\n      transform: 'translate3d(100%, 0, 0)'\n    }), animations.animate('{{animationDuration}} cubic-bezier(0.35, 0, 0.25, 1)')])])\n  };\n  /**\n   * @fileoverview added by tsickle\n   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n   */\n\n  /**\n   * The portal host directive for the contents of the tab.\n   * \\@docs-private\n   */\n\n  var MatTabBodyPortal =\n  /** @class */\n  function (_super) {\n    __extends(MatTabBodyPortal, _super);\n\n    function MatTabBodyPortal(componentFactoryResolver, viewContainerRef, _host) {\n      var _this = _super.call(this, componentFactoryResolver, viewContainerRef) || this;\n\n      _this._host = _host;\n      /**\n       * Subscription to events for when the tab body begins centering.\n       */\n\n      _this._centeringSub = rxjs.Subscription.EMPTY;\n      /**\n       * Subscription to events for when the tab body finishes leaving from center position.\n       */\n\n      _this._leavingSub = rxjs.Subscription.EMPTY;\n      return _this;\n    }\n    /** Set initial visibility or set up subscription for changing visibility. */\n\n    /**\n     * Set initial visibility or set up subscription for changing visibility.\n     * @return {?}\n     */\n\n\n    MatTabBodyPortal.prototype.ngOnInit =\n    /**\n    * Set initial visibility or set up subscription for changing visibility.\n    * @return {?}\n    */\n    function () {\n      var _this = this;\n\n      _super.prototype.ngOnInit.call(this);\n\n      this._centeringSub = this._host._beforeCentering.pipe(operators.startWith(this._host._isCenterPosition(this._host._position))).subscribe(function (isCentering) {\n        if (isCentering && !_this.hasAttached()) {\n          _this.attach(_this._host._content);\n        }\n      });\n      this._leavingSub = this._host._afterLeavingCenter.subscribe(function () {\n        _this.detach();\n      });\n    };\n    /** Clean up centering subscription. */\n\n    /**\n     * Clean up centering subscription.\n     * @return {?}\n     */\n\n\n    MatTabBodyPortal.prototype.ngOnDestroy =\n    /**\n    * Clean up centering subscription.\n    * @return {?}\n    */\n    function () {\n      _super.prototype.ngOnDestroy.call(this);\n\n      this._centeringSub.unsubscribe();\n\n      this._leavingSub.unsubscribe();\n    };\n\n    MatTabBodyPortal.decorators = [{\n      type: core.Directive,\n      args: [{\n        selector: '[matTabBodyHost]'\n      }]\n    }];\n    /** @nocollapse */\n\n    MatTabBodyPortal.ctorParameters = function () {\n      return [{\n        type: core.ComponentFactoryResolver\n      }, {\n        type: core.ViewContainerRef\n      }, {\n        type: MatTabBody,\n        decorators: [{\n          type: core.Inject,\n          args: [core.forwardRef(function () {\n            return MatTabBody;\n          })]\n        }]\n      }];\n    };\n\n    return MatTabBodyPortal;\n  }(portal.CdkPortalOutlet);\n  /**\n   * Wrapper for the contents of a tab.\n   * \\@docs-private\n   */\n\n\n  var MatTabBody =\n  /** @class */\n  function () {\n    function MatTabBody(_elementRef, _dir,\n    /**\n     * @breaking-change 8.0.0 changeDetectorRef to be made required.\n     */\n    changeDetectorRef) {\n      var _this = this;\n\n      this._elementRef = _elementRef;\n      this._dir = _dir;\n      /**\n       * Subscription to the directionality change observable.\n       */\n\n      this._dirChangeSubscription = rxjs.Subscription.EMPTY;\n      /**\n       * Emits when an animation on the tab is complete.\n       */\n\n      this._translateTabComplete = new rxjs.Subject();\n      /**\n       * Event emitted when the tab begins to animate towards the center as the active tab.\n       */\n\n      this._onCentering = new core.EventEmitter();\n      /**\n       * Event emitted before the centering of the tab begins.\n       */\n\n      this._beforeCentering = new core.EventEmitter();\n      /**\n       * Event emitted before the centering of the tab begins.\n       */\n\n      this._afterLeavingCenter = new core.EventEmitter();\n      /**\n       * Event emitted when the tab completes its animation towards the center.\n       */\n\n      this._onCentered = new core.EventEmitter(true); // Note that the default value will always be overwritten by `MatTabBody`, but we need one\n      // anyway to prevent the animations module from throwing an error if the body is used on its own.\n\n      /**\n       * Duration for the tab's animation.\n       */\n\n      this.animationDuration = '500ms';\n\n      if (this._dir && changeDetectorRef) {\n        this._dirChangeSubscription = this._dir.change.subscribe(function (dir) {\n          _this._computePositionAnimationState(dir);\n\n          changeDetectorRef.markForCheck();\n        });\n      } // Ensure that we get unique animation events, because the `.done` callback can get\n      // invoked twice in some browsers. See https://github.com/angular/angular/issues/24084.\n\n\n      this._translateTabComplete.pipe(operators.distinctUntilChanged(function (x, y) {\n        return x.fromState === y.fromState && x.toState === y.toState;\n      })).subscribe(function (event) {\n        // If the transition to the center is complete, emit an event.\n        if (_this._isCenterPosition(event.toState) && _this._isCenterPosition(_this._position)) {\n          _this._onCentered.emit();\n        }\n\n        if (_this._isCenterPosition(event.fromState) && !_this._isCenterPosition(_this._position)) {\n          _this._afterLeavingCenter.emit();\n        }\n      });\n    }\n\n    Object.defineProperty(MatTabBody.prototype, \"position\", {\n      /** The shifted index position of the tab body, where zero represents the active center tab. */\n      set:\n      /**\n      * The shifted index position of the tab body, where zero represents the active center tab.\n      * @param {?} position\n      * @return {?}\n      */\n      function (position) {\n        this._positionIndex = position;\n\n        this._computePositionAnimationState();\n      },\n      enumerable: true,\n      configurable: true\n    });\n    /**\n     * After initialized, check if the content is centered and has an origin. If so, set the\n     * special position states that transition the tab from the left or right before centering.\n     */\n\n    /**\n     * After initialized, check if the content is centered and has an origin. If so, set the\n     * special position states that transition the tab from the left or right before centering.\n     * @return {?}\n     */\n\n    MatTabBody.prototype.ngOnInit =\n    /**\n    * After initialized, check if the content is centered and has an origin. If so, set the\n    * special position states that transition the tab from the left or right before centering.\n    * @return {?}\n    */\n    function () {\n      if (this._position == 'center' && this.origin != null) {\n        this._position = this._computePositionFromOrigin();\n      }\n    };\n    /**\n     * @return {?}\n     */\n\n\n    MatTabBody.prototype.ngOnDestroy =\n    /**\n    * @return {?}\n    */\n    function () {\n      this._dirChangeSubscription.unsubscribe();\n\n      this._translateTabComplete.complete();\n    };\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n\n\n    MatTabBody.prototype._onTranslateTabStarted =\n    /**\n    * @param {?} event\n    * @return {?}\n    */\n    function (event) {\n      /** @type {?} */\n      var isCentering = this._isCenterPosition(event.toState);\n\n      this._beforeCentering.emit(isCentering);\n\n      if (isCentering) {\n        this._onCentering.emit(this._elementRef.nativeElement.clientHeight);\n      }\n    };\n    /** The text direction of the containing app. */\n\n    /**\n     * The text direction of the containing app.\n     * @return {?}\n     */\n\n\n    MatTabBody.prototype._getLayoutDirection =\n    /**\n    * The text direction of the containing app.\n    * @return {?}\n    */\n    function () {\n      return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';\n    };\n    /** Whether the provided position state is considered center, regardless of origin. */\n\n    /**\n     * Whether the provided position state is considered center, regardless of origin.\n     * @param {?} position\n     * @return {?}\n     */\n\n\n    MatTabBody.prototype._isCenterPosition =\n    /**\n    * Whether the provided position state is considered center, regardless of origin.\n    * @param {?} position\n    * @return {?}\n    */\n    function (position) {\n      return position == 'center' || position == 'left-origin-center' || position == 'right-origin-center';\n    };\n    /** Computes the position state that will be used for the tab-body animation trigger. */\n\n    /**\n     * Computes the position state that will be used for the tab-body animation trigger.\n     * @private\n     * @param {?=} dir\n     * @return {?}\n     */\n\n\n    MatTabBody.prototype._computePositionAnimationState =\n    /**\n    * Computes the position state that will be used for the tab-body animation trigger.\n    * @private\n    * @param {?=} dir\n    * @return {?}\n    */\n    function (dir) {\n      if (dir === void 0) {\n        dir = this._getLayoutDirection();\n      }\n\n      if (this._positionIndex < 0) {\n        this._position = dir == 'ltr' ? 'left' : 'right';\n      } else if (this._positionIndex > 0) {\n        this._position = dir == 'ltr' ? 'right' : 'left';\n      } else {\n        this._position = 'center';\n      }\n    };\n    /**\n     * Computes the position state based on the specified origin position. This is used if the\n     * tab is becoming visible immediately after creation.\n     */\n\n    /**\n     * Computes the position state based on the specified origin position. This is used if the\n     * tab is becoming visible immediately after creation.\n     * @private\n     * @return {?}\n     */\n\n\n    MatTabBody.prototype._computePositionFromOrigin =\n    /**\n    * Computes the position state based on the specified origin position. This is used if the\n    * tab is becoming visible immediately after creation.\n    * @private\n    * @return {?}\n    */\n    function () {\n      /** @type {?} */\n      var dir = this._getLayoutDirection();\n\n      if (dir == 'ltr' && this.origin <= 0 || dir == 'rtl' && this.origin > 0) {\n        return 'left-origin-center';\n      }\n\n      return 'right-origin-center';\n    };\n\n    MatTabBody.decorators = [{\n      type: core.Component,\n      args: [{\n        selector: 'mat-tab-body',\n        template: \"<div class=\\\"mat-tab-body-content\\\" #content [@translateTab]=\\\"{ value: _position, params: {animationDuration: animationDuration} }\\\" (@translateTab.start)=\\\"_onTranslateTabStarted($event)\\\" (@translateTab.done)=\\\"_translateTabComplete.next($event)\\\"><ng-template matTabBodyHost></ng-template></div>\",\n        styles: [\".mat-tab-body-content{height:100%;overflow:auto}.mat-tab-group-dynamic-height .mat-tab-body-content{overflow:hidden}\"],\n        encapsulation: core.ViewEncapsulation.None,\n        changeDetection: core.ChangeDetectionStrategy.OnPush,\n        animations: [matTabsAnimations.translateTab],\n        host: {\n          'class': 'mat-tab-body'\n        }\n      }]\n    }];\n    /** @nocollapse */\n\n    MatTabBody.ctorParameters = function () {\n      return [{\n        type: core.ElementRef\n      }, {\n        type: bidi.Directionality,\n        decorators: [{\n          type: core.Optional\n        }]\n      }, {\n        type: core.ChangeDetectorRef\n      }];\n    };\n\n    MatTabBody.propDecorators = {\n      _onCentering: [{\n        type: core.Output\n      }],\n      _beforeCentering: [{\n        type: core.Output\n      }],\n      _afterLeavingCenter: [{\n        type: core.Output\n      }],\n      _onCentered: [{\n        type: core.Output\n      }],\n      _portalHost: [{\n        type: core.ViewChild,\n        args: [portal.PortalHostDirective]\n      }],\n      _content: [{\n        type: core.Input,\n        args: ['content']\n      }],\n      origin: [{\n        type: core.Input\n      }],\n      animationDuration: [{\n        type: core.Input\n      }],\n      position: [{\n        type: core.Input\n      }]\n    };\n    return MatTabBody;\n  }();\n  /**\n   * @fileoverview added by tsickle\n   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n   */\n  // Boilerplate for applying mixins to MatTabLabelWrapper.\n\n  /**\n   * \\@docs-private\n   */\n\n\n  var // Boilerplate for applying mixins to MatTabLabelWrapper.\n\n  /**\n   * \\@docs-private\n   */\n  MatTabLabelWrapperBase =\n  /** @class */\n  function () {\n    function MatTabLabelWrapperBase() {}\n\n    return MatTabLabelWrapperBase;\n  }();\n  /** @type {?} */\n\n\n  var _MatTabLabelWrapperMixinBase = core$1.mixinDisabled(MatTabLabelWrapperBase);\n  /**\n   * Used in the `mat-tab-group` view to display tab labels.\n   * \\@docs-private\n   */\n\n\n  var MatTabLabelWrapper =\n  /** @class */\n  function (_super) {\n    __extends(MatTabLabelWrapper, _super);\n\n    function MatTabLabelWrapper(elementRef) {\n      var _this = _super.call(this) || this;\n\n      _this.elementRef = elementRef;\n      return _this;\n    }\n    /** Sets focus on the wrapper element */\n\n    /**\n     * Sets focus on the wrapper element\n     * @return {?}\n     */\n\n\n    MatTabLabelWrapper.prototype.focus =\n    /**\n    * Sets focus on the wrapper element\n    * @return {?}\n    */\n    function () {\n      this.elementRef.nativeElement.focus();\n    };\n    /**\n     * @return {?}\n     */\n\n\n    MatTabLabelWrapper.prototype.getOffsetLeft =\n    /**\n    * @return {?}\n    */\n    function () {\n      return this.elementRef.nativeElement.offsetLeft;\n    };\n    /**\n     * @return {?}\n     */\n\n\n    MatTabLabelWrapper.prototype.getOffsetWidth =\n    /**\n    * @return {?}\n    */\n    function () {\n      return this.elementRef.nativeElement.offsetWidth;\n    };\n\n    MatTabLabelWrapper.decorators = [{\n      type: core.Directive,\n      args: [{\n        selector: '[matTabLabelWrapper]',\n        inputs: ['disabled'],\n        host: {\n          '[class.mat-tab-disabled]': 'disabled',\n          '[attr.aria-disabled]': '!!disabled'\n        }\n      }]\n    }];\n    /** @nocollapse */\n\n    MatTabLabelWrapper.ctorParameters = function () {\n      return [{\n        type: core.ElementRef\n      }];\n    };\n\n    return MatTabLabelWrapper;\n  }(_MatTabLabelWrapperMixinBase);\n  /**\n   * @fileoverview added by tsickle\n   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n   */\n\n  /**\n   * Config used to bind passive event listeners\n   * @type {?}\n   */\n\n\n  var passiveEventListenerOptions =\n  /** @type {?} */\n  platform.normalizePassiveListenerOptions({\n    passive: true\n  });\n  /**\n   * The distance in pixels that will be overshot when scrolling a tab label into view. This helps\n   * provide a small affordance to the label next to it.\n   * @type {?}\n   */\n\n  var EXAGGERATED_OVERSCROLL = 60;\n  /**\n   * Amount of milliseconds to wait before starting to scroll the header automatically.\n   * Set a little conservatively in order to handle fake events dispatched on touch devices.\n   * @type {?}\n   */\n\n  var HEADER_SCROLL_DELAY = 650;\n  /**\n   * Interval in milliseconds at which to scroll the header\n   * while the user is holding their pointer.\n   * @type {?}\n   */\n\n  var HEADER_SCROLL_INTERVAL = 100; // Boilerplate for applying mixins to MatTabHeader.\n\n  /**\n   * \\@docs-private\n   */\n\n  var // Boilerplate for applying mixins to MatTabHeader.\n\n  /**\n   * \\@docs-private\n   */\n  MatTabHeaderBase =\n  /** @class */\n  function () {\n    function MatTabHeaderBase() {}\n\n    return MatTabHeaderBase;\n  }();\n  /** @type {?} */\n\n\n  var _MatTabHeaderMixinBase = core$1.mixinDisableRipple(MatTabHeaderBase);\n  /**\n   * The header of the tab group which displays a list of all the tabs in the tab group. Includes\n   * an ink bar that follows the currently selected tab. When the tabs list's width exceeds the\n   * width of the header container, then arrows will be displayed to allow the user to scroll\n   * left and right across the header.\n   * \\@docs-private\n   */\n\n\n  var MatTabHeader =\n  /** @class */\n  function (_super) {\n    __extends(MatTabHeader, _super);\n\n    function MatTabHeader(_elementRef, _changeDetectorRef, _viewportRuler, _dir, _ngZone, _platform) {\n      var _this = _super.call(this) || this;\n\n      _this._elementRef = _elementRef;\n      _this._changeDetectorRef = _changeDetectorRef;\n      _this._viewportRuler = _viewportRuler;\n      _this._dir = _dir;\n      _this._ngZone = _ngZone;\n      _this._platform = _platform;\n      /**\n       * The distance in pixels that the tab labels should be translated to the left.\n       */\n\n      _this._scrollDistance = 0;\n      /**\n       * Whether the header should scroll to the selected index after the view has been checked.\n       */\n\n      _this._selectedIndexChanged = false;\n      /**\n       * Emits when the component is destroyed.\n       */\n\n      _this._destroyed = new rxjs.Subject();\n      /**\n       * Whether the controls for pagination should be displayed\n       */\n\n      _this._showPaginationControls = false;\n      /**\n       * Whether the tab list can be scrolled more towards the end of the tab label list.\n       */\n\n      _this._disableScrollAfter = true;\n      /**\n       * Whether the tab list can be scrolled more towards the beginning of the tab label list.\n       */\n\n      _this._disableScrollBefore = true;\n      /**\n       * Stream that will stop the automated scrolling.\n       */\n\n      _this._stopScrolling = new rxjs.Subject();\n      _this._selectedIndex = 0;\n      /**\n       * Event emitted when the option is selected.\n       */\n\n      _this.selectFocusedIndex = new core.EventEmitter();\n      /**\n       * Event emitted when a label is focused.\n       */\n\n      _this.indexFocused = new core.EventEmitter();\n      /** @type {?} */\n\n      var element = _elementRef.nativeElement;\n      /** @type {?} */\n\n      var bindEvent = function () {\n        rxjs.fromEvent(element, 'mouseleave').pipe(operators.takeUntil(_this._destroyed)).subscribe(function () {\n          _this._stopInterval();\n        });\n      }; // @breaking-change 8.0.0 remove null check once _ngZone is made into a required parameter.\n\n\n      if (_ngZone) {\n        // Bind the `mouseleave` event on the outside since it doesn't change anything in the view.\n        _ngZone.runOutsideAngular(bindEvent);\n      } else {\n        bindEvent();\n      }\n\n      return _this;\n    }\n\n    Object.defineProperty(MatTabHeader.prototype, \"selectedIndex\", {\n      /** The index of the active tab. */\n      get:\n      /**\n      * The index of the active tab.\n      * @return {?}\n      */\n      function () {\n        return this._selectedIndex;\n      },\n      set:\n      /**\n      * @param {?} value\n      * @return {?}\n      */\n      function (value) {\n        value = coercion.coerceNumberProperty(value);\n        this._selectedIndexChanged = this._selectedIndex != value;\n        this._selectedIndex = value;\n\n        if (this._keyManager) {\n          this._keyManager.updateActiveItemIndex(value);\n        }\n      },\n      enumerable: true,\n      configurable: true\n    });\n    /**\n     * @return {?}\n     */\n\n    MatTabHeader.prototype.ngAfterContentChecked =\n    /**\n    * @return {?}\n    */\n    function () {\n      // If the number of tab labels have changed, check if scrolling should be enabled\n      if (this._tabLabelCount != this._labelWrappers.length) {\n        this.updatePagination();\n        this._tabLabelCount = this._labelWrappers.length;\n\n        this._changeDetectorRef.markForCheck();\n      } // If the selected index has changed, scroll to the label and check if the scrolling controls\n      // should be disabled.\n\n\n      if (this._selectedIndexChanged) {\n        this._scrollToLabel(this._selectedIndex);\n\n        this._checkScrollingControls();\n\n        this._alignInkBarToSelectedTab();\n\n        this._selectedIndexChanged = false;\n\n        this._changeDetectorRef.markForCheck();\n      } // If the scroll distance has been changed (tab selected, focused, scroll controls activated),\n      // then translate the header to reflect this.\n\n\n      if (this._scrollDistanceChanged) {\n        this._updateTabScrollPosition();\n\n        this._scrollDistanceChanged = false;\n\n        this._changeDetectorRef.markForCheck();\n      }\n    };\n    /** Handles keyboard events on the header. */\n\n    /**\n     * Handles keyboard events on the header.\n     * @param {?} event\n     * @return {?}\n     */\n\n\n    MatTabHeader.prototype._handleKeydown =\n    /**\n    * Handles keyboard events on the header.\n    * @param {?} event\n    * @return {?}\n    */\n    function (event) {\n      // We don't handle any key bindings with a modifier key.\n      if (keycodes.hasModifierKey(event)) {\n        return;\n      }\n\n      switch (event.keyCode) {\n        case keycodes.HOME:\n          this._keyManager.setFirstItemActive();\n\n          event.preventDefault();\n          break;\n\n        case keycodes.END:\n          this._keyManager.setLastItemActive();\n\n          event.preventDefault();\n          break;\n\n        case keycodes.ENTER:\n        case keycodes.SPACE:\n          this.selectFocusedIndex.emit(this.focusIndex);\n          event.preventDefault();\n          break;\n\n        default:\n          this._keyManager.onKeydown(event);\n\n      }\n    };\n    /**\n     * Aligns the ink bar to the selected tab on load.\n     */\n\n    /**\n     * Aligns the ink bar to the selected tab on load.\n     * @return {?}\n     */\n\n\n    MatTabHeader.prototype.ngAfterContentInit =\n    /**\n    * Aligns the ink bar to the selected tab on load.\n    * @return {?}\n    */\n    function () {\n      var _this = this;\n      /** @type {?} */\n\n\n      var dirChange = this._dir ? this._dir.change : rxjs.of(null);\n      /** @type {?} */\n\n      var resize = this._viewportRuler.change(150);\n      /** @type {?} */\n\n\n      var realign = function () {\n        _this.updatePagination();\n\n        _this._alignInkBarToSelectedTab();\n      };\n\n      this._keyManager = new a11y.FocusKeyManager(this._labelWrappers).withHorizontalOrientation(this._getLayoutDirection()).withWrap();\n\n      this._keyManager.updateActiveItem(0); // Defer the first call in order to allow for slower browsers to lay out the elements.\n      // This helps in cases where the user lands directly on a page with paginated tabs.\n\n\n      typeof requestAnimationFrame !== 'undefined' ? requestAnimationFrame(realign) : realign(); // On dir change or window resize, realign the ink bar and update the orientation of\n      // the key manager if the direction has changed.\n\n      rxjs.merge(dirChange, resize).pipe(operators.takeUntil(this._destroyed)).subscribe(function () {\n        realign();\n\n        _this._keyManager.withHorizontalOrientation(_this._getLayoutDirection());\n      }); // If there is a change in the focus key manager we need to emit the `indexFocused`\n      // event in order to provide a public event that notifies about focus changes. Also we realign\n      // the tabs container by scrolling the new focused tab into the visible section.\n\n      this._keyManager.change.pipe(operators.takeUntil(this._destroyed)).subscribe(function (newFocusIndex) {\n        _this.indexFocused.emit(newFocusIndex);\n\n        _this._setTabFocus(newFocusIndex);\n      });\n    };\n    /**\n     * @return {?}\n     */\n\n\n    MatTabHeader.prototype.ngAfterViewInit =\n    /**\n    * @return {?}\n    */\n    function () {\n      var _this = this; // We need to handle these events manually, because we want to bind passive event listeners.\n\n\n      rxjs.fromEvent(this._previousPaginator.nativeElement, 'touchstart', passiveEventListenerOptions).pipe(operators.takeUntil(this._destroyed)).subscribe(function () {\n        _this._handlePaginatorPress('before');\n      });\n      rxjs.fromEvent(this._nextPaginator.nativeElement, 'touchstart', passiveEventListenerOptions).pipe(operators.takeUntil(this._destroyed)).subscribe(function () {\n        _this._handlePaginatorPress('after');\n      });\n    };\n    /**\n     * @return {?}\n     */\n\n\n    MatTabHeader.prototype.ngOnDestroy =\n    /**\n    * @return {?}\n    */\n    function () {\n      this._destroyed.next();\n\n      this._destroyed.complete();\n\n      this._stopScrolling.complete();\n    };\n    /**\n     * Callback for when the MutationObserver detects that the content has changed.\n     */\n\n    /**\n     * Callback for when the MutationObserver detects that the content has changed.\n     * @return {?}\n     */\n\n\n    MatTabHeader.prototype._onContentChanges =\n    /**\n    * Callback for when the MutationObserver detects that the content has changed.\n    * @return {?}\n    */\n    function () {\n      var _this = this;\n      /** @type {?} */\n\n\n      var textContent = this._elementRef.nativeElement.textContent; // We need to diff the text content of the header, because the MutationObserver callback\n      // will fire even if the text content didn't change which is inefficient and is prone\n      // to infinite loops if a poorly constructed expression is passed in (see #14249).\n\n      if (textContent !== this._currentTextContent) {\n        this._currentTextContent = textContent;\n        /** @type {?} */\n\n        var zoneCallback = function () {\n          _this.updatePagination();\n\n          _this._alignInkBarToSelectedTab();\n\n          _this._changeDetectorRef.markForCheck();\n        }; // The content observer runs outside the `NgZone` by default, which\n        // means that we need to bring the callback back in ourselves.\n        // @breaking-change 8.0.0 Remove null check for `_ngZone` once it's a required parameter.\n\n\n        this._ngZone ? this._ngZone.run(zoneCallback) : zoneCallback();\n      }\n    };\n    /**\n     * Updates the view whether pagination should be enabled or not.\n     *\n     * WARNING: Calling this method can be very costly in terms of performance.  It should be called\n     * as infrequently as possible from outside of the Tabs component as it causes a reflow of the\n     * page.\n     */\n\n    /**\n     * Updates the view whether pagination should be enabled or not.\n     *\n     * WARNING: Calling this method can be very costly in terms of performance.  It should be called\n     * as infrequently as possible from outside of the Tabs component as it causes a reflow of the\n     * page.\n     * @return {?}\n     */\n\n\n    MatTabHeader.prototype.updatePagination =\n    /**\n    * Updates the view whether pagination should be enabled or not.\n    *\n    * WARNING: Calling this method can be very costly in terms of performance.  It should be called\n    * as infrequently as possible from outside of the Tabs component as it causes a reflow of the\n    * page.\n    * @return {?}\n    */\n    function () {\n      this._checkPaginationEnabled();\n\n      this._checkScrollingControls();\n\n      this._updateTabScrollPosition();\n    };\n\n    Object.defineProperty(MatTabHeader.prototype, \"focusIndex\", {\n      /** Tracks which element has focus; used for keyboard navigation */\n      get:\n      /**\n      * Tracks which element has focus; used for keyboard navigation\n      * @return {?}\n      */\n      function () {\n        return this._keyManager ?\n        /** @type {?} */\n        this._keyManager.activeItemIndex : 0;\n      },\n\n      /** When the focus index is set, we must manually send focus to the correct label */\n      set:\n      /**\n      * When the focus index is set, we must manually send focus to the correct label\n      * @param {?} value\n      * @return {?}\n      */\n      function (value) {\n        if (!this._isValidIndex(value) || this.focusIndex === value || !this._keyManager) {\n          return;\n        }\n\n        this._keyManager.setActiveItem(value);\n      },\n      enumerable: true,\n      configurable: true\n    });\n    /**\n     * Determines if an index is valid.  If the tabs are not ready yet, we assume that the user is\n     * providing a valid index and return true.\n     */\n\n    /**\n     * Determines if an index is valid.  If the tabs are not ready yet, we assume that the user is\n     * providing a valid index and return true.\n     * @param {?} index\n     * @return {?}\n     */\n\n    MatTabHeader.prototype._isValidIndex =\n    /**\n    * Determines if an index is valid.  If the tabs are not ready yet, we assume that the user is\n    * providing a valid index and return true.\n    * @param {?} index\n    * @return {?}\n    */\n    function (index) {\n      if (!this._labelWrappers) {\n        return true;\n      }\n      /** @type {?} */\n\n\n      var tab = this._labelWrappers ? this._labelWrappers.toArray()[index] : null;\n      return !!tab && !tab.disabled;\n    };\n    /**\n     * Sets focus on the HTML element for the label wrapper and scrolls it into the view if\n     * scrolling is enabled.\n     */\n\n    /**\n     * Sets focus on the HTML element for the label wrapper and scrolls it into the view if\n     * scrolling is enabled.\n     * @param {?} tabIndex\n     * @return {?}\n     */\n\n\n    MatTabHeader.prototype._setTabFocus =\n    /**\n    * Sets focus on the HTML element for the label wrapper and scrolls it into the view if\n    * scrolling is enabled.\n    * @param {?} tabIndex\n    * @return {?}\n    */\n    function (tabIndex) {\n      if (this._showPaginationControls) {\n        this._scrollToLabel(tabIndex);\n      }\n\n      if (this._labelWrappers && this._labelWrappers.length) {\n        this._labelWrappers.toArray()[tabIndex].focus(); // Do not let the browser manage scrolling to focus the element, this will be handled\n        // by using translation. In LTR, the scroll left should be 0. In RTL, the scroll width\n        // should be the full width minus the offset width.\n\n        /** @type {?} */\n\n\n        var containerEl = this._tabListContainer.nativeElement;\n        /** @type {?} */\n\n        var dir = this._getLayoutDirection();\n\n        if (dir == 'ltr') {\n          containerEl.scrollLeft = 0;\n        } else {\n          containerEl.scrollLeft = containerEl.scrollWidth - containerEl.offsetWidth;\n        }\n      }\n    };\n    /** The layout direction of the containing app. */\n\n    /**\n     * The layout direction of the containing app.\n     * @return {?}\n     */\n\n\n    MatTabHeader.prototype._getLayoutDirection =\n    /**\n    * The layout direction of the containing app.\n    * @return {?}\n    */\n    function () {\n      return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';\n    };\n    /** Performs the CSS transformation on the tab list that will cause the list to scroll. */\n\n    /**\n     * Performs the CSS transformation on the tab list that will cause the list to scroll.\n     * @return {?}\n     */\n\n\n    MatTabHeader.prototype._updateTabScrollPosition =\n    /**\n    * Performs the CSS transformation on the tab list that will cause the list to scroll.\n    * @return {?}\n    */\n    function () {\n      /** @type {?} */\n      var scrollDistance = this.scrollDistance;\n      /** @type {?} */\n\n      var platform$$1 = this._platform;\n      /** @type {?} */\n\n      var translateX = this._getLayoutDirection() === 'ltr' ? -scrollDistance : scrollDistance; // Don't use `translate3d` here because we don't want to create a new layer. A new layer\n      // seems to cause flickering and overflow in Internet Explorer. For example, the ink bar\n      // and ripples will exceed the boundaries of the visible tab bar.\n      // See: https://github.com/angular/material2/issues/10276\n      // We round the `transform` here, because transforms with sub-pixel precision cause some\n      // browsers to blur the content of the element.\n\n      this._tabList.nativeElement.style.transform = \"translateX(\" + Math.round(translateX) + \"px)\"; // Setting the `transform` on IE will change the scroll offset of the parent, causing the\n      // position to be thrown off in some cases. We have to reset it ourselves to ensure that\n      // it doesn't get thrown off. Note that we scope it only to IE and Edge, because messing\n      // with the scroll position throws off Chrome 71+ in RTL mode (see #14689).\n      // @breaking-change 8.0.0 Remove null check for `platform`.\n\n      if (platform$$1 && (platform$$1.TRIDENT || platform$$1.EDGE)) {\n        this._tabListContainer.nativeElement.scrollLeft = 0;\n      }\n    };\n\n    Object.defineProperty(MatTabHeader.prototype, \"scrollDistance\", {\n      /** Sets the distance in pixels that the tab header should be transformed in the X-axis. */\n      get:\n      /**\n      * Sets the distance in pixels that the tab header should be transformed in the X-axis.\n      * @return {?}\n      */\n      function () {\n        return this._scrollDistance;\n      },\n      set:\n      /**\n      * @param {?} value\n      * @return {?}\n      */\n      function (value) {\n        this._scrollTo(value);\n      },\n      enumerable: true,\n      configurable: true\n    });\n    /**\n     * Moves the tab list in the 'before' or 'after' direction (towards the beginning of the list or\n     * the end of the list, respectively). The distance to scroll is computed to be a third of the\n     * length of the tab list view window.\n     *\n     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n     * should be called sparingly.\n     */\n\n    /**\n     * Moves the tab list in the 'before' or 'after' direction (towards the beginning of the list or\n     * the end of the list, respectively). The distance to scroll is computed to be a third of the\n     * length of the tab list view window.\n     *\n     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n     * should be called sparingly.\n     * @param {?} direction\n     * @return {?}\n     */\n\n    MatTabHeader.prototype._scrollHeader =\n    /**\n    * Moves the tab list in the 'before' or 'after' direction (towards the beginning of the list or\n    * the end of the list, respectively). The distance to scroll is computed to be a third of the\n    * length of the tab list view window.\n    *\n    * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n    * should be called sparingly.\n    * @param {?} direction\n    * @return {?}\n    */\n    function (direction) {\n      /** @type {?} */\n      var viewLength = this._tabListContainer.nativeElement.offsetWidth; // Move the scroll distance one-third the length of the tab list's viewport.\n\n      /** @type {?} */\n\n      var scrollAmount = (direction == 'before' ? -1 : 1) * viewLength / 3;\n      return this._scrollTo(this._scrollDistance + scrollAmount);\n    };\n    /** Handles click events on the pagination arrows. */\n\n    /**\n     * Handles click events on the pagination arrows.\n     * @param {?} direction\n     * @return {?}\n     */\n\n\n    MatTabHeader.prototype._handlePaginatorClick =\n    /**\n    * Handles click events on the pagination arrows.\n    * @param {?} direction\n    * @return {?}\n    */\n    function (direction) {\n      this._stopInterval();\n\n      this._scrollHeader(direction);\n    };\n    /**\n     * Moves the tab list such that the desired tab label (marked by index) is moved into view.\n     *\n     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n     * should be called sparingly.\n     */\n\n    /**\n     * Moves the tab list such that the desired tab label (marked by index) is moved into view.\n     *\n     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n     * should be called sparingly.\n     * @param {?} labelIndex\n     * @return {?}\n     */\n\n\n    MatTabHeader.prototype._scrollToLabel =\n    /**\n    * Moves the tab list such that the desired tab label (marked by index) is moved into view.\n    *\n    * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n    * should be called sparingly.\n    * @param {?} labelIndex\n    * @return {?}\n    */\n    function (labelIndex) {\n      /** @type {?} */\n      var selectedLabel = this._labelWrappers ? this._labelWrappers.toArray()[labelIndex] : null;\n\n      if (!selectedLabel) {\n        return;\n      } // The view length is the visible width of the tab labels.\n\n      /** @type {?} */\n\n\n      var viewLength = this._tabListContainer.nativeElement.offsetWidth;\n      /** @type {?} */\n\n      var labelBeforePos;\n      /** @type {?} */\n\n      var labelAfterPos;\n\n      if (this._getLayoutDirection() == 'ltr') {\n        labelBeforePos = selectedLabel.getOffsetLeft();\n        labelAfterPos = labelBeforePos + selectedLabel.getOffsetWidth();\n      } else {\n        labelAfterPos = this._tabList.nativeElement.offsetWidth - selectedLabel.getOffsetLeft();\n        labelBeforePos = labelAfterPos - selectedLabel.getOffsetWidth();\n      }\n      /** @type {?} */\n\n\n      var beforeVisiblePos = this.scrollDistance;\n      /** @type {?} */\n\n      var afterVisiblePos = this.scrollDistance + viewLength;\n\n      if (labelBeforePos < beforeVisiblePos) {\n        // Scroll header to move label to the before direction\n        this.scrollDistance -= beforeVisiblePos - labelBeforePos + EXAGGERATED_OVERSCROLL;\n      } else if (labelAfterPos > afterVisiblePos) {\n        // Scroll header to move label to the after direction\n        this.scrollDistance += labelAfterPos - afterVisiblePos + EXAGGERATED_OVERSCROLL;\n      }\n    };\n    /**\n     * Evaluate whether the pagination controls should be displayed. If the scroll width of the\n     * tab list is wider than the size of the header container, then the pagination controls should\n     * be shown.\n     *\n     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n     * should be called sparingly.\n     */\n\n    /**\n     * Evaluate whether the pagination controls should be displayed. If the scroll width of the\n     * tab list is wider than the size of the header container, then the pagination controls should\n     * be shown.\n     *\n     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n     * should be called sparingly.\n     * @return {?}\n     */\n\n\n    MatTabHeader.prototype._checkPaginationEnabled =\n    /**\n    * Evaluate whether the pagination controls should be displayed. If the scroll width of the\n    * tab list is wider than the size of the header container, then the pagination controls should\n    * be shown.\n    *\n    * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n    * should be called sparingly.\n    * @return {?}\n    */\n    function () {\n      /** @type {?} */\n      var isEnabled = this._tabList.nativeElement.scrollWidth > this._elementRef.nativeElement.offsetWidth;\n\n      if (!isEnabled) {\n        this.scrollDistance = 0;\n      }\n\n      if (isEnabled !== this._showPaginationControls) {\n        this._changeDetectorRef.markForCheck();\n      }\n\n      this._showPaginationControls = isEnabled;\n    };\n    /**\n     * Evaluate whether the before and after controls should be enabled or disabled.\n     * If the header is at the beginning of the list (scroll distance is equal to 0) then disable the\n     * before button. If the header is at the end of the list (scroll distance is equal to the\n     * maximum distance we can scroll), then disable the after button.\n     *\n     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n     * should be called sparingly.\n     */\n\n    /**\n     * Evaluate whether the before and after controls should be enabled or disabled.\n     * If the header is at the beginning of the list (scroll distance is equal to 0) then disable the\n     * before button. If the header is at the end of the list (scroll distance is equal to the\n     * maximum distance we can scroll), then disable the after button.\n     *\n     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n     * should be called sparingly.\n     * @return {?}\n     */\n\n\n    MatTabHeader.prototype._checkScrollingControls =\n    /**\n    * Evaluate whether the before and after controls should be enabled or disabled.\n    * If the header is at the beginning of the list (scroll distance is equal to 0) then disable the\n    * before button. If the header is at the end of the list (scroll distance is equal to the\n    * maximum distance we can scroll), then disable the after button.\n    *\n    * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n    * should be called sparingly.\n    * @return {?}\n    */\n    function () {\n      // Check if the pagination arrows should be activated.\n      this._disableScrollBefore = this.scrollDistance == 0;\n      this._disableScrollAfter = this.scrollDistance == this._getMaxScrollDistance();\n\n      this._changeDetectorRef.markForCheck();\n    };\n    /**\n     * Determines what is the maximum length in pixels that can be set for the scroll distance. This\n     * is equal to the difference in width between the tab list container and tab header container.\n     *\n     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n     * should be called sparingly.\n     */\n\n    /**\n     * Determines what is the maximum length in pixels that can be set for the scroll distance. This\n     * is equal to the difference in width between the tab list container and tab header container.\n     *\n     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n     * should be called sparingly.\n     * @return {?}\n     */\n\n\n    MatTabHeader.prototype._getMaxScrollDistance =\n    /**\n    * Determines what is the maximum length in pixels that can be set for the scroll distance. This\n    * is equal to the difference in width between the tab list container and tab header container.\n    *\n    * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n    * should be called sparingly.\n    * @return {?}\n    */\n    function () {\n      /** @type {?} */\n      var lengthOfTabList = this._tabList.nativeElement.scrollWidth;\n      /** @type {?} */\n\n      var viewLength = this._tabListContainer.nativeElement.offsetWidth;\n      return lengthOfTabList - viewLength || 0;\n    };\n    /** Tells the ink-bar to align itself to the current label wrapper */\n\n    /**\n     * Tells the ink-bar to align itself to the current label wrapper\n     * @return {?}\n     */\n\n\n    MatTabHeader.prototype._alignInkBarToSelectedTab =\n    /**\n    * Tells the ink-bar to align itself to the current label wrapper\n    * @return {?}\n    */\n    function () {\n      /** @type {?} */\n      var selectedLabelWrapper = this._labelWrappers && this._labelWrappers.length ? this._labelWrappers.toArray()[this.selectedIndex].elementRef.nativeElement : null;\n\n      this._inkBar.alignToElement(\n      /** @type {?} */\n      selectedLabelWrapper);\n    };\n    /** Stops the currently-running paginator interval.  */\n\n    /**\n     * Stops the currently-running paginator interval.\n     * @return {?}\n     */\n\n\n    MatTabHeader.prototype._stopInterval =\n    /**\n    * Stops the currently-running paginator interval.\n    * @return {?}\n    */\n    function () {\n      this._stopScrolling.next();\n    };\n    /**\n     * Handles the user pressing down on one of the paginators.\n     * Starts scrolling the header after a certain amount of time.\n     * @param direction In which direction the paginator should be scrolled.\n     */\n\n    /**\n     * Handles the user pressing down on one of the paginators.\n     * Starts scrolling the header after a certain amount of time.\n     * @param {?} direction In which direction the paginator should be scrolled.\n     * @return {?}\n     */\n\n\n    MatTabHeader.prototype._handlePaginatorPress =\n    /**\n    * Handles the user pressing down on one of the paginators.\n    * Starts scrolling the header after a certain amount of time.\n    * @param {?} direction In which direction the paginator should be scrolled.\n    * @return {?}\n    */\n    function (direction) {\n      var _this = this; // Avoid overlapping timers.\n\n\n      this._stopInterval(); // Start a timer after the delay and keep firing based on the interval.\n\n\n      rxjs.timer(HEADER_SCROLL_DELAY, HEADER_SCROLL_INTERVAL) // Keep the timer going until something tells it to stop or the component is destroyed.\n      .pipe(operators.takeUntil(rxjs.merge(this._stopScrolling, this._destroyed))).subscribe(function () {\n        var _a = _this._scrollHeader(direction),\n            maxScrollDistance = _a.maxScrollDistance,\n            distance = _a.distance; // Stop the timer if we've reached the start or the end.\n\n\n        if (distance === 0 || distance >= maxScrollDistance) {\n          _this._stopInterval();\n        }\n      });\n    };\n    /**\n     * Scrolls the header to a given position.\n     * @param position Position to which to scroll.\n     * @returns Information on the current scroll distance and the maximum.\n     */\n\n    /**\n     * Scrolls the header to a given position.\n     * @private\n     * @param {?} position Position to which to scroll.\n     * @return {?} Information on the current scroll distance and the maximum.\n     */\n\n\n    MatTabHeader.prototype._scrollTo =\n    /**\n    * Scrolls the header to a given position.\n    * @private\n    * @param {?} position Position to which to scroll.\n    * @return {?} Information on the current scroll distance and the maximum.\n    */\n    function (position) {\n      /** @type {?} */\n      var maxScrollDistance = this._getMaxScrollDistance();\n\n      this._scrollDistance = Math.max(0, Math.min(maxScrollDistance, position)); // Mark that the scroll distance has changed so that after the view is checked, the CSS\n      // transformation can move the header.\n\n      this._scrollDistanceChanged = true;\n\n      this._checkScrollingControls();\n\n      return {\n        maxScrollDistance: maxScrollDistance,\n        distance: this._scrollDistance\n      };\n    };\n\n    MatTabHeader.decorators = [{\n      type: core.Component,\n      args: [{\n        selector: 'mat-tab-header',\n        template: \"<div class=\\\"mat-tab-header-pagination mat-tab-header-pagination-before mat-elevation-z4\\\" #previousPaginator aria-hidden=\\\"true\\\" mat-ripple [matRippleDisabled]=\\\"_disableScrollBefore || disableRipple\\\" [class.mat-tab-header-pagination-disabled]=\\\"_disableScrollBefore\\\" (click)=\\\"_handlePaginatorClick('before')\\\" (mousedown)=\\\"_handlePaginatorPress('before')\\\" (touchend)=\\\"_stopInterval()\\\"><div class=\\\"mat-tab-header-pagination-chevron\\\"></div></div><div class=\\\"mat-tab-label-container\\\" #tabListContainer (keydown)=\\\"_handleKeydown($event)\\\"><div class=\\\"mat-tab-list\\\" #tabList role=\\\"tablist\\\" (cdkObserveContent)=\\\"_onContentChanges()\\\"><div class=\\\"mat-tab-labels\\\"><ng-content></ng-content></div><mat-ink-bar></mat-ink-bar></div></div><div class=\\\"mat-tab-header-pagination mat-tab-header-pagination-after mat-elevation-z4\\\" #nextPaginator aria-hidden=\\\"true\\\" mat-ripple [matRippleDisabled]=\\\"_disableScrollAfter || disableRipple\\\" [class.mat-tab-header-pagination-disabled]=\\\"_disableScrollAfter\\\" (mousedown)=\\\"_handlePaginatorPress('after')\\\" (click)=\\\"_handlePaginatorClick('after')\\\" (touchend)=\\\"_stopInterval()\\\"><div class=\\\"mat-tab-header-pagination-chevron\\\"></div></div>\",\n        styles: [\".mat-tab-header{display:flex;overflow:hidden;position:relative;flex-shrink:0}.mat-tab-label{height:48px;padding:0 24px;cursor:pointer;box-sizing:border-box;opacity:.6;min-width:160px;text-align:center;display:inline-flex;justify-content:center;align-items:center;white-space:nowrap;position:relative}.mat-tab-label:focus{outline:0}.mat-tab-label:focus:not(.mat-tab-disabled){opacity:1}@media (-ms-high-contrast:active){.mat-tab-label:focus{outline:dotted 2px}}.mat-tab-label.mat-tab-disabled{cursor:default}@media (-ms-high-contrast:active){.mat-tab-label.mat-tab-disabled{opacity:.5}}.mat-tab-label .mat-tab-label-content{display:inline-flex;justify-content:center;align-items:center;white-space:nowrap}@media (-ms-high-contrast:active){.mat-tab-label{opacity:1}}@media (max-width:599px){.mat-tab-label{min-width:72px}}.mat-ink-bar{position:absolute;bottom:0;height:2px;transition:.5s cubic-bezier(.35,0,.25,1)}.mat-tab-group-inverted-header .mat-ink-bar{bottom:auto;top:0}@media (-ms-high-contrast:active){.mat-ink-bar{outline:solid 2px;height:0}}.mat-tab-header-pagination{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;position:relative;display:none;justify-content:center;align-items:center;min-width:32px;cursor:pointer;z-index:2;-webkit-tap-highlight-color:transparent;touch-action:none}.mat-tab-header-pagination-controls-enabled .mat-tab-header-pagination{display:flex}.mat-tab-header-pagination-before,.mat-tab-header-rtl .mat-tab-header-pagination-after{padding-left:4px}.mat-tab-header-pagination-before .mat-tab-header-pagination-chevron,.mat-tab-header-rtl .mat-tab-header-pagination-after .mat-tab-header-pagination-chevron{transform:rotate(-135deg)}.mat-tab-header-pagination-after,.mat-tab-header-rtl .mat-tab-header-pagination-before{padding-right:4px}.mat-tab-header-pagination-after .mat-tab-header-pagination-chevron,.mat-tab-header-rtl .mat-tab-header-pagination-before .mat-tab-header-pagination-chevron{transform:rotate(45deg)}.mat-tab-header-pagination-chevron{border-style:solid;border-width:2px 2px 0 0;content:'';height:8px;width:8px}.mat-tab-header-pagination-disabled{box-shadow:none;cursor:default}.mat-tab-label-container{display:flex;flex-grow:1;overflow:hidden;z-index:1}.mat-tab-list{flex-grow:1;position:relative;transition:transform .5s cubic-bezier(.35,0,.25,1)}.mat-tab-labels{display:flex}[mat-align-tabs=center] .mat-tab-labels{justify-content:center}[mat-align-tabs=end] .mat-tab-labels{justify-content:flex-end}\"],\n        inputs: ['disableRipple'],\n        encapsulation: core.ViewEncapsulation.None,\n        changeDetection: core.ChangeDetectionStrategy.OnPush,\n        host: {\n          'class': 'mat-tab-header',\n          '[class.mat-tab-header-pagination-controls-enabled]': '_showPaginationControls',\n          '[class.mat-tab-header-rtl]': \"_getLayoutDirection() == 'rtl'\"\n        }\n      }]\n    }];\n    /** @nocollapse */\n\n    MatTabHeader.ctorParameters = function () {\n      return [{\n        type: core.ElementRef\n      }, {\n        type: core.ChangeDetectorRef\n      }, {\n        type: scrolling.ViewportRuler\n      }, {\n        type: bidi.Directionality,\n        decorators: [{\n          type: core.Optional\n        }]\n      }, {\n        type: core.NgZone\n      }, {\n        type: platform.Platform\n      }];\n    };\n\n    MatTabHeader.propDecorators = {\n      _labelWrappers: [{\n        type: core.ContentChildren,\n        args: [MatTabLabelWrapper]\n      }],\n      _inkBar: [{\n        type: core.ViewChild,\n        args: [MatInkBar]\n      }],\n      _tabListContainer: [{\n        type: core.ViewChild,\n        args: ['tabListContainer']\n      }],\n      _tabList: [{\n        type: core.ViewChild,\n        args: ['tabList']\n      }],\n      _nextPaginator: [{\n        type: core.ViewChild,\n        args: ['nextPaginator']\n      }],\n      _previousPaginator: [{\n        type: core.ViewChild,\n        args: ['previousPaginator']\n      }],\n      selectedIndex: [{\n        type: core.Input\n      }],\n      selectFocusedIndex: [{\n        type: core.Output\n      }],\n      indexFocused: [{\n        type: core.Output\n      }]\n    };\n    return MatTabHeader;\n  }(_MatTabHeaderMixinBase);\n  /**\n   * @fileoverview added by tsickle\n   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n   */\n\n  /**\n   * Used to generate unique ID's for each tab component\n   * @type {?}\n   */\n\n\n  var nextId = 0;\n  /**\n   * A simple change event emitted on focus or selection changes.\n   */\n\n  var\n  /**\n  * A simple change event emitted on focus or selection changes.\n  */\n  MatTabChangeEvent =\n  /** @class */\n  function () {\n    function MatTabChangeEvent() {}\n\n    return MatTabChangeEvent;\n  }();\n  /**\n   * Injection token that can be used to provide the default options the tabs module.\n   * @type {?}\n   */\n\n\n  var MAT_TABS_CONFIG = new core.InjectionToken('MAT_TABS_CONFIG'); // Boilerplate for applying mixins to MatTabGroup.\n\n  /**\n   * \\@docs-private\n   */\n\n  var // Boilerplate for applying mixins to MatTabGroup.\n\n  /**\n   * \\@docs-private\n   */\n  MatTabGroupBase =\n  /** @class */\n  function () {\n    function MatTabGroupBase(_elementRef) {\n      this._elementRef = _elementRef;\n    }\n\n    return MatTabGroupBase;\n  }();\n  /** @type {?} */\n\n\n  var _MatTabGroupMixinBase = core$1.mixinColor(core$1.mixinDisableRipple(MatTabGroupBase), 'primary');\n  /**\n   * Material design tab-group component.  Supports basic tab pairs (label + content) and includes\n   * animated ink-bar, keyboard navigation, and screen reader.\n   * See: https://material.io/design/components/tabs.html\n   */\n\n\n  var MatTabGroup =\n  /** @class */\n  function (_super) {\n    __extends(MatTabGroup, _super);\n\n    function MatTabGroup(elementRef, _changeDetectorRef, defaultConfig) {\n      var _this = _super.call(this, elementRef) || this;\n\n      _this._changeDetectorRef = _changeDetectorRef;\n      /**\n       * The tab index that should be selected after the content has been checked.\n       */\n\n      _this._indexToSelect = 0;\n      /**\n       * Snapshot of the height of the tab body wrapper before another tab is activated.\n       */\n\n      _this._tabBodyWrapperHeight = 0;\n      /**\n       * Subscription to tabs being added/removed.\n       */\n\n      _this._tabsSubscription = rxjs.Subscription.EMPTY;\n      /**\n       * Subscription to changes in the tab labels.\n       */\n\n      _this._tabLabelSubscription = rxjs.Subscription.EMPTY;\n      _this._dynamicHeight = false;\n      _this._selectedIndex = null;\n      /**\n       * Position of the tab header.\n       */\n\n      _this.headerPosition = 'above';\n      /**\n       * Output to enable support for two-way binding on `[(selectedIndex)]`\n       */\n\n      _this.selectedIndexChange = new core.EventEmitter();\n      /**\n       * Event emitted when focus has changed within a tab group.\n       */\n\n      _this.focusChange = new core.EventEmitter();\n      /**\n       * Event emitted when the body animation has completed\n       */\n\n      _this.animationDone = new core.EventEmitter();\n      /**\n       * Event emitted when the tab selection has changed.\n       */\n\n      _this.selectedTabChange = new core.EventEmitter(true);\n      _this._groupId = nextId++;\n      _this.animationDuration = defaultConfig && defaultConfig.animationDuration ? defaultConfig.animationDuration : '500ms';\n      return _this;\n    }\n\n    Object.defineProperty(MatTabGroup.prototype, \"dynamicHeight\", {\n      /** Whether the tab group should grow to the size of the active tab. */\n      get:\n      /**\n      * Whether the tab group should grow to the size of the active tab.\n      * @return {?}\n      */\n      function () {\n        return this._dynamicHeight;\n      },\n      set:\n      /**\n      * @param {?} value\n      * @return {?}\n      */\n      function (value) {\n        this._dynamicHeight = coercion.coerceBooleanProperty(value);\n      },\n      enumerable: true,\n      configurable: true\n    });\n    Object.defineProperty(MatTabGroup.prototype, \"selectedIndex\", {\n      /** The index of the active tab. */\n      get:\n      /**\n      * The index of the active tab.\n      * @return {?}\n      */\n      function () {\n        return this._selectedIndex;\n      },\n      set:\n      /**\n      * @param {?} value\n      * @return {?}\n      */\n      function (value) {\n        this._indexToSelect = coercion.coerceNumberProperty(value, null);\n      },\n      enumerable: true,\n      configurable: true\n    });\n    Object.defineProperty(MatTabGroup.prototype, \"animationDuration\", {\n      /** Duration for the tab animation. Will be normalized to milliseconds if no units are set. */\n      get:\n      /**\n      * Duration for the tab animation. Will be normalized to milliseconds if no units are set.\n      * @return {?}\n      */\n      function () {\n        return this._animationDuration;\n      },\n      set:\n      /**\n      * @param {?} value\n      * @return {?}\n      */\n      function (value) {\n        this._animationDuration = /^\\d+$/.test(value) ? value + 'ms' : value;\n      },\n      enumerable: true,\n      configurable: true\n    });\n    Object.defineProperty(MatTabGroup.prototype, \"backgroundColor\", {\n      /** Background color of the tab group. */\n      get:\n      /**\n      * Background color of the tab group.\n      * @return {?}\n      */\n      function () {\n        return this._backgroundColor;\n      },\n      set:\n      /**\n      * @param {?} value\n      * @return {?}\n      */\n      function (value) {\n        /** @type {?} */\n        var nativeElement = this._elementRef.nativeElement;\n        nativeElement.classList.remove(\"mat-background-\" + this.backgroundColor);\n\n        if (value) {\n          nativeElement.classList.add(\"mat-background-\" + value);\n        }\n\n        this._backgroundColor = value;\n      },\n      enumerable: true,\n      configurable: true\n    });\n    /**\n     * After the content is checked, this component knows what tabs have been defined\n     * and what the selected index should be. This is where we can know exactly what position\n     * each tab should be in according to the new selected index, and additionally we know how\n     * a new selected tab should transition in (from the left or right).\n     */\n\n    /**\n     * After the content is checked, this component knows what tabs have been defined\n     * and what the selected index should be. This is where we can know exactly what position\n     * each tab should be in according to the new selected index, and additionally we know how\n     * a new selected tab should transition in (from the left or right).\n     * @return {?}\n     */\n\n    MatTabGroup.prototype.ngAfterContentChecked =\n    /**\n    * After the content is checked, this component knows what tabs have been defined\n    * and what the selected index should be. This is where we can know exactly what position\n    * each tab should be in according to the new selected index, and additionally we know how\n    * a new selected tab should transition in (from the left or right).\n    * @return {?}\n    */\n    function () {\n      var _this = this; // Don't clamp the `indexToSelect` immediately in the setter because it can happen that\n      // the amount of tabs changes before the actual change detection runs.\n\n      /** @type {?} */\n\n\n      var indexToSelect = this._indexToSelect = this._clampTabIndex(this._indexToSelect); // If there is a change in selected index, emit a change event. Should not trigger if\n      // the selected index has not yet been initialized.\n\n\n      if (this._selectedIndex != indexToSelect) {\n        /** @type {?} */\n        var isFirstRun_1 = this._selectedIndex == null;\n\n        if (!isFirstRun_1) {\n          this.selectedTabChange.emit(this._createChangeEvent(indexToSelect));\n        } // Changing these values after change detection has run\n        // since the checked content may contain references to them.\n\n\n        Promise.resolve().then(function () {\n          _this._tabs.forEach(function (tab, index) {\n            return tab.isActive = index === indexToSelect;\n          });\n\n          if (!isFirstRun_1) {\n            _this.selectedIndexChange.emit(indexToSelect);\n          }\n        });\n      } // Setup the position for each tab and optionally setup an origin on the next selected tab.\n\n\n      this._tabs.forEach(function (tab, index) {\n        tab.position = index - indexToSelect; // If there is already a selected tab, then set up an origin for the next selected tab\n        // if it doesn't have one already.\n\n        if (_this._selectedIndex != null && tab.position == 0 && !tab.origin) {\n          tab.origin = indexToSelect - _this._selectedIndex;\n        }\n      });\n\n      if (this._selectedIndex !== indexToSelect) {\n        this._selectedIndex = indexToSelect;\n\n        this._changeDetectorRef.markForCheck();\n      }\n    };\n    /**\n     * @return {?}\n     */\n\n\n    MatTabGroup.prototype.ngAfterContentInit =\n    /**\n    * @return {?}\n    */\n    function () {\n      var _this = this;\n\n      this._subscribeToTabLabels(); // Subscribe to changes in the amount of tabs, in order to be\n      // able to re-render the content as new tabs are added or removed.\n\n\n      this._tabsSubscription = this._tabs.changes.subscribe(function () {\n        /** @type {?} */\n        var indexToSelect = _this._clampTabIndex(_this._indexToSelect); // Maintain the previously-selected tab if a new tab is added or removed and there is no\n        // explicit change that selects a different tab.\n\n\n        if (indexToSelect === _this._selectedIndex) {\n          /** @type {?} */\n          var tabs = _this._tabs.toArray();\n\n          for (var i = 0; i < tabs.length; i++) {\n            if (tabs[i].isActive) {\n              // Assign both to the `_indexToSelect` and `_selectedIndex` so we don't fire a changed\n              // event, otherwise the consumer may end up in an infinite loop in some edge cases like\n              // adding a tab within the `selectedIndexChange` event.\n              _this._indexToSelect = _this._selectedIndex = i;\n              break;\n            }\n          }\n        }\n\n        _this._subscribeToTabLabels();\n\n        _this._changeDetectorRef.markForCheck();\n      });\n    };\n    /**\n     * @return {?}\n     */\n\n\n    MatTabGroup.prototype.ngOnDestroy =\n    /**\n    * @return {?}\n    */\n    function () {\n      this._tabsSubscription.unsubscribe();\n\n      this._tabLabelSubscription.unsubscribe();\n    };\n    /** Re-aligns the ink bar to the selected tab element. */\n\n    /**\n     * Re-aligns the ink bar to the selected tab element.\n     * @return {?}\n     */\n\n\n    MatTabGroup.prototype.realignInkBar =\n    /**\n    * Re-aligns the ink bar to the selected tab element.\n    * @return {?}\n    */\n    function () {\n      if (this._tabHeader) {\n        this._tabHeader._alignInkBarToSelectedTab();\n      }\n    };\n    /**\n     * @param {?} index\n     * @return {?}\n     */\n\n\n    MatTabGroup.prototype._focusChanged =\n    /**\n    * @param {?} index\n    * @return {?}\n    */\n    function (index) {\n      this.focusChange.emit(this._createChangeEvent(index));\n    };\n    /**\n     * @private\n     * @param {?} index\n     * @return {?}\n     */\n\n\n    MatTabGroup.prototype._createChangeEvent =\n    /**\n    * @private\n    * @param {?} index\n    * @return {?}\n    */\n    function (index) {\n      /** @type {?} */\n      var event = new MatTabChangeEvent();\n      event.index = index;\n\n      if (this._tabs && this._tabs.length) {\n        event.tab = this._tabs.toArray()[index];\n      }\n\n      return event;\n    };\n    /**\n     * Subscribes to changes in the tab labels. This is needed, because the @Input for the label is\n     * on the MatTab component, whereas the data binding is inside the MatTabGroup. In order for the\n     * binding to be updated, we need to subscribe to changes in it and trigger change detection\n     * manually.\n     */\n\n    /**\n     * Subscribes to changes in the tab labels. This is needed, because the \\@Input for the label is\n     * on the MatTab component, whereas the data binding is inside the MatTabGroup. In order for the\n     * binding to be updated, we need to subscribe to changes in it and trigger change detection\n     * manually.\n     * @private\n     * @return {?}\n     */\n\n\n    MatTabGroup.prototype._subscribeToTabLabels =\n    /**\n    * Subscribes to changes in the tab labels. This is needed, because the \\@Input for the label is\n    * on the MatTab component, whereas the data binding is inside the MatTabGroup. In order for the\n    * binding to be updated, we need to subscribe to changes in it and trigger change detection\n    * manually.\n    * @private\n    * @return {?}\n    */\n    function () {\n      var _this = this;\n\n      if (this._tabLabelSubscription) {\n        this._tabLabelSubscription.unsubscribe();\n      }\n\n      this._tabLabelSubscription = rxjs.merge.apply(void 0, this._tabs.map(function (tab) {\n        return tab._stateChanges;\n      })).subscribe(function () {\n        return _this._changeDetectorRef.markForCheck();\n      });\n    };\n    /** Clamps the given index to the bounds of 0 and the tabs length. */\n\n    /**\n     * Clamps the given index to the bounds of 0 and the tabs length.\n     * @private\n     * @param {?} index\n     * @return {?}\n     */\n\n\n    MatTabGroup.prototype._clampTabIndex =\n    /**\n    * Clamps the given index to the bounds of 0 and the tabs length.\n    * @private\n    * @param {?} index\n    * @return {?}\n    */\n    function (index) {\n      // Note the `|| 0`, which ensures that values like NaN can't get through\n      // and which would otherwise throw the component into an infinite loop\n      // (since Math.max(NaN, 0) === NaN).\n      return Math.min(this._tabs.length - 1, Math.max(index || 0, 0));\n    };\n    /** Returns a unique id for each tab label element */\n\n    /**\n     * Returns a unique id for each tab label element\n     * @param {?} i\n     * @return {?}\n     */\n\n\n    MatTabGroup.prototype._getTabLabelId =\n    /**\n    * Returns a unique id for each tab label element\n    * @param {?} i\n    * @return {?}\n    */\n    function (i) {\n      return \"mat-tab-label-\" + this._groupId + \"-\" + i;\n    };\n    /** Returns a unique id for each tab content element */\n\n    /**\n     * Returns a unique id for each tab content element\n     * @param {?} i\n     * @return {?}\n     */\n\n\n    MatTabGroup.prototype._getTabContentId =\n    /**\n    * Returns a unique id for each tab content element\n    * @param {?} i\n    * @return {?}\n    */\n    function (i) {\n      return \"mat-tab-content-\" + this._groupId + \"-\" + i;\n    };\n    /**\n     * Sets the height of the body wrapper to the height of the activating tab if dynamic\n     * height property is true.\n     */\n\n    /**\n     * Sets the height of the body wrapper to the height of the activating tab if dynamic\n     * height property is true.\n     * @param {?} tabHeight\n     * @return {?}\n     */\n\n\n    MatTabGroup.prototype._setTabBodyWrapperHeight =\n    /**\n    * Sets the height of the body wrapper to the height of the activating tab if dynamic\n    * height property is true.\n    * @param {?} tabHeight\n    * @return {?}\n    */\n    function (tabHeight) {\n      if (!this._dynamicHeight || !this._tabBodyWrapperHeight) {\n        return;\n      }\n      /** @type {?} */\n\n\n      var wrapper = this._tabBodyWrapper.nativeElement;\n      wrapper.style.height = this._tabBodyWrapperHeight + 'px'; // This conditional forces the browser to paint the height so that\n      // the animation to the new height can have an origin.\n\n      if (this._tabBodyWrapper.nativeElement.offsetHeight) {\n        wrapper.style.height = tabHeight + 'px';\n      }\n    };\n    /** Removes the height of the tab body wrapper. */\n\n    /**\n     * Removes the height of the tab body wrapper.\n     * @return {?}\n     */\n\n\n    MatTabGroup.prototype._removeTabBodyWrapperHeight =\n    /**\n    * Removes the height of the tab body wrapper.\n    * @return {?}\n    */\n    function () {\n      /** @type {?} */\n      var wrapper = this._tabBodyWrapper.nativeElement;\n      this._tabBodyWrapperHeight = wrapper.clientHeight;\n      wrapper.style.height = '';\n      this.animationDone.emit();\n    };\n    /** Handle click events, setting new selected index if appropriate. */\n\n    /**\n     * Handle click events, setting new selected index if appropriate.\n     * @param {?} tab\n     * @param {?} tabHeader\n     * @param {?} index\n     * @return {?}\n     */\n\n\n    MatTabGroup.prototype._handleClick =\n    /**\n    * Handle click events, setting new selected index if appropriate.\n    * @param {?} tab\n    * @param {?} tabHeader\n    * @param {?} index\n    * @return {?}\n    */\n    function (tab, tabHeader, index) {\n      if (!tab.disabled) {\n        this.selectedIndex = tabHeader.focusIndex = index;\n      }\n    };\n    /** Retrieves the tabindex for the tab. */\n\n    /**\n     * Retrieves the tabindex for the tab.\n     * @param {?} tab\n     * @param {?} idx\n     * @return {?}\n     */\n\n\n    MatTabGroup.prototype._getTabIndex =\n    /**\n    * Retrieves the tabindex for the tab.\n    * @param {?} tab\n    * @param {?} idx\n    * @return {?}\n    */\n    function (tab, idx) {\n      if (tab.disabled) {\n        return null;\n      }\n\n      return this.selectedIndex === idx ? 0 : -1;\n    };\n\n    MatTabGroup.decorators = [{\n      type: core.Component,\n      args: [{\n        selector: 'mat-tab-group',\n        exportAs: 'matTabGroup',\n        template: \"<mat-tab-header #tabHeader [selectedIndex]=\\\"selectedIndex\\\" [disableRipple]=\\\"disableRipple\\\" (indexFocused)=\\\"_focusChanged($event)\\\" (selectFocusedIndex)=\\\"selectedIndex = $event\\\"><div class=\\\"mat-tab-label\\\" role=\\\"tab\\\" matTabLabelWrapper mat-ripple cdkMonitorElementFocus *ngFor=\\\"let tab of _tabs; let i = index\\\" [id]=\\\"_getTabLabelId(i)\\\" [attr.tabIndex]=\\\"_getTabIndex(tab, i)\\\" [attr.aria-posinset]=\\\"i + 1\\\" [attr.aria-setsize]=\\\"_tabs.length\\\" [attr.aria-controls]=\\\"_getTabContentId(i)\\\" [attr.aria-selected]=\\\"selectedIndex == i\\\" [attr.aria-label]=\\\"tab.ariaLabel || null\\\" [attr.aria-labelledby]=\\\"(!tab.ariaLabel && tab.ariaLabelledby) ? tab.ariaLabelledby : null\\\" [class.mat-tab-label-active]=\\\"selectedIndex == i\\\" [disabled]=\\\"tab.disabled\\\" [matRippleDisabled]=\\\"tab.disabled || disableRipple\\\" (click)=\\\"_handleClick(tab, tabHeader, i)\\\"><div class=\\\"mat-tab-label-content\\\"><ng-template [ngIf]=\\\"tab.templateLabel\\\"><ng-template [cdkPortalOutlet]=\\\"tab.templateLabel\\\"></ng-template></ng-template><ng-template [ngIf]=\\\"!tab.templateLabel\\\">{{tab.textLabel}}</ng-template></div></div></mat-tab-header><div class=\\\"mat-tab-body-wrapper\\\" #tabBodyWrapper><mat-tab-body role=\\\"tabpanel\\\" *ngFor=\\\"let tab of _tabs; let i = index\\\" [id]=\\\"_getTabContentId(i)\\\" [attr.aria-labelledby]=\\\"_getTabLabelId(i)\\\" [class.mat-tab-body-active]=\\\"selectedIndex == i\\\" [content]=\\\"tab.content\\\" [position]=\\\"tab.position\\\" [origin]=\\\"tab.origin\\\" [animationDuration]=\\\"animationDuration\\\" (_onCentered)=\\\"_removeTabBodyWrapperHeight()\\\" (_onCentering)=\\\"_setTabBodyWrapperHeight($event)\\\"></mat-tab-body></div>\",\n        styles: [\".mat-tab-group{display:flex;flex-direction:column}.mat-tab-group.mat-tab-group-inverted-header{flex-direction:column-reverse}.mat-tab-label{height:48px;padding:0 24px;cursor:pointer;box-sizing:border-box;opacity:.6;min-width:160px;text-align:center;display:inline-flex;justify-content:center;align-items:center;white-space:nowrap;position:relative}.mat-tab-label:focus{outline:0}.mat-tab-label:focus:not(.mat-tab-disabled){opacity:1}@media (-ms-high-contrast:active){.mat-tab-label:focus{outline:dotted 2px}}.mat-tab-label.mat-tab-disabled{cursor:default}@media (-ms-high-contrast:active){.mat-tab-label.mat-tab-disabled{opacity:.5}}.mat-tab-label .mat-tab-label-content{display:inline-flex;justify-content:center;align-items:center;white-space:nowrap}@media (-ms-high-contrast:active){.mat-tab-label{opacity:1}}@media (max-width:599px){.mat-tab-label{padding:0 12px}}@media (max-width:959px){.mat-tab-label{padding:0 12px}}.mat-tab-group[mat-stretch-tabs]>.mat-tab-header .mat-tab-label{flex-basis:0;flex-grow:1}.mat-tab-body-wrapper{position:relative;overflow:hidden;display:flex;transition:height .5s cubic-bezier(.35,0,.25,1)}.mat-tab-body{top:0;left:0;right:0;bottom:0;position:absolute;display:block;overflow:hidden;flex-basis:100%}.mat-tab-body.mat-tab-body-active{position:relative;overflow-x:hidden;overflow-y:auto;z-index:1;flex-grow:1}.mat-tab-group.mat-tab-group-dynamic-height .mat-tab-body.mat-tab-body-active{overflow-y:hidden}\"],\n        encapsulation: core.ViewEncapsulation.None,\n        changeDetection: core.ChangeDetectionStrategy.OnPush,\n        inputs: ['color', 'disableRipple'],\n        host: {\n          'class': 'mat-tab-group',\n          '[class.mat-tab-group-dynamic-height]': 'dynamicHeight',\n          '[class.mat-tab-group-inverted-header]': 'headerPosition === \"below\"'\n        }\n      }]\n    }];\n    /** @nocollapse */\n\n    MatTabGroup.ctorParameters = function () {\n      return [{\n        type: core.ElementRef\n      }, {\n        type: core.ChangeDetectorRef\n      }, {\n        type: undefined,\n        decorators: [{\n          type: core.Inject,\n          args: [MAT_TABS_CONFIG]\n        }, {\n          type: core.Optional\n        }]\n      }];\n    };\n\n    MatTabGroup.propDecorators = {\n      _tabs: [{\n        type: core.ContentChildren,\n        args: [MatTab]\n      }],\n      _tabBodyWrapper: [{\n        type: core.ViewChild,\n        args: ['tabBodyWrapper']\n      }],\n      _tabHeader: [{\n        type: core.ViewChild,\n        args: ['tabHeader']\n      }],\n      dynamicHeight: [{\n        type: core.Input\n      }],\n      selectedIndex: [{\n        type: core.Input\n      }],\n      headerPosition: [{\n        type: core.Input\n      }],\n      animationDuration: [{\n        type: core.Input\n      }],\n      backgroundColor: [{\n        type: core.Input\n      }],\n      selectedIndexChange: [{\n        type: core.Output\n      }],\n      focusChange: [{\n        type: core.Output\n      }],\n      animationDone: [{\n        type: core.Output\n      }],\n      selectedTabChange: [{\n        type: core.Output\n      }]\n    };\n    return MatTabGroup;\n  }(_MatTabGroupMixinBase);\n  /**\n   * @fileoverview added by tsickle\n   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n   */\n  // Boilerplate for applying mixins to MatTabNav.\n\n  /**\n   * \\@docs-private\n   */\n\n\n  var // Boilerplate for applying mixins to MatTabNav.\n\n  /**\n   * \\@docs-private\n   */\n  MatTabNavBase =\n  /** @class */\n  function () {\n    function MatTabNavBase(_elementRef) {\n      this._elementRef = _elementRef;\n    }\n\n    return MatTabNavBase;\n  }();\n  /** @type {?} */\n\n\n  var _MatTabNavMixinBase = core$1.mixinDisableRipple(core$1.mixinColor(MatTabNavBase, 'primary'));\n  /**\n   * Navigation component matching the styles of the tab group header.\n   * Provides anchored navigation with animated ink bar.\n   */\n\n\n  var MatTabNav =\n  /** @class */\n  function (_super) {\n    __extends(MatTabNav, _super);\n\n    function MatTabNav(elementRef, _dir, _ngZone, _changeDetectorRef, _viewportRuler) {\n      var _this = _super.call(this, elementRef) || this;\n\n      _this._dir = _dir;\n      _this._ngZone = _ngZone;\n      _this._changeDetectorRef = _changeDetectorRef;\n      _this._viewportRuler = _viewportRuler;\n      /**\n       * Subject that emits when the component has been destroyed.\n       */\n\n      _this._onDestroy = new rxjs.Subject();\n      return _this;\n    }\n\n    Object.defineProperty(MatTabNav.prototype, \"backgroundColor\", {\n      /** Background color of the tab nav. */\n      get:\n      /**\n      * Background color of the tab nav.\n      * @return {?}\n      */\n      function () {\n        return this._backgroundColor;\n      },\n      set:\n      /**\n      * @param {?} value\n      * @return {?}\n      */\n      function (value) {\n        /** @type {?} */\n        var nativeElement = this._elementRef.nativeElement;\n        nativeElement.classList.remove(\"mat-background-\" + this.backgroundColor);\n\n        if (value) {\n          nativeElement.classList.add(\"mat-background-\" + value);\n        }\n\n        this._backgroundColor = value;\n      },\n      enumerable: true,\n      configurable: true\n    });\n    /**\n     * Notifies the component that the active link has been changed.\n     * @breaking-change 8.0.0 `element` parameter to be removed.\n     */\n\n    /**\n     * Notifies the component that the active link has been changed.\n     * \\@breaking-change 8.0.0 `element` parameter to be removed.\n     * @param {?} element\n     * @return {?}\n     */\n\n    MatTabNav.prototype.updateActiveLink =\n    /**\n    * Notifies the component that the active link has been changed.\n    * \\@breaking-change 8.0.0 `element` parameter to be removed.\n    * @param {?} element\n    * @return {?}\n    */\n    function (element) {\n      // Note: keeping the `element` for backwards-compat, but isn't being used for anything.\n      // @breaking-change 8.0.0\n      this._activeLinkChanged = !!element;\n\n      this._changeDetectorRef.markForCheck();\n    };\n    /**\n     * @return {?}\n     */\n\n\n    MatTabNav.prototype.ngAfterContentInit =\n    /**\n    * @return {?}\n    */\n    function () {\n      var _this = this;\n\n      this._ngZone.runOutsideAngular(function () {\n        /** @type {?} */\n        var dirChange = _this._dir ? _this._dir.change : rxjs.of(null);\n        return rxjs.merge(dirChange, _this._viewportRuler.change(10)).pipe(operators.takeUntil(_this._onDestroy)).subscribe(function () {\n          return _this._alignInkBar();\n        });\n      });\n    };\n    /** Checks if the active link has been changed and, if so, will update the ink bar. */\n\n    /**\n     * Checks if the active link has been changed and, if so, will update the ink bar.\n     * @return {?}\n     */\n\n\n    MatTabNav.prototype.ngAfterContentChecked =\n    /**\n    * Checks if the active link has been changed and, if so, will update the ink bar.\n    * @return {?}\n    */\n    function () {\n      if (this._activeLinkChanged) {\n        /** @type {?} */\n        var activeTab = this._tabLinks.find(function (tab) {\n          return tab.active;\n        });\n\n        this._activeLinkElement = activeTab ? activeTab._elementRef : null;\n\n        this._alignInkBar();\n\n        this._activeLinkChanged = false;\n      }\n    };\n    /**\n     * @return {?}\n     */\n\n\n    MatTabNav.prototype.ngOnDestroy =\n    /**\n    * @return {?}\n    */\n    function () {\n      this._onDestroy.next();\n\n      this._onDestroy.complete();\n    };\n    /** Aligns the ink bar to the active link. */\n\n    /**\n     * Aligns the ink bar to the active link.\n     * @return {?}\n     */\n\n\n    MatTabNav.prototype._alignInkBar =\n    /**\n    * Aligns the ink bar to the active link.\n    * @return {?}\n    */\n    function () {\n      if (this._activeLinkElement) {\n        this._inkBar.show();\n\n        this._inkBar.alignToElement(this._activeLinkElement.nativeElement);\n      } else {\n        this._inkBar.hide();\n      }\n    };\n\n    MatTabNav.decorators = [{\n      type: core.Component,\n      args: [{\n        selector: '[mat-tab-nav-bar]',\n        exportAs: 'matTabNavBar, matTabNav',\n        inputs: ['color', 'disableRipple'],\n        template: \"<div class=\\\"mat-tab-links\\\" (cdkObserveContent)=\\\"_alignInkBar()\\\"><ng-content></ng-content><mat-ink-bar></mat-ink-bar></div>\",\n        styles: [\".mat-tab-nav-bar{overflow:hidden;position:relative;flex-shrink:0}.mat-tab-links{position:relative;display:flex}[mat-align-tabs=center] .mat-tab-links{justify-content:center}[mat-align-tabs=end] .mat-tab-links{justify-content:flex-end}.mat-tab-link{height:48px;padding:0 24px;cursor:pointer;box-sizing:border-box;opacity:.6;min-width:160px;text-align:center;display:inline-flex;justify-content:center;align-items:center;white-space:nowrap;vertical-align:top;text-decoration:none;position:relative;overflow:hidden;-webkit-tap-highlight-color:transparent}.mat-tab-link:focus{outline:0}.mat-tab-link:focus:not(.mat-tab-disabled){opacity:1}@media (-ms-high-contrast:active){.mat-tab-link:focus{outline:dotted 2px}}.mat-tab-link.mat-tab-disabled{cursor:default}@media (-ms-high-contrast:active){.mat-tab-link.mat-tab-disabled{opacity:.5}}.mat-tab-link .mat-tab-label-content{display:inline-flex;justify-content:center;align-items:center;white-space:nowrap}@media (-ms-high-contrast:active){.mat-tab-link{opacity:1}}[mat-stretch-tabs] .mat-tab-link{flex-basis:0;flex-grow:1}.mat-tab-link.mat-tab-disabled{pointer-events:none}@media (max-width:599px){.mat-tab-link{min-width:72px}}.mat-ink-bar{position:absolute;bottom:0;height:2px;transition:.5s cubic-bezier(.35,0,.25,1)}.mat-tab-group-inverted-header .mat-ink-bar{bottom:auto;top:0}@media (-ms-high-contrast:active){.mat-ink-bar{outline:solid 2px;height:0}}\"],\n        host: {\n          'class': 'mat-tab-nav-bar'\n        },\n        encapsulation: core.ViewEncapsulation.None,\n        changeDetection: core.ChangeDetectionStrategy.OnPush\n      }]\n    }];\n    /** @nocollapse */\n\n    MatTabNav.ctorParameters = function () {\n      return [{\n        type: core.ElementRef\n      }, {\n        type: bidi.Directionality,\n        decorators: [{\n          type: core.Optional\n        }]\n      }, {\n        type: core.NgZone\n      }, {\n        type: core.ChangeDetectorRef\n      }, {\n        type: scrolling.ViewportRuler\n      }];\n    };\n\n    MatTabNav.propDecorators = {\n      _inkBar: [{\n        type: core.ViewChild,\n        args: [MatInkBar]\n      }],\n      _tabLinks: [{\n        type: core.ContentChildren,\n        args: [core.forwardRef(function () {\n          return MatTabLink;\n        }), {\n          descendants: true\n        }]\n      }],\n      backgroundColor: [{\n        type: core.Input\n      }]\n    };\n    return MatTabNav;\n  }(_MatTabNavMixinBase); // Boilerplate for applying mixins to MatTabLink.\n\n\n  var // Boilerplate for applying mixins to MatTabLink.\n  MatTabLinkBase =\n  /** @class */\n  function () {\n    function MatTabLinkBase() {}\n\n    return MatTabLinkBase;\n  }();\n  /** @type {?} */\n\n\n  var _MatTabLinkMixinBase = core$1.mixinTabIndex(core$1.mixinDisableRipple(core$1.mixinDisabled(MatTabLinkBase)));\n  /**\n   * Link inside of a `mat-tab-nav-bar`.\n   */\n\n\n  var MatTabLink =\n  /** @class */\n  function (_super) {\n    __extends(MatTabLink, _super);\n\n    function MatTabLink(_tabNavBar, _elementRef, ngZone, platform$$1, globalRippleOptions, tabIndex, _focusMonitor) {\n      var _this = _super.call(this) || this;\n\n      _this._tabNavBar = _tabNavBar;\n      _this._elementRef = _elementRef;\n      _this._focusMonitor = _focusMonitor;\n      /**\n       * Whether the tab link is active or not.\n       */\n\n      _this._isActive = false;\n      _this._tabLinkRipple = new core$1.RippleRenderer(_this, ngZone, _elementRef, platform$$1);\n\n      _this._tabLinkRipple.setupTriggerEvents(_elementRef.nativeElement);\n\n      _this.rippleConfig = globalRippleOptions || {};\n      _this.tabIndex = parseInt(tabIndex) || 0;\n\n      if (_focusMonitor) {\n        _focusMonitor.monitor(_elementRef);\n      }\n\n      return _this;\n    }\n\n    Object.defineProperty(MatTabLink.prototype, \"active\", {\n      /** Whether the link is active. */\n      get:\n      /**\n      * Whether the link is active.\n      * @return {?}\n      */\n      function () {\n        return this._isActive;\n      },\n      set:\n      /**\n      * @param {?} value\n      * @return {?}\n      */\n      function (value) {\n        if (value !== this._isActive) {\n          this._isActive = value;\n\n          this._tabNavBar.updateActiveLink(this._elementRef);\n        }\n      },\n      enumerable: true,\n      configurable: true\n    });\n    Object.defineProperty(MatTabLink.prototype, \"rippleDisabled\", {\n      /**\n       * Whether ripples are disabled on interaction.\n       * @docs-private\n       */\n      get:\n      /**\n      * Whether ripples are disabled on interaction.\n      * \\@docs-private\n      * @return {?}\n      */\n      function () {\n        return this.disabled || this.disableRipple || this._tabNavBar.disableRipple || !!this.rippleConfig.disabled;\n      },\n      enumerable: true,\n      configurable: true\n    });\n    /**\n     * @return {?}\n     */\n\n    MatTabLink.prototype.ngOnDestroy =\n    /**\n    * @return {?}\n    */\n    function () {\n      this._tabLinkRipple._removeTriggerEvents();\n\n      if (this._focusMonitor) {\n        this._focusMonitor.stopMonitoring(this._elementRef);\n      }\n    };\n\n    MatTabLink.decorators = [{\n      type: core.Directive,\n      args: [{\n        selector: '[mat-tab-link], [matTabLink]',\n        exportAs: 'matTabLink',\n        inputs: ['disabled', 'disableRipple', 'tabIndex'],\n        host: {\n          'class': 'mat-tab-link',\n          '[attr.aria-current]': 'active',\n          '[attr.aria-disabled]': 'disabled.toString()',\n          '[attr.tabIndex]': 'tabIndex',\n          '[class.mat-tab-disabled]': 'disabled',\n          '[class.mat-tab-label-active]': 'active'\n        }\n      }]\n    }];\n    /** @nocollapse */\n\n    MatTabLink.ctorParameters = function () {\n      return [{\n        type: MatTabNav\n      }, {\n        type: core.ElementRef\n      }, {\n        type: core.NgZone\n      }, {\n        type: platform.Platform\n      }, {\n        type: undefined,\n        decorators: [{\n          type: core.Optional\n        }, {\n          type: core.Inject,\n          args: [core$1.MAT_RIPPLE_GLOBAL_OPTIONS]\n        }]\n      }, {\n        type: String,\n        decorators: [{\n          type: core.Attribute,\n          args: ['tabindex']\n        }]\n      }, {\n        type: a11y.FocusMonitor\n      }];\n    };\n\n    MatTabLink.propDecorators = {\n      active: [{\n        type: core.Input\n      }]\n    };\n    return MatTabLink;\n  }(_MatTabLinkMixinBase);\n  /**\n   * @fileoverview added by tsickle\n   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n   */\n\n\n  var MatTabsModule =\n  /** @class */\n  function () {\n    function MatTabsModule() {}\n\n    MatTabsModule.decorators = [{\n      type: core.NgModule,\n      args: [{\n        imports: [common.CommonModule, core$1.MatCommonModule, portal.PortalModule, core$1.MatRippleModule, observers.ObserversModule, a11y.A11yModule],\n        // Don't export all components because some are only to be used internally.\n        exports: [core$1.MatCommonModule, MatTabGroup, MatTabLabel, MatTab, MatTabNav, MatTabLink, MatTabContent],\n        declarations: [MatTabGroup, MatTabLabel, MatTab, MatInkBar, MatTabLabelWrapper, MatTabNav, MatTabLink, MatTabBody, MatTabBodyPortal, MatTabHeader, MatTabContent]\n      }]\n    }];\n    return MatTabsModule;\n  }();\n\n  exports.MatInkBar = MatInkBar;\n  exports._MAT_INK_BAR_POSITIONER = _MAT_INK_BAR_POSITIONER;\n  exports.MatTabBody = MatTabBody;\n  exports.MatTabBodyPortal = MatTabBodyPortal;\n  exports.MatTabHeader = MatTabHeader;\n  exports.MatTabLabelWrapper = MatTabLabelWrapper;\n  exports.MatTab = MatTab;\n  exports.MatTabLabel = MatTabLabel;\n  exports.MatTabNav = MatTabNav;\n  exports.MatTabLink = MatTabLink;\n  exports.MatTabContent = MatTabContent;\n  exports.MatTabsModule = MatTabsModule;\n  exports.MatTabChangeEvent = MatTabChangeEvent;\n  exports.MAT_TABS_CONFIG = MAT_TABS_CONFIG;\n  exports.MatTabGroupBase = MatTabGroupBase;\n  exports._MatTabGroupMixinBase = _MatTabGroupMixinBase;\n  exports.MatTabGroup = MatTabGroup;\n  exports.matTabsAnimations = matTabsAnimations;\n  exports.ɵa21 = _MAT_INK_BAR_POSITIONER_FACTORY;\n  exports.ɵf21 = MatTabBase;\n  exports.ɵg21 = _MatTabMixinBase;\n  exports.ɵb21 = MatTabHeaderBase;\n  exports.ɵc21 = _MatTabHeaderMixinBase;\n  exports.ɵd21 = MatTabLabelWrapperBase;\n  exports.ɵe21 = _MatTabLabelWrapperMixinBase;\n  exports.ɵj21 = MatTabLinkBase;\n  exports.ɵh21 = MatTabNavBase;\n  exports.ɵk21 = _MatTabLinkMixinBase;\n  exports.ɵi21 = _MatTabNavMixinBase;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":{"version":3,"names":["global","factory","exports","module","require","define","amd","ng","material","tabs","core","cdk","portal","rxjs","animations","bidi","operators","coercion","keycodes","scrolling","a11y","platform","observers","common","core$1","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__extends","__","constructor","prototype","create","_MAT_INK_BAR_POSITIONER","InjectionToken","providedIn","_MAT_INK_BAR_POSITIONER_FACTORY","method","element","left","offsetLeft","width","offsetWidth","MatInkBar","_elementRef","_ngZone","_inkBarPositioner","alignToElement","_this","show","requestAnimationFrame","runOutsideAngular","_setStyles","nativeElement","style","visibility","hide","positions","inkBar","decorators","type","Directive","args","selector","host","ctorParameters","ElementRef","NgZone","undefined","Inject","MatTabContent","template","TemplateRef","MatTabLabel","_super","apply","arguments","CdkPortal","MatTabBase","_MatTabMixinBase","mixinDisabled","MatTab","_viewContainerRef","call","textLabel","_contentPortal","_stateChanges","Subject","position","origin","isActive","defineProperty","get","enumerable","configurable","ngOnChanges","changes","next","ngOnDestroy","complete","ngOnInit","TemplatePortal","_explicitContent","_implicitContent","Component","inputs","changeDetection","ChangeDetectionStrategy","OnPush","encapsulation","ViewEncapsulation","None","exportAs","ViewContainerRef","propDecorators","templateLabel","ContentChild","read","ViewChild","Input","ariaLabel","ariaLabelledby","matTabsAnimations","translateTab","trigger","state","transform","minHeight","transition","animate","MatTabBodyPortal","componentFactoryResolver","viewContainerRef","_host","_centeringSub","Subscription","EMPTY","_leavingSub","_beforeCentering","pipe","startWith","_isCenterPosition","_position","subscribe","isCentering","hasAttached","attach","_content","_afterLeavingCenter","detach","unsubscribe","ComponentFactoryResolver","MatTabBody","forwardRef","CdkPortalOutlet","_dir","changeDetectorRef","_dirChangeSubscription","_translateTabComplete","_onCentering","EventEmitter","_onCentered","animationDuration","change","dir","_computePositionAnimationState","markForCheck","distinctUntilChanged","x","y","fromState","toState","event","emit","set","_positionIndex","_computePositionFromOrigin","_onTranslateTabStarted","clientHeight","_getLayoutDirection","value","styles","Directionality","Optional","ChangeDetectorRef","Output","_portalHost","PortalHostDirective","MatTabLabelWrapperBase","_MatTabLabelWrapperMixinBase","MatTabLabelWrapper","elementRef","focus","getOffsetLeft","getOffsetWidth","passiveEventListenerOptions","normalizePassiveListenerOptions","passive","EXAGGERATED_OVERSCROLL","HEADER_SCROLL_DELAY","HEADER_SCROLL_INTERVAL","MatTabHeaderBase","_MatTabHeaderMixinBase","mixinDisableRipple","MatTabHeader","_changeDetectorRef","_viewportRuler","_platform","_scrollDistance","_selectedIndexChanged","_destroyed","_showPaginationControls","_disableScrollAfter","_disableScrollBefore","_stopScrolling","_selectedIndex","selectFocusedIndex","indexFocused","bindEvent","fromEvent","takeUntil","_stopInterval","coerceNumberProperty","_keyManager","updateActiveItemIndex","ngAfterContentChecked","_tabLabelCount","_labelWrappers","length","updatePagination","_scrollToLabel","_checkScrollingControls","_alignInkBarToSelectedTab","_scrollDistanceChanged","_updateTabScrollPosition","_handleKeydown","hasModifierKey","keyCode","HOME","setFirstItemActive","preventDefault","END","setLastItemActive","ENTER","SPACE","focusIndex","onKeydown","ngAfterContentInit","dirChange","of","resize","realign","FocusKeyManager","withHorizontalOrientation","withWrap","updateActiveItem","merge","newFocusIndex","_setTabFocus","ngAfterViewInit","_previousPaginator","_handlePaginatorPress","_nextPaginator","_onContentChanges","textContent","_currentTextContent","zoneCallback","run","_checkPaginationEnabled","activeItemIndex","_isValidIndex","setActiveItem","index","tab","toArray","disabled","tabIndex","containerEl","_tabListContainer","scrollLeft","scrollWidth","scrollDistance","platform$$1","translateX","_tabList","Math","round","TRIDENT","EDGE","_scrollTo","_scrollHeader","direction","viewLength","scrollAmount","_handlePaginatorClick","labelIndex","selectedLabel","labelBeforePos","labelAfterPos","beforeVisiblePos","afterVisiblePos","isEnabled","_getMaxScrollDistance","lengthOfTabList","selectedLabelWrapper","selectedIndex","_inkBar","timer","_a","maxScrollDistance","distance","max","min","ViewportRuler","Platform","ContentChildren","nextId","MatTabChangeEvent","MAT_TABS_CONFIG","MatTabGroupBase","_MatTabGroupMixinBase","mixinColor","MatTabGroup","defaultConfig","_indexToSelect","_tabBodyWrapperHeight","_tabsSubscription","_tabLabelSubscription","_dynamicHeight","headerPosition","selectedIndexChange","focusChange","animationDone","selectedTabChange","_groupId","coerceBooleanProperty","_animationDuration","test","_backgroundColor","classList","remove","backgroundColor","add","indexToSelect","_clampTabIndex","isFirstRun_1","_createChangeEvent","Promise","resolve","then","_tabs","forEach","_subscribeToTabLabels","i","realignInkBar","_tabHeader","_focusChanged","map","_getTabLabelId","_getTabContentId","_setTabBodyWrapperHeight","tabHeight","wrapper","_tabBodyWrapper","height","offsetHeight","_removeTabBodyWrapperHeight","_handleClick","tabHeader","_getTabIndex","idx","dynamicHeight","MatTabNavBase","_MatTabNavMixinBase","MatTabNav","_onDestroy","updateActiveLink","_activeLinkChanged","_alignInkBar","activeTab","_tabLinks","find","active","_activeLinkElement","MatTabLink","descendants","MatTabLinkBase","_MatTabLinkMixinBase","mixinTabIndex","_tabNavBar","ngZone","globalRippleOptions","_focusMonitor","_isActive","_tabLinkRipple","RippleRenderer","setupTriggerEvents","rippleConfig","parseInt","monitor","disableRipple","_removeTriggerEvents","stopMonitoring","MAT_RIPPLE_GLOBAL_OPTIONS","String","Attribute","FocusMonitor","MatTabsModule","NgModule","imports","CommonModule","MatCommonModule","PortalModule","MatRippleModule","ObserversModule","A11yModule","declarations","ɵa21","ɵf21","ɵg21","ɵb21","ɵc21","ɵd21","ɵe21","ɵj21","ɵh21","ɵk21","ɵi21"],"sources":["C:/Users/ismae/Desktop/PVGym/PVGymAngularClient/ClientApp/node_modules/@angular/material/bundles/material-tabs.umd.js"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/cdk/portal'), require('@angular/material/core'), require('rxjs'), require('@angular/animations'), require('@angular/cdk/bidi'), require('rxjs/operators'), require('@angular/cdk/coercion'), require('@angular/cdk/keycodes'), require('@angular/cdk/scrolling'), require('@angular/cdk/a11y'), require('@angular/cdk/platform'), require('@angular/cdk/observers'), require('@angular/common')) :\n\ttypeof define === 'function' && define.amd ? define('@angular/material/tabs', ['exports', '@angular/core', '@angular/cdk/portal', '@angular/material/core', 'rxjs', '@angular/animations', '@angular/cdk/bidi', 'rxjs/operators', '@angular/cdk/coercion', '@angular/cdk/keycodes', '@angular/cdk/scrolling', '@angular/cdk/a11y', '@angular/cdk/platform', '@angular/cdk/observers', '@angular/common'], factory) :\n\t(factory((global.ng = global.ng || {}, global.ng.material = global.ng.material || {}, global.ng.material.tabs = {}),global.ng.core,global.ng.cdk.portal,global.ng.material.core,global.rxjs,global.ng.animations,global.ng.cdk.bidi,global.rxjs.operators,global.ng.cdk.coercion,global.ng.cdk.keycodes,global.ng.cdk.scrolling,global.ng.cdk.a11y,global.ng.cdk.platform,global.ng.cdk.observers,global.ng.common));\n}(this, (function (exports,core,portal,core$1,rxjs,animations,bidi,operators,coercion,keycodes,scrolling,a11y,platform,observers,common) { 'use strict';\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Injection token for the MatInkBar's Positioner.\n * @type {?}\n */\nvar _MAT_INK_BAR_POSITIONER = new core.InjectionToken('MatInkBarPositioner', {\n    providedIn: 'root',\n    factory: _MAT_INK_BAR_POSITIONER_FACTORY\n});\n/**\n * The default positioner function for the MatInkBar.\n * \\@docs-private\n * @return {?}\n */\nfunction _MAT_INK_BAR_POSITIONER_FACTORY() {\n    /** @type {?} */\n    var method = function (element) { return ({\n        left: element ? (element.offsetLeft || 0) + 'px' : '0',\n        width: element ? (element.offsetWidth || 0) + 'px' : '0',\n    }); };\n    return method;\n}\n/**\n * The ink-bar is used to display and animate the line underneath the current active tab label.\n * \\@docs-private\n */\nvar MatInkBar = /** @class */ (function () {\n    function MatInkBar(_elementRef, _ngZone, _inkBarPositioner) {\n        this._elementRef = _elementRef;\n        this._ngZone = _ngZone;\n        this._inkBarPositioner = _inkBarPositioner;\n    }\n    /**\n     * Calculates the styles from the provided element in order to align the ink-bar to that element.\n     * Shows the ink bar if previously set as hidden.\n     * @param element\n     */\n    /**\n     * Calculates the styles from the provided element in order to align the ink-bar to that element.\n     * Shows the ink bar if previously set as hidden.\n     * @param {?} element\n     * @return {?}\n     */\n    MatInkBar.prototype.alignToElement = /**\n     * Calculates the styles from the provided element in order to align the ink-bar to that element.\n     * Shows the ink bar if previously set as hidden.\n     * @param {?} element\n     * @return {?}\n     */\n    function (element) {\n        var _this = this;\n        this.show();\n        if (typeof requestAnimationFrame !== 'undefined') {\n            this._ngZone.runOutsideAngular(function () {\n                requestAnimationFrame(function () { return _this._setStyles(element); });\n            });\n        }\n        else {\n            this._setStyles(element);\n        }\n    };\n    /** Shows the ink bar. */\n    /**\n     * Shows the ink bar.\n     * @return {?}\n     */\n    MatInkBar.prototype.show = /**\n     * Shows the ink bar.\n     * @return {?}\n     */\n    function () {\n        this._elementRef.nativeElement.style.visibility = 'visible';\n    };\n    /** Hides the ink bar. */\n    /**\n     * Hides the ink bar.\n     * @return {?}\n     */\n    MatInkBar.prototype.hide = /**\n     * Hides the ink bar.\n     * @return {?}\n     */\n    function () {\n        this._elementRef.nativeElement.style.visibility = 'hidden';\n    };\n    /**\n     * Sets the proper styles to the ink bar element.\n     * @param element\n     */\n    /**\n     * Sets the proper styles to the ink bar element.\n     * @private\n     * @param {?} element\n     * @return {?}\n     */\n    MatInkBar.prototype._setStyles = /**\n     * Sets the proper styles to the ink bar element.\n     * @private\n     * @param {?} element\n     * @return {?}\n     */\n    function (element) {\n        /** @type {?} */\n        var positions = this._inkBarPositioner(element);\n        /** @type {?} */\n        var inkBar = this._elementRef.nativeElement;\n        inkBar.style.left = positions.left;\n        inkBar.style.width = positions.width;\n    };\n    MatInkBar.decorators = [\n        { type: core.Directive, args: [{\n                    selector: 'mat-ink-bar',\n                    host: {\n                        'class': 'mat-ink-bar',\n                    },\n                },] },\n    ];\n    /** @nocollapse */\n    MatInkBar.ctorParameters = function () { return [\n        { type: core.ElementRef },\n        { type: core.NgZone },\n        { type: undefined, decorators: [{ type: core.Inject, args: [_MAT_INK_BAR_POSITIONER,] }] }\n    ]; };\n    return MatInkBar;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Decorates the `ng-template` tags and reads out the template from it.\n */\nvar MatTabContent = /** @class */ (function () {\n    function MatTabContent(template) {\n        this.template = template;\n    }\n    MatTabContent.decorators = [\n        { type: core.Directive, args: [{ selector: '[matTabContent]' },] },\n    ];\n    /** @nocollapse */\n    MatTabContent.ctorParameters = function () { return [\n        { type: core.TemplateRef }\n    ]; };\n    return MatTabContent;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Used to flag tab labels for use with the portal directive\n */\nvar MatTabLabel = /** @class */ (function (_super) {\n    __extends(MatTabLabel, _super);\n    function MatTabLabel() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    MatTabLabel.decorators = [\n        { type: core.Directive, args: [{\n                    selector: '[mat-tab-label], [matTabLabel]',\n                },] },\n    ];\n    return MatTabLabel;\n}(portal.CdkPortal));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n// Boilerplate for applying mixins to MatTab.\n/**\n * \\@docs-private\n */\nvar   \n// Boilerplate for applying mixins to MatTab.\n/**\n * \\@docs-private\n */\nMatTabBase = /** @class */ (function () {\n    function MatTabBase() {\n    }\n    return MatTabBase;\n}());\n/** @type {?} */\nvar _MatTabMixinBase = core$1.mixinDisabled(MatTabBase);\nvar MatTab = /** @class */ (function (_super) {\n    __extends(MatTab, _super);\n    function MatTab(_viewContainerRef) {\n        var _this = _super.call(this) || this;\n        _this._viewContainerRef = _viewContainerRef;\n        /**\n         * Plain text label for the tab, used when there is no template label.\n         */\n        _this.textLabel = '';\n        /**\n         * Portal that will be the hosted content of the tab\n         */\n        _this._contentPortal = null;\n        /**\n         * Emits whenever the internal state of the tab changes.\n         */\n        _this._stateChanges = new rxjs.Subject();\n        /**\n         * The relatively indexed position where 0 represents the center, negative is left, and positive\n         * represents the right.\n         */\n        _this.position = null;\n        /**\n         * The initial relatively index origin of the tab if it was created and selected after there\n         * was already a selected tab. Provides context of what position the tab should originate from.\n         */\n        _this.origin = null;\n        /**\n         * Whether the tab is currently active.\n         */\n        _this.isActive = false;\n        return _this;\n    }\n    Object.defineProperty(MatTab.prototype, \"content\", {\n        /** @docs-private */\n        get: /**\n         * \\@docs-private\n         * @return {?}\n         */\n        function () {\n            return this._contentPortal;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n    MatTab.prototype.ngOnChanges = /**\n     * @param {?} changes\n     * @return {?}\n     */\n    function (changes) {\n        if (changes.hasOwnProperty('textLabel') || changes.hasOwnProperty('disabled')) {\n            this._stateChanges.next();\n        }\n    };\n    /**\n     * @return {?}\n     */\n    MatTab.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this._stateChanges.complete();\n    };\n    /**\n     * @return {?}\n     */\n    MatTab.prototype.ngOnInit = /**\n     * @return {?}\n     */\n    function () {\n        this._contentPortal = new portal.TemplatePortal(this._explicitContent || this._implicitContent, this._viewContainerRef);\n    };\n    MatTab.decorators = [\n        { type: core.Component, args: [{selector: 'mat-tab',\n                    template: \"<ng-template><ng-content></ng-content></ng-template>\",\n                    inputs: ['disabled'],\n                    changeDetection: core.ChangeDetectionStrategy.OnPush,\n                    encapsulation: core.ViewEncapsulation.None,\n                    exportAs: 'matTab',\n                },] },\n    ];\n    /** @nocollapse */\n    MatTab.ctorParameters = function () { return [\n        { type: core.ViewContainerRef }\n    ]; };\n    MatTab.propDecorators = {\n        templateLabel: [{ type: core.ContentChild, args: [MatTabLabel,] }],\n        _explicitContent: [{ type: core.ContentChild, args: [MatTabContent, { read: core.TemplateRef },] }],\n        _implicitContent: [{ type: core.ViewChild, args: [core.TemplateRef,] }],\n        textLabel: [{ type: core.Input, args: ['label',] }],\n        ariaLabel: [{ type: core.Input, args: ['aria-label',] }],\n        ariaLabelledby: [{ type: core.Input, args: ['aria-labelledby',] }]\n    };\n    return MatTab;\n}(_MatTabMixinBase));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Animations used by the Material tabs.\n * \\@docs-private\n * @type {?}\n */\nvar matTabsAnimations = {\n    /**\n     * Animation translates a tab along the X axis.\n     */\n    translateTab: animations.trigger('translateTab', [\n        // Note: transitions to `none` instead of 0, because some browsers might blur the content.\n        animations.state('center, void, left-origin-center, right-origin-center', animations.style({ transform: 'none' })),\n        // If the tab is either on the left or right, we additionally add a `min-height` of 1px\n        // in order to ensure that the element has a height before its state changes. This is\n        // necessary because Chrome does seem to skip the transition in RTL mode if the element does\n        // not have a static height and is not rendered. See related issue: #9465\n        animations.state('left', animations.style({ transform: 'translate3d(-100%, 0, 0)', minHeight: '1px' })),\n        animations.state('right', animations.style({ transform: 'translate3d(100%, 0, 0)', minHeight: '1px' })),\n        animations.transition('* => left, * => right, left => center, right => center', animations.animate('{{animationDuration}} cubic-bezier(0.35, 0, 0.25, 1)')),\n        animations.transition('void => left-origin-center', [\n            animations.style({ transform: 'translate3d(-100%, 0, 0)' }),\n            animations.animate('{{animationDuration}} cubic-bezier(0.35, 0, 0.25, 1)')\n        ]),\n        animations.transition('void => right-origin-center', [\n            animations.style({ transform: 'translate3d(100%, 0, 0)' }),\n            animations.animate('{{animationDuration}} cubic-bezier(0.35, 0, 0.25, 1)')\n        ])\n    ])\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * The portal host directive for the contents of the tab.\n * \\@docs-private\n */\nvar MatTabBodyPortal = /** @class */ (function (_super) {\n    __extends(MatTabBodyPortal, _super);\n    function MatTabBodyPortal(componentFactoryResolver, viewContainerRef, _host) {\n        var _this = _super.call(this, componentFactoryResolver, viewContainerRef) || this;\n        _this._host = _host;\n        /**\n         * Subscription to events for when the tab body begins centering.\n         */\n        _this._centeringSub = rxjs.Subscription.EMPTY;\n        /**\n         * Subscription to events for when the tab body finishes leaving from center position.\n         */\n        _this._leavingSub = rxjs.Subscription.EMPTY;\n        return _this;\n    }\n    /** Set initial visibility or set up subscription for changing visibility. */\n    /**\n     * Set initial visibility or set up subscription for changing visibility.\n     * @return {?}\n     */\n    MatTabBodyPortal.prototype.ngOnInit = /**\n     * Set initial visibility or set up subscription for changing visibility.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        _super.prototype.ngOnInit.call(this);\n        this._centeringSub = this._host._beforeCentering\n            .pipe(operators.startWith(this._host._isCenterPosition(this._host._position)))\n            .subscribe(function (isCentering) {\n            if (isCentering && !_this.hasAttached()) {\n                _this.attach(_this._host._content);\n            }\n        });\n        this._leavingSub = this._host._afterLeavingCenter.subscribe(function () {\n            _this.detach();\n        });\n    };\n    /** Clean up centering subscription. */\n    /**\n     * Clean up centering subscription.\n     * @return {?}\n     */\n    MatTabBodyPortal.prototype.ngOnDestroy = /**\n     * Clean up centering subscription.\n     * @return {?}\n     */\n    function () {\n        _super.prototype.ngOnDestroy.call(this);\n        this._centeringSub.unsubscribe();\n        this._leavingSub.unsubscribe();\n    };\n    MatTabBodyPortal.decorators = [\n        { type: core.Directive, args: [{\n                    selector: '[matTabBodyHost]'\n                },] },\n    ];\n    /** @nocollapse */\n    MatTabBodyPortal.ctorParameters = function () { return [\n        { type: core.ComponentFactoryResolver },\n        { type: core.ViewContainerRef },\n        { type: MatTabBody, decorators: [{ type: core.Inject, args: [core.forwardRef(function () { return MatTabBody; }),] }] }\n    ]; };\n    return MatTabBodyPortal;\n}(portal.CdkPortalOutlet));\n/**\n * Wrapper for the contents of a tab.\n * \\@docs-private\n */\nvar MatTabBody = /** @class */ (function () {\n    function MatTabBody(_elementRef, _dir, \n    /**\n     * @breaking-change 8.0.0 changeDetectorRef to be made required.\n     */\n    changeDetectorRef) {\n        var _this = this;\n        this._elementRef = _elementRef;\n        this._dir = _dir;\n        /**\n         * Subscription to the directionality change observable.\n         */\n        this._dirChangeSubscription = rxjs.Subscription.EMPTY;\n        /**\n         * Emits when an animation on the tab is complete.\n         */\n        this._translateTabComplete = new rxjs.Subject();\n        /**\n         * Event emitted when the tab begins to animate towards the center as the active tab.\n         */\n        this._onCentering = new core.EventEmitter();\n        /**\n         * Event emitted before the centering of the tab begins.\n         */\n        this._beforeCentering = new core.EventEmitter();\n        /**\n         * Event emitted before the centering of the tab begins.\n         */\n        this._afterLeavingCenter = new core.EventEmitter();\n        /**\n         * Event emitted when the tab completes its animation towards the center.\n         */\n        this._onCentered = new core.EventEmitter(true);\n        // Note that the default value will always be overwritten by `MatTabBody`, but we need one\n        // anyway to prevent the animations module from throwing an error if the body is used on its own.\n        /**\n         * Duration for the tab's animation.\n         */\n        this.animationDuration = '500ms';\n        if (this._dir && changeDetectorRef) {\n            this._dirChangeSubscription = this._dir.change.subscribe(function (dir) {\n                _this._computePositionAnimationState(dir);\n                changeDetectorRef.markForCheck();\n            });\n        }\n        // Ensure that we get unique animation events, because the `.done` callback can get\n        // invoked twice in some browsers. See https://github.com/angular/angular/issues/24084.\n        this._translateTabComplete.pipe(operators.distinctUntilChanged(function (x, y) {\n            return x.fromState === y.fromState && x.toState === y.toState;\n        })).subscribe(function (event) {\n            // If the transition to the center is complete, emit an event.\n            if (_this._isCenterPosition(event.toState) && _this._isCenterPosition(_this._position)) {\n                _this._onCentered.emit();\n            }\n            if (_this._isCenterPosition(event.fromState) && !_this._isCenterPosition(_this._position)) {\n                _this._afterLeavingCenter.emit();\n            }\n        });\n    }\n    Object.defineProperty(MatTabBody.prototype, \"position\", {\n        /** The shifted index position of the tab body, where zero represents the active center tab. */\n        set: /**\n         * The shifted index position of the tab body, where zero represents the active center tab.\n         * @param {?} position\n         * @return {?}\n         */\n        function (position) {\n            this._positionIndex = position;\n            this._computePositionAnimationState();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * After initialized, check if the content is centered and has an origin. If so, set the\n     * special position states that transition the tab from the left or right before centering.\n     */\n    /**\n     * After initialized, check if the content is centered and has an origin. If so, set the\n     * special position states that transition the tab from the left or right before centering.\n     * @return {?}\n     */\n    MatTabBody.prototype.ngOnInit = /**\n     * After initialized, check if the content is centered and has an origin. If so, set the\n     * special position states that transition the tab from the left or right before centering.\n     * @return {?}\n     */\n    function () {\n        if (this._position == 'center' && this.origin != null) {\n            this._position = this._computePositionFromOrigin();\n        }\n    };\n    /**\n     * @return {?}\n     */\n    MatTabBody.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this._dirChangeSubscription.unsubscribe();\n        this._translateTabComplete.complete();\n    };\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n    MatTabBody.prototype._onTranslateTabStarted = /**\n     * @param {?} event\n     * @return {?}\n     */\n    function (event) {\n        /** @type {?} */\n        var isCentering = this._isCenterPosition(event.toState);\n        this._beforeCentering.emit(isCentering);\n        if (isCentering) {\n            this._onCentering.emit(this._elementRef.nativeElement.clientHeight);\n        }\n    };\n    /** The text direction of the containing app. */\n    /**\n     * The text direction of the containing app.\n     * @return {?}\n     */\n    MatTabBody.prototype._getLayoutDirection = /**\n     * The text direction of the containing app.\n     * @return {?}\n     */\n    function () {\n        return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';\n    };\n    /** Whether the provided position state is considered center, regardless of origin. */\n    /**\n     * Whether the provided position state is considered center, regardless of origin.\n     * @param {?} position\n     * @return {?}\n     */\n    MatTabBody.prototype._isCenterPosition = /**\n     * Whether the provided position state is considered center, regardless of origin.\n     * @param {?} position\n     * @return {?}\n     */\n    function (position) {\n        return position == 'center' ||\n            position == 'left-origin-center' ||\n            position == 'right-origin-center';\n    };\n    /** Computes the position state that will be used for the tab-body animation trigger. */\n    /**\n     * Computes the position state that will be used for the tab-body animation trigger.\n     * @private\n     * @param {?=} dir\n     * @return {?}\n     */\n    MatTabBody.prototype._computePositionAnimationState = /**\n     * Computes the position state that will be used for the tab-body animation trigger.\n     * @private\n     * @param {?=} dir\n     * @return {?}\n     */\n    function (dir) {\n        if (dir === void 0) { dir = this._getLayoutDirection(); }\n        if (this._positionIndex < 0) {\n            this._position = dir == 'ltr' ? 'left' : 'right';\n        }\n        else if (this._positionIndex > 0) {\n            this._position = dir == 'ltr' ? 'right' : 'left';\n        }\n        else {\n            this._position = 'center';\n        }\n    };\n    /**\n     * Computes the position state based on the specified origin position. This is used if the\n     * tab is becoming visible immediately after creation.\n     */\n    /**\n     * Computes the position state based on the specified origin position. This is used if the\n     * tab is becoming visible immediately after creation.\n     * @private\n     * @return {?}\n     */\n    MatTabBody.prototype._computePositionFromOrigin = /**\n     * Computes the position state based on the specified origin position. This is used if the\n     * tab is becoming visible immediately after creation.\n     * @private\n     * @return {?}\n     */\n    function () {\n        /** @type {?} */\n        var dir = this._getLayoutDirection();\n        if ((dir == 'ltr' && this.origin <= 0) || (dir == 'rtl' && this.origin > 0)) {\n            return 'left-origin-center';\n        }\n        return 'right-origin-center';\n    };\n    MatTabBody.decorators = [\n        { type: core.Component, args: [{selector: 'mat-tab-body',\n                    template: \"<div class=\\\"mat-tab-body-content\\\" #content [@translateTab]=\\\"{ value: _position, params: {animationDuration: animationDuration} }\\\" (@translateTab.start)=\\\"_onTranslateTabStarted($event)\\\" (@translateTab.done)=\\\"_translateTabComplete.next($event)\\\"><ng-template matTabBodyHost></ng-template></div>\",\n                    styles: [\".mat-tab-body-content{height:100%;overflow:auto}.mat-tab-group-dynamic-height .mat-tab-body-content{overflow:hidden}\"],\n                    encapsulation: core.ViewEncapsulation.None,\n                    changeDetection: core.ChangeDetectionStrategy.OnPush,\n                    animations: [matTabsAnimations.translateTab],\n                    host: {\n                        'class': 'mat-tab-body',\n                    },\n                },] },\n    ];\n    /** @nocollapse */\n    MatTabBody.ctorParameters = function () { return [\n        { type: core.ElementRef },\n        { type: bidi.Directionality, decorators: [{ type: core.Optional }] },\n        { type: core.ChangeDetectorRef }\n    ]; };\n    MatTabBody.propDecorators = {\n        _onCentering: [{ type: core.Output }],\n        _beforeCentering: [{ type: core.Output }],\n        _afterLeavingCenter: [{ type: core.Output }],\n        _onCentered: [{ type: core.Output }],\n        _portalHost: [{ type: core.ViewChild, args: [portal.PortalHostDirective,] }],\n        _content: [{ type: core.Input, args: ['content',] }],\n        origin: [{ type: core.Input }],\n        animationDuration: [{ type: core.Input }],\n        position: [{ type: core.Input }]\n    };\n    return MatTabBody;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n// Boilerplate for applying mixins to MatTabLabelWrapper.\n/**\n * \\@docs-private\n */\nvar   \n// Boilerplate for applying mixins to MatTabLabelWrapper.\n/**\n * \\@docs-private\n */\nMatTabLabelWrapperBase = /** @class */ (function () {\n    function MatTabLabelWrapperBase() {\n    }\n    return MatTabLabelWrapperBase;\n}());\n/** @type {?} */\nvar _MatTabLabelWrapperMixinBase = core$1.mixinDisabled(MatTabLabelWrapperBase);\n/**\n * Used in the `mat-tab-group` view to display tab labels.\n * \\@docs-private\n */\nvar MatTabLabelWrapper = /** @class */ (function (_super) {\n    __extends(MatTabLabelWrapper, _super);\n    function MatTabLabelWrapper(elementRef) {\n        var _this = _super.call(this) || this;\n        _this.elementRef = elementRef;\n        return _this;\n    }\n    /** Sets focus on the wrapper element */\n    /**\n     * Sets focus on the wrapper element\n     * @return {?}\n     */\n    MatTabLabelWrapper.prototype.focus = /**\n     * Sets focus on the wrapper element\n     * @return {?}\n     */\n    function () {\n        this.elementRef.nativeElement.focus();\n    };\n    /**\n     * @return {?}\n     */\n    MatTabLabelWrapper.prototype.getOffsetLeft = /**\n     * @return {?}\n     */\n    function () {\n        return this.elementRef.nativeElement.offsetLeft;\n    };\n    /**\n     * @return {?}\n     */\n    MatTabLabelWrapper.prototype.getOffsetWidth = /**\n     * @return {?}\n     */\n    function () {\n        return this.elementRef.nativeElement.offsetWidth;\n    };\n    MatTabLabelWrapper.decorators = [\n        { type: core.Directive, args: [{\n                    selector: '[matTabLabelWrapper]',\n                    inputs: ['disabled'],\n                    host: {\n                        '[class.mat-tab-disabled]': 'disabled',\n                        '[attr.aria-disabled]': '!!disabled',\n                    }\n                },] },\n    ];\n    /** @nocollapse */\n    MatTabLabelWrapper.ctorParameters = function () { return [\n        { type: core.ElementRef }\n    ]; };\n    return MatTabLabelWrapper;\n}(_MatTabLabelWrapperMixinBase));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Config used to bind passive event listeners\n * @type {?}\n */\nvar passiveEventListenerOptions = (/** @type {?} */ (platform.normalizePassiveListenerOptions({ passive: true })));\n/**\n * The distance in pixels that will be overshot when scrolling a tab label into view. This helps\n * provide a small affordance to the label next to it.\n * @type {?}\n */\nvar EXAGGERATED_OVERSCROLL = 60;\n/**\n * Amount of milliseconds to wait before starting to scroll the header automatically.\n * Set a little conservatively in order to handle fake events dispatched on touch devices.\n * @type {?}\n */\nvar HEADER_SCROLL_DELAY = 650;\n/**\n * Interval in milliseconds at which to scroll the header\n * while the user is holding their pointer.\n * @type {?}\n */\nvar HEADER_SCROLL_INTERVAL = 100;\n// Boilerplate for applying mixins to MatTabHeader.\n/**\n * \\@docs-private\n */\nvar   \n// Boilerplate for applying mixins to MatTabHeader.\n/**\n * \\@docs-private\n */\nMatTabHeaderBase = /** @class */ (function () {\n    function MatTabHeaderBase() {\n    }\n    return MatTabHeaderBase;\n}());\n/** @type {?} */\nvar _MatTabHeaderMixinBase = core$1.mixinDisableRipple(MatTabHeaderBase);\n/**\n * The header of the tab group which displays a list of all the tabs in the tab group. Includes\n * an ink bar that follows the currently selected tab. When the tabs list's width exceeds the\n * width of the header container, then arrows will be displayed to allow the user to scroll\n * left and right across the header.\n * \\@docs-private\n */\nvar MatTabHeader = /** @class */ (function (_super) {\n    __extends(MatTabHeader, _super);\n    function MatTabHeader(_elementRef, _changeDetectorRef, _viewportRuler, _dir, _ngZone, _platform) {\n        var _this = _super.call(this) || this;\n        _this._elementRef = _elementRef;\n        _this._changeDetectorRef = _changeDetectorRef;\n        _this._viewportRuler = _viewportRuler;\n        _this._dir = _dir;\n        _this._ngZone = _ngZone;\n        _this._platform = _platform;\n        /**\n         * The distance in pixels that the tab labels should be translated to the left.\n         */\n        _this._scrollDistance = 0;\n        /**\n         * Whether the header should scroll to the selected index after the view has been checked.\n         */\n        _this._selectedIndexChanged = false;\n        /**\n         * Emits when the component is destroyed.\n         */\n        _this._destroyed = new rxjs.Subject();\n        /**\n         * Whether the controls for pagination should be displayed\n         */\n        _this._showPaginationControls = false;\n        /**\n         * Whether the tab list can be scrolled more towards the end of the tab label list.\n         */\n        _this._disableScrollAfter = true;\n        /**\n         * Whether the tab list can be scrolled more towards the beginning of the tab label list.\n         */\n        _this._disableScrollBefore = true;\n        /**\n         * Stream that will stop the automated scrolling.\n         */\n        _this._stopScrolling = new rxjs.Subject();\n        _this._selectedIndex = 0;\n        /**\n         * Event emitted when the option is selected.\n         */\n        _this.selectFocusedIndex = new core.EventEmitter();\n        /**\n         * Event emitted when a label is focused.\n         */\n        _this.indexFocused = new core.EventEmitter();\n        /** @type {?} */\n        var element = _elementRef.nativeElement;\n        /** @type {?} */\n        var bindEvent = function () {\n            rxjs.fromEvent(element, 'mouseleave')\n                .pipe(operators.takeUntil(_this._destroyed))\n                .subscribe(function () {\n                _this._stopInterval();\n            });\n        };\n        // @breaking-change 8.0.0 remove null check once _ngZone is made into a required parameter.\n        if (_ngZone) {\n            // Bind the `mouseleave` event on the outside since it doesn't change anything in the view.\n            _ngZone.runOutsideAngular(bindEvent);\n        }\n        else {\n            bindEvent();\n        }\n        return _this;\n    }\n    Object.defineProperty(MatTabHeader.prototype, \"selectedIndex\", {\n        /** The index of the active tab. */\n        get: /**\n         * The index of the active tab.\n         * @return {?}\n         */\n        function () { return this._selectedIndex; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) {\n            value = coercion.coerceNumberProperty(value);\n            this._selectedIndexChanged = this._selectedIndex != value;\n            this._selectedIndex = value;\n            if (this._keyManager) {\n                this._keyManager.updateActiveItemIndex(value);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    MatTabHeader.prototype.ngAfterContentChecked = /**\n     * @return {?}\n     */\n    function () {\n        // If the number of tab labels have changed, check if scrolling should be enabled\n        if (this._tabLabelCount != this._labelWrappers.length) {\n            this.updatePagination();\n            this._tabLabelCount = this._labelWrappers.length;\n            this._changeDetectorRef.markForCheck();\n        }\n        // If the selected index has changed, scroll to the label and check if the scrolling controls\n        // should be disabled.\n        if (this._selectedIndexChanged) {\n            this._scrollToLabel(this._selectedIndex);\n            this._checkScrollingControls();\n            this._alignInkBarToSelectedTab();\n            this._selectedIndexChanged = false;\n            this._changeDetectorRef.markForCheck();\n        }\n        // If the scroll distance has been changed (tab selected, focused, scroll controls activated),\n        // then translate the header to reflect this.\n        if (this._scrollDistanceChanged) {\n            this._updateTabScrollPosition();\n            this._scrollDistanceChanged = false;\n            this._changeDetectorRef.markForCheck();\n        }\n    };\n    /** Handles keyboard events on the header. */\n    /**\n     * Handles keyboard events on the header.\n     * @param {?} event\n     * @return {?}\n     */\n    MatTabHeader.prototype._handleKeydown = /**\n     * Handles keyboard events on the header.\n     * @param {?} event\n     * @return {?}\n     */\n    function (event) {\n        // We don't handle any key bindings with a modifier key.\n        if (keycodes.hasModifierKey(event)) {\n            return;\n        }\n        switch (event.keyCode) {\n            case keycodes.HOME:\n                this._keyManager.setFirstItemActive();\n                event.preventDefault();\n                break;\n            case keycodes.END:\n                this._keyManager.setLastItemActive();\n                event.preventDefault();\n                break;\n            case keycodes.ENTER:\n            case keycodes.SPACE:\n                this.selectFocusedIndex.emit(this.focusIndex);\n                event.preventDefault();\n                break;\n            default:\n                this._keyManager.onKeydown(event);\n        }\n    };\n    /**\n     * Aligns the ink bar to the selected tab on load.\n     */\n    /**\n     * Aligns the ink bar to the selected tab on load.\n     * @return {?}\n     */\n    MatTabHeader.prototype.ngAfterContentInit = /**\n     * Aligns the ink bar to the selected tab on load.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        /** @type {?} */\n        var dirChange = this._dir ? this._dir.change : rxjs.of(null);\n        /** @type {?} */\n        var resize = this._viewportRuler.change(150);\n        /** @type {?} */\n        var realign = function () {\n            _this.updatePagination();\n            _this._alignInkBarToSelectedTab();\n        };\n        this._keyManager = new a11y.FocusKeyManager(this._labelWrappers)\n            .withHorizontalOrientation(this._getLayoutDirection())\n            .withWrap();\n        this._keyManager.updateActiveItem(0);\n        // Defer the first call in order to allow for slower browsers to lay out the elements.\n        // This helps in cases where the user lands directly on a page with paginated tabs.\n        typeof requestAnimationFrame !== 'undefined' ? requestAnimationFrame(realign) : realign();\n        // On dir change or window resize, realign the ink bar and update the orientation of\n        // the key manager if the direction has changed.\n        rxjs.merge(dirChange, resize).pipe(operators.takeUntil(this._destroyed)).subscribe(function () {\n            realign();\n            _this._keyManager.withHorizontalOrientation(_this._getLayoutDirection());\n        });\n        // If there is a change in the focus key manager we need to emit the `indexFocused`\n        // event in order to provide a public event that notifies about focus changes. Also we realign\n        // the tabs container by scrolling the new focused tab into the visible section.\n        this._keyManager.change.pipe(operators.takeUntil(this._destroyed)).subscribe(function (newFocusIndex) {\n            _this.indexFocused.emit(newFocusIndex);\n            _this._setTabFocus(newFocusIndex);\n        });\n    };\n    /**\n     * @return {?}\n     */\n    MatTabHeader.prototype.ngAfterViewInit = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        // We need to handle these events manually, because we want to bind passive event listeners.\n        rxjs.fromEvent(this._previousPaginator.nativeElement, 'touchstart', passiveEventListenerOptions)\n            .pipe(operators.takeUntil(this._destroyed))\n            .subscribe(function () {\n            _this._handlePaginatorPress('before');\n        });\n        rxjs.fromEvent(this._nextPaginator.nativeElement, 'touchstart', passiveEventListenerOptions)\n            .pipe(operators.takeUntil(this._destroyed))\n            .subscribe(function () {\n            _this._handlePaginatorPress('after');\n        });\n    };\n    /**\n     * @return {?}\n     */\n    MatTabHeader.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this._destroyed.next();\n        this._destroyed.complete();\n        this._stopScrolling.complete();\n    };\n    /**\n     * Callback for when the MutationObserver detects that the content has changed.\n     */\n    /**\n     * Callback for when the MutationObserver detects that the content has changed.\n     * @return {?}\n     */\n    MatTabHeader.prototype._onContentChanges = /**\n     * Callback for when the MutationObserver detects that the content has changed.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        /** @type {?} */\n        var textContent = this._elementRef.nativeElement.textContent;\n        // We need to diff the text content of the header, because the MutationObserver callback\n        // will fire even if the text content didn't change which is inefficient and is prone\n        // to infinite loops if a poorly constructed expression is passed in (see #14249).\n        if (textContent !== this._currentTextContent) {\n            this._currentTextContent = textContent;\n            /** @type {?} */\n            var zoneCallback = function () {\n                _this.updatePagination();\n                _this._alignInkBarToSelectedTab();\n                _this._changeDetectorRef.markForCheck();\n            };\n            // The content observer runs outside the `NgZone` by default, which\n            // means that we need to bring the callback back in ourselves.\n            // @breaking-change 8.0.0 Remove null check for `_ngZone` once it's a required parameter.\n            this._ngZone ? this._ngZone.run(zoneCallback) : zoneCallback();\n        }\n    };\n    /**\n     * Updates the view whether pagination should be enabled or not.\n     *\n     * WARNING: Calling this method can be very costly in terms of performance.  It should be called\n     * as infrequently as possible from outside of the Tabs component as it causes a reflow of the\n     * page.\n     */\n    /**\n     * Updates the view whether pagination should be enabled or not.\n     *\n     * WARNING: Calling this method can be very costly in terms of performance.  It should be called\n     * as infrequently as possible from outside of the Tabs component as it causes a reflow of the\n     * page.\n     * @return {?}\n     */\n    MatTabHeader.prototype.updatePagination = /**\n     * Updates the view whether pagination should be enabled or not.\n     *\n     * WARNING: Calling this method can be very costly in terms of performance.  It should be called\n     * as infrequently as possible from outside of the Tabs component as it causes a reflow of the\n     * page.\n     * @return {?}\n     */\n    function () {\n        this._checkPaginationEnabled();\n        this._checkScrollingControls();\n        this._updateTabScrollPosition();\n    };\n    Object.defineProperty(MatTabHeader.prototype, \"focusIndex\", {\n        /** Tracks which element has focus; used for keyboard navigation */\n        get: /**\n         * Tracks which element has focus; used for keyboard navigation\n         * @return {?}\n         */\n        function () {\n            return this._keyManager ? (/** @type {?} */ (this._keyManager.activeItemIndex)) : 0;\n        },\n        /** When the focus index is set, we must manually send focus to the correct label */\n        set: /**\n         * When the focus index is set, we must manually send focus to the correct label\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) {\n            if (!this._isValidIndex(value) || this.focusIndex === value || !this._keyManager) {\n                return;\n            }\n            this._keyManager.setActiveItem(value);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Determines if an index is valid.  If the tabs are not ready yet, we assume that the user is\n     * providing a valid index and return true.\n     */\n    /**\n     * Determines if an index is valid.  If the tabs are not ready yet, we assume that the user is\n     * providing a valid index and return true.\n     * @param {?} index\n     * @return {?}\n     */\n    MatTabHeader.prototype._isValidIndex = /**\n     * Determines if an index is valid.  If the tabs are not ready yet, we assume that the user is\n     * providing a valid index and return true.\n     * @param {?} index\n     * @return {?}\n     */\n    function (index) {\n        if (!this._labelWrappers) {\n            return true;\n        }\n        /** @type {?} */\n        var tab = this._labelWrappers ? this._labelWrappers.toArray()[index] : null;\n        return !!tab && !tab.disabled;\n    };\n    /**\n     * Sets focus on the HTML element for the label wrapper and scrolls it into the view if\n     * scrolling is enabled.\n     */\n    /**\n     * Sets focus on the HTML element for the label wrapper and scrolls it into the view if\n     * scrolling is enabled.\n     * @param {?} tabIndex\n     * @return {?}\n     */\n    MatTabHeader.prototype._setTabFocus = /**\n     * Sets focus on the HTML element for the label wrapper and scrolls it into the view if\n     * scrolling is enabled.\n     * @param {?} tabIndex\n     * @return {?}\n     */\n    function (tabIndex) {\n        if (this._showPaginationControls) {\n            this._scrollToLabel(tabIndex);\n        }\n        if (this._labelWrappers && this._labelWrappers.length) {\n            this._labelWrappers.toArray()[tabIndex].focus();\n            // Do not let the browser manage scrolling to focus the element, this will be handled\n            // by using translation. In LTR, the scroll left should be 0. In RTL, the scroll width\n            // should be the full width minus the offset width.\n            /** @type {?} */\n            var containerEl = this._tabListContainer.nativeElement;\n            /** @type {?} */\n            var dir = this._getLayoutDirection();\n            if (dir == 'ltr') {\n                containerEl.scrollLeft = 0;\n            }\n            else {\n                containerEl.scrollLeft = containerEl.scrollWidth - containerEl.offsetWidth;\n            }\n        }\n    };\n    /** The layout direction of the containing app. */\n    /**\n     * The layout direction of the containing app.\n     * @return {?}\n     */\n    MatTabHeader.prototype._getLayoutDirection = /**\n     * The layout direction of the containing app.\n     * @return {?}\n     */\n    function () {\n        return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';\n    };\n    /** Performs the CSS transformation on the tab list that will cause the list to scroll. */\n    /**\n     * Performs the CSS transformation on the tab list that will cause the list to scroll.\n     * @return {?}\n     */\n    MatTabHeader.prototype._updateTabScrollPosition = /**\n     * Performs the CSS transformation on the tab list that will cause the list to scroll.\n     * @return {?}\n     */\n    function () {\n        /** @type {?} */\n        var scrollDistance = this.scrollDistance;\n        /** @type {?} */\n        var platform$$1 = this._platform;\n        /** @type {?} */\n        var translateX = this._getLayoutDirection() === 'ltr' ? -scrollDistance : scrollDistance;\n        // Don't use `translate3d` here because we don't want to create a new layer. A new layer\n        // seems to cause flickering and overflow in Internet Explorer. For example, the ink bar\n        // and ripples will exceed the boundaries of the visible tab bar.\n        // See: https://github.com/angular/material2/issues/10276\n        // We round the `transform` here, because transforms with sub-pixel precision cause some\n        // browsers to blur the content of the element.\n        this._tabList.nativeElement.style.transform = \"translateX(\" + Math.round(translateX) + \"px)\";\n        // Setting the `transform` on IE will change the scroll offset of the parent, causing the\n        // position to be thrown off in some cases. We have to reset it ourselves to ensure that\n        // it doesn't get thrown off. Note that we scope it only to IE and Edge, because messing\n        // with the scroll position throws off Chrome 71+ in RTL mode (see #14689).\n        // @breaking-change 8.0.0 Remove null check for `platform`.\n        if (platform$$1 && (platform$$1.TRIDENT || platform$$1.EDGE)) {\n            this._tabListContainer.nativeElement.scrollLeft = 0;\n        }\n    };\n    Object.defineProperty(MatTabHeader.prototype, \"scrollDistance\", {\n        /** Sets the distance in pixels that the tab header should be transformed in the X-axis. */\n        get: /**\n         * Sets the distance in pixels that the tab header should be transformed in the X-axis.\n         * @return {?}\n         */\n        function () { return this._scrollDistance; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) {\n            this._scrollTo(value);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Moves the tab list in the 'before' or 'after' direction (towards the beginning of the list or\n     * the end of the list, respectively). The distance to scroll is computed to be a third of the\n     * length of the tab list view window.\n     *\n     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n     * should be called sparingly.\n     */\n    /**\n     * Moves the tab list in the 'before' or 'after' direction (towards the beginning of the list or\n     * the end of the list, respectively). The distance to scroll is computed to be a third of the\n     * length of the tab list view window.\n     *\n     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n     * should be called sparingly.\n     * @param {?} direction\n     * @return {?}\n     */\n    MatTabHeader.prototype._scrollHeader = /**\n     * Moves the tab list in the 'before' or 'after' direction (towards the beginning of the list or\n     * the end of the list, respectively). The distance to scroll is computed to be a third of the\n     * length of the tab list view window.\n     *\n     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n     * should be called sparingly.\n     * @param {?} direction\n     * @return {?}\n     */\n    function (direction) {\n        /** @type {?} */\n        var viewLength = this._tabListContainer.nativeElement.offsetWidth;\n        // Move the scroll distance one-third the length of the tab list's viewport.\n        /** @type {?} */\n        var scrollAmount = (direction == 'before' ? -1 : 1) * viewLength / 3;\n        return this._scrollTo(this._scrollDistance + scrollAmount);\n    };\n    /** Handles click events on the pagination arrows. */\n    /**\n     * Handles click events on the pagination arrows.\n     * @param {?} direction\n     * @return {?}\n     */\n    MatTabHeader.prototype._handlePaginatorClick = /**\n     * Handles click events on the pagination arrows.\n     * @param {?} direction\n     * @return {?}\n     */\n    function (direction) {\n        this._stopInterval();\n        this._scrollHeader(direction);\n    };\n    /**\n     * Moves the tab list such that the desired tab label (marked by index) is moved into view.\n     *\n     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n     * should be called sparingly.\n     */\n    /**\n     * Moves the tab list such that the desired tab label (marked by index) is moved into view.\n     *\n     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n     * should be called sparingly.\n     * @param {?} labelIndex\n     * @return {?}\n     */\n    MatTabHeader.prototype._scrollToLabel = /**\n     * Moves the tab list such that the desired tab label (marked by index) is moved into view.\n     *\n     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n     * should be called sparingly.\n     * @param {?} labelIndex\n     * @return {?}\n     */\n    function (labelIndex) {\n        /** @type {?} */\n        var selectedLabel = this._labelWrappers ? this._labelWrappers.toArray()[labelIndex] : null;\n        if (!selectedLabel) {\n            return;\n        }\n        // The view length is the visible width of the tab labels.\n        /** @type {?} */\n        var viewLength = this._tabListContainer.nativeElement.offsetWidth;\n        /** @type {?} */\n        var labelBeforePos;\n        /** @type {?} */\n        var labelAfterPos;\n        if (this._getLayoutDirection() == 'ltr') {\n            labelBeforePos = selectedLabel.getOffsetLeft();\n            labelAfterPos = labelBeforePos + selectedLabel.getOffsetWidth();\n        }\n        else {\n            labelAfterPos = this._tabList.nativeElement.offsetWidth - selectedLabel.getOffsetLeft();\n            labelBeforePos = labelAfterPos - selectedLabel.getOffsetWidth();\n        }\n        /** @type {?} */\n        var beforeVisiblePos = this.scrollDistance;\n        /** @type {?} */\n        var afterVisiblePos = this.scrollDistance + viewLength;\n        if (labelBeforePos < beforeVisiblePos) {\n            // Scroll header to move label to the before direction\n            this.scrollDistance -= beforeVisiblePos - labelBeforePos + EXAGGERATED_OVERSCROLL;\n        }\n        else if (labelAfterPos > afterVisiblePos) {\n            // Scroll header to move label to the after direction\n            this.scrollDistance += labelAfterPos - afterVisiblePos + EXAGGERATED_OVERSCROLL;\n        }\n    };\n    /**\n     * Evaluate whether the pagination controls should be displayed. If the scroll width of the\n     * tab list is wider than the size of the header container, then the pagination controls should\n     * be shown.\n     *\n     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n     * should be called sparingly.\n     */\n    /**\n     * Evaluate whether the pagination controls should be displayed. If the scroll width of the\n     * tab list is wider than the size of the header container, then the pagination controls should\n     * be shown.\n     *\n     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n     * should be called sparingly.\n     * @return {?}\n     */\n    MatTabHeader.prototype._checkPaginationEnabled = /**\n     * Evaluate whether the pagination controls should be displayed. If the scroll width of the\n     * tab list is wider than the size of the header container, then the pagination controls should\n     * be shown.\n     *\n     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n     * should be called sparingly.\n     * @return {?}\n     */\n    function () {\n        /** @type {?} */\n        var isEnabled = this._tabList.nativeElement.scrollWidth > this._elementRef.nativeElement.offsetWidth;\n        if (!isEnabled) {\n            this.scrollDistance = 0;\n        }\n        if (isEnabled !== this._showPaginationControls) {\n            this._changeDetectorRef.markForCheck();\n        }\n        this._showPaginationControls = isEnabled;\n    };\n    /**\n     * Evaluate whether the before and after controls should be enabled or disabled.\n     * If the header is at the beginning of the list (scroll distance is equal to 0) then disable the\n     * before button. If the header is at the end of the list (scroll distance is equal to the\n     * maximum distance we can scroll), then disable the after button.\n     *\n     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n     * should be called sparingly.\n     */\n    /**\n     * Evaluate whether the before and after controls should be enabled or disabled.\n     * If the header is at the beginning of the list (scroll distance is equal to 0) then disable the\n     * before button. If the header is at the end of the list (scroll distance is equal to the\n     * maximum distance we can scroll), then disable the after button.\n     *\n     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n     * should be called sparingly.\n     * @return {?}\n     */\n    MatTabHeader.prototype._checkScrollingControls = /**\n     * Evaluate whether the before and after controls should be enabled or disabled.\n     * If the header is at the beginning of the list (scroll distance is equal to 0) then disable the\n     * before button. If the header is at the end of the list (scroll distance is equal to the\n     * maximum distance we can scroll), then disable the after button.\n     *\n     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n     * should be called sparingly.\n     * @return {?}\n     */\n    function () {\n        // Check if the pagination arrows should be activated.\n        this._disableScrollBefore = this.scrollDistance == 0;\n        this._disableScrollAfter = this.scrollDistance == this._getMaxScrollDistance();\n        this._changeDetectorRef.markForCheck();\n    };\n    /**\n     * Determines what is the maximum length in pixels that can be set for the scroll distance. This\n     * is equal to the difference in width between the tab list container and tab header container.\n     *\n     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n     * should be called sparingly.\n     */\n    /**\n     * Determines what is the maximum length in pixels that can be set for the scroll distance. This\n     * is equal to the difference in width between the tab list container and tab header container.\n     *\n     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n     * should be called sparingly.\n     * @return {?}\n     */\n    MatTabHeader.prototype._getMaxScrollDistance = /**\n     * Determines what is the maximum length in pixels that can be set for the scroll distance. This\n     * is equal to the difference in width between the tab list container and tab header container.\n     *\n     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n     * should be called sparingly.\n     * @return {?}\n     */\n    function () {\n        /** @type {?} */\n        var lengthOfTabList = this._tabList.nativeElement.scrollWidth;\n        /** @type {?} */\n        var viewLength = this._tabListContainer.nativeElement.offsetWidth;\n        return (lengthOfTabList - viewLength) || 0;\n    };\n    /** Tells the ink-bar to align itself to the current label wrapper */\n    /**\n     * Tells the ink-bar to align itself to the current label wrapper\n     * @return {?}\n     */\n    MatTabHeader.prototype._alignInkBarToSelectedTab = /**\n     * Tells the ink-bar to align itself to the current label wrapper\n     * @return {?}\n     */\n    function () {\n        /** @type {?} */\n        var selectedLabelWrapper = this._labelWrappers && this._labelWrappers.length ?\n            this._labelWrappers.toArray()[this.selectedIndex].elementRef.nativeElement :\n            null;\n        this._inkBar.alignToElement((/** @type {?} */ (selectedLabelWrapper)));\n    };\n    /** Stops the currently-running paginator interval.  */\n    /**\n     * Stops the currently-running paginator interval.\n     * @return {?}\n     */\n    MatTabHeader.prototype._stopInterval = /**\n     * Stops the currently-running paginator interval.\n     * @return {?}\n     */\n    function () {\n        this._stopScrolling.next();\n    };\n    /**\n     * Handles the user pressing down on one of the paginators.\n     * Starts scrolling the header after a certain amount of time.\n     * @param direction In which direction the paginator should be scrolled.\n     */\n    /**\n     * Handles the user pressing down on one of the paginators.\n     * Starts scrolling the header after a certain amount of time.\n     * @param {?} direction In which direction the paginator should be scrolled.\n     * @return {?}\n     */\n    MatTabHeader.prototype._handlePaginatorPress = /**\n     * Handles the user pressing down on one of the paginators.\n     * Starts scrolling the header after a certain amount of time.\n     * @param {?} direction In which direction the paginator should be scrolled.\n     * @return {?}\n     */\n    function (direction) {\n        var _this = this;\n        // Avoid overlapping timers.\n        this._stopInterval();\n        // Start a timer after the delay and keep firing based on the interval.\n        rxjs.timer(HEADER_SCROLL_DELAY, HEADER_SCROLL_INTERVAL)\n            // Keep the timer going until something tells it to stop or the component is destroyed.\n            .pipe(operators.takeUntil(rxjs.merge(this._stopScrolling, this._destroyed)))\n            .subscribe(function () {\n            var _a = _this._scrollHeader(direction), maxScrollDistance = _a.maxScrollDistance, distance = _a.distance;\n            // Stop the timer if we've reached the start or the end.\n            if (distance === 0 || distance >= maxScrollDistance) {\n                _this._stopInterval();\n            }\n        });\n    };\n    /**\n     * Scrolls the header to a given position.\n     * @param position Position to which to scroll.\n     * @returns Information on the current scroll distance and the maximum.\n     */\n    /**\n     * Scrolls the header to a given position.\n     * @private\n     * @param {?} position Position to which to scroll.\n     * @return {?} Information on the current scroll distance and the maximum.\n     */\n    MatTabHeader.prototype._scrollTo = /**\n     * Scrolls the header to a given position.\n     * @private\n     * @param {?} position Position to which to scroll.\n     * @return {?} Information on the current scroll distance and the maximum.\n     */\n    function (position) {\n        /** @type {?} */\n        var maxScrollDistance = this._getMaxScrollDistance();\n        this._scrollDistance = Math.max(0, Math.min(maxScrollDistance, position));\n        // Mark that the scroll distance has changed so that after the view is checked, the CSS\n        // transformation can move the header.\n        this._scrollDistanceChanged = true;\n        this._checkScrollingControls();\n        return { maxScrollDistance: maxScrollDistance, distance: this._scrollDistance };\n    };\n    MatTabHeader.decorators = [\n        { type: core.Component, args: [{selector: 'mat-tab-header',\n                    template: \"<div class=\\\"mat-tab-header-pagination mat-tab-header-pagination-before mat-elevation-z4\\\" #previousPaginator aria-hidden=\\\"true\\\" mat-ripple [matRippleDisabled]=\\\"_disableScrollBefore || disableRipple\\\" [class.mat-tab-header-pagination-disabled]=\\\"_disableScrollBefore\\\" (click)=\\\"_handlePaginatorClick('before')\\\" (mousedown)=\\\"_handlePaginatorPress('before')\\\" (touchend)=\\\"_stopInterval()\\\"><div class=\\\"mat-tab-header-pagination-chevron\\\"></div></div><div class=\\\"mat-tab-label-container\\\" #tabListContainer (keydown)=\\\"_handleKeydown($event)\\\"><div class=\\\"mat-tab-list\\\" #tabList role=\\\"tablist\\\" (cdkObserveContent)=\\\"_onContentChanges()\\\"><div class=\\\"mat-tab-labels\\\"><ng-content></ng-content></div><mat-ink-bar></mat-ink-bar></div></div><div class=\\\"mat-tab-header-pagination mat-tab-header-pagination-after mat-elevation-z4\\\" #nextPaginator aria-hidden=\\\"true\\\" mat-ripple [matRippleDisabled]=\\\"_disableScrollAfter || disableRipple\\\" [class.mat-tab-header-pagination-disabled]=\\\"_disableScrollAfter\\\" (mousedown)=\\\"_handlePaginatorPress('after')\\\" (click)=\\\"_handlePaginatorClick('after')\\\" (touchend)=\\\"_stopInterval()\\\"><div class=\\\"mat-tab-header-pagination-chevron\\\"></div></div>\",\n                    styles: [\".mat-tab-header{display:flex;overflow:hidden;position:relative;flex-shrink:0}.mat-tab-label{height:48px;padding:0 24px;cursor:pointer;box-sizing:border-box;opacity:.6;min-width:160px;text-align:center;display:inline-flex;justify-content:center;align-items:center;white-space:nowrap;position:relative}.mat-tab-label:focus{outline:0}.mat-tab-label:focus:not(.mat-tab-disabled){opacity:1}@media (-ms-high-contrast:active){.mat-tab-label:focus{outline:dotted 2px}}.mat-tab-label.mat-tab-disabled{cursor:default}@media (-ms-high-contrast:active){.mat-tab-label.mat-tab-disabled{opacity:.5}}.mat-tab-label .mat-tab-label-content{display:inline-flex;justify-content:center;align-items:center;white-space:nowrap}@media (-ms-high-contrast:active){.mat-tab-label{opacity:1}}@media (max-width:599px){.mat-tab-label{min-width:72px}}.mat-ink-bar{position:absolute;bottom:0;height:2px;transition:.5s cubic-bezier(.35,0,.25,1)}.mat-tab-group-inverted-header .mat-ink-bar{bottom:auto;top:0}@media (-ms-high-contrast:active){.mat-ink-bar{outline:solid 2px;height:0}}.mat-tab-header-pagination{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;position:relative;display:none;justify-content:center;align-items:center;min-width:32px;cursor:pointer;z-index:2;-webkit-tap-highlight-color:transparent;touch-action:none}.mat-tab-header-pagination-controls-enabled .mat-tab-header-pagination{display:flex}.mat-tab-header-pagination-before,.mat-tab-header-rtl .mat-tab-header-pagination-after{padding-left:4px}.mat-tab-header-pagination-before .mat-tab-header-pagination-chevron,.mat-tab-header-rtl .mat-tab-header-pagination-after .mat-tab-header-pagination-chevron{transform:rotate(-135deg)}.mat-tab-header-pagination-after,.mat-tab-header-rtl .mat-tab-header-pagination-before{padding-right:4px}.mat-tab-header-pagination-after .mat-tab-header-pagination-chevron,.mat-tab-header-rtl .mat-tab-header-pagination-before .mat-tab-header-pagination-chevron{transform:rotate(45deg)}.mat-tab-header-pagination-chevron{border-style:solid;border-width:2px 2px 0 0;content:'';height:8px;width:8px}.mat-tab-header-pagination-disabled{box-shadow:none;cursor:default}.mat-tab-label-container{display:flex;flex-grow:1;overflow:hidden;z-index:1}.mat-tab-list{flex-grow:1;position:relative;transition:transform .5s cubic-bezier(.35,0,.25,1)}.mat-tab-labels{display:flex}[mat-align-tabs=center] .mat-tab-labels{justify-content:center}[mat-align-tabs=end] .mat-tab-labels{justify-content:flex-end}\"],\n                    inputs: ['disableRipple'],\n                    encapsulation: core.ViewEncapsulation.None,\n                    changeDetection: core.ChangeDetectionStrategy.OnPush,\n                    host: {\n                        'class': 'mat-tab-header',\n                        '[class.mat-tab-header-pagination-controls-enabled]': '_showPaginationControls',\n                        '[class.mat-tab-header-rtl]': \"_getLayoutDirection() == 'rtl'\",\n                    },\n                },] },\n    ];\n    /** @nocollapse */\n    MatTabHeader.ctorParameters = function () { return [\n        { type: core.ElementRef },\n        { type: core.ChangeDetectorRef },\n        { type: scrolling.ViewportRuler },\n        { type: bidi.Directionality, decorators: [{ type: core.Optional }] },\n        { type: core.NgZone },\n        { type: platform.Platform }\n    ]; };\n    MatTabHeader.propDecorators = {\n        _labelWrappers: [{ type: core.ContentChildren, args: [MatTabLabelWrapper,] }],\n        _inkBar: [{ type: core.ViewChild, args: [MatInkBar,] }],\n        _tabListContainer: [{ type: core.ViewChild, args: ['tabListContainer',] }],\n        _tabList: [{ type: core.ViewChild, args: ['tabList',] }],\n        _nextPaginator: [{ type: core.ViewChild, args: ['nextPaginator',] }],\n        _previousPaginator: [{ type: core.ViewChild, args: ['previousPaginator',] }],\n        selectedIndex: [{ type: core.Input }],\n        selectFocusedIndex: [{ type: core.Output }],\n        indexFocused: [{ type: core.Output }]\n    };\n    return MatTabHeader;\n}(_MatTabHeaderMixinBase));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Used to generate unique ID's for each tab component\n * @type {?}\n */\nvar nextId = 0;\n/**\n * A simple change event emitted on focus or selection changes.\n */\nvar   /**\n * A simple change event emitted on focus or selection changes.\n */\nMatTabChangeEvent = /** @class */ (function () {\n    function MatTabChangeEvent() {\n    }\n    return MatTabChangeEvent;\n}());\n/**\n * Injection token that can be used to provide the default options the tabs module.\n * @type {?}\n */\nvar MAT_TABS_CONFIG = new core.InjectionToken('MAT_TABS_CONFIG');\n// Boilerplate for applying mixins to MatTabGroup.\n/**\n * \\@docs-private\n */\nvar   \n// Boilerplate for applying mixins to MatTabGroup.\n/**\n * \\@docs-private\n */\nMatTabGroupBase = /** @class */ (function () {\n    function MatTabGroupBase(_elementRef) {\n        this._elementRef = _elementRef;\n    }\n    return MatTabGroupBase;\n}());\n/** @type {?} */\nvar _MatTabGroupMixinBase = core$1.mixinColor(core$1.mixinDisableRipple(MatTabGroupBase), 'primary');\n/**\n * Material design tab-group component.  Supports basic tab pairs (label + content) and includes\n * animated ink-bar, keyboard navigation, and screen reader.\n * See: https://material.io/design/components/tabs.html\n */\nvar MatTabGroup = /** @class */ (function (_super) {\n    __extends(MatTabGroup, _super);\n    function MatTabGroup(elementRef, _changeDetectorRef, defaultConfig) {\n        var _this = _super.call(this, elementRef) || this;\n        _this._changeDetectorRef = _changeDetectorRef;\n        /**\n         * The tab index that should be selected after the content has been checked.\n         */\n        _this._indexToSelect = 0;\n        /**\n         * Snapshot of the height of the tab body wrapper before another tab is activated.\n         */\n        _this._tabBodyWrapperHeight = 0;\n        /**\n         * Subscription to tabs being added/removed.\n         */\n        _this._tabsSubscription = rxjs.Subscription.EMPTY;\n        /**\n         * Subscription to changes in the tab labels.\n         */\n        _this._tabLabelSubscription = rxjs.Subscription.EMPTY;\n        _this._dynamicHeight = false;\n        _this._selectedIndex = null;\n        /**\n         * Position of the tab header.\n         */\n        _this.headerPosition = 'above';\n        /**\n         * Output to enable support for two-way binding on `[(selectedIndex)]`\n         */\n        _this.selectedIndexChange = new core.EventEmitter();\n        /**\n         * Event emitted when focus has changed within a tab group.\n         */\n        _this.focusChange = new core.EventEmitter();\n        /**\n         * Event emitted when the body animation has completed\n         */\n        _this.animationDone = new core.EventEmitter();\n        /**\n         * Event emitted when the tab selection has changed.\n         */\n        _this.selectedTabChange = new core.EventEmitter(true);\n        _this._groupId = nextId++;\n        _this.animationDuration = defaultConfig && defaultConfig.animationDuration ?\n            defaultConfig.animationDuration : '500ms';\n        return _this;\n    }\n    Object.defineProperty(MatTabGroup.prototype, \"dynamicHeight\", {\n        /** Whether the tab group should grow to the size of the active tab. */\n        get: /**\n         * Whether the tab group should grow to the size of the active tab.\n         * @return {?}\n         */\n        function () { return this._dynamicHeight; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) { this._dynamicHeight = coercion.coerceBooleanProperty(value); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatTabGroup.prototype, \"selectedIndex\", {\n        /** The index of the active tab. */\n        get: /**\n         * The index of the active tab.\n         * @return {?}\n         */\n        function () { return this._selectedIndex; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) {\n            this._indexToSelect = coercion.coerceNumberProperty(value, null);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatTabGroup.prototype, \"animationDuration\", {\n        /** Duration for the tab animation. Will be normalized to milliseconds if no units are set. */\n        get: /**\n         * Duration for the tab animation. Will be normalized to milliseconds if no units are set.\n         * @return {?}\n         */\n        function () { return this._animationDuration; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) {\n            this._animationDuration = /^\\d+$/.test(value) ? value + 'ms' : value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatTabGroup.prototype, \"backgroundColor\", {\n        /** Background color of the tab group. */\n        get: /**\n         * Background color of the tab group.\n         * @return {?}\n         */\n        function () { return this._backgroundColor; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) {\n            /** @type {?} */\n            var nativeElement = this._elementRef.nativeElement;\n            nativeElement.classList.remove(\"mat-background-\" + this.backgroundColor);\n            if (value) {\n                nativeElement.classList.add(\"mat-background-\" + value);\n            }\n            this._backgroundColor = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * After the content is checked, this component knows what tabs have been defined\n     * and what the selected index should be. This is where we can know exactly what position\n     * each tab should be in according to the new selected index, and additionally we know how\n     * a new selected tab should transition in (from the left or right).\n     */\n    /**\n     * After the content is checked, this component knows what tabs have been defined\n     * and what the selected index should be. This is where we can know exactly what position\n     * each tab should be in according to the new selected index, and additionally we know how\n     * a new selected tab should transition in (from the left or right).\n     * @return {?}\n     */\n    MatTabGroup.prototype.ngAfterContentChecked = /**\n     * After the content is checked, this component knows what tabs have been defined\n     * and what the selected index should be. This is where we can know exactly what position\n     * each tab should be in according to the new selected index, and additionally we know how\n     * a new selected tab should transition in (from the left or right).\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        // Don't clamp the `indexToSelect` immediately in the setter because it can happen that\n        // the amount of tabs changes before the actual change detection runs.\n        /** @type {?} */\n        var indexToSelect = this._indexToSelect = this._clampTabIndex(this._indexToSelect);\n        // If there is a change in selected index, emit a change event. Should not trigger if\n        // the selected index has not yet been initialized.\n        if (this._selectedIndex != indexToSelect) {\n            /** @type {?} */\n            var isFirstRun_1 = this._selectedIndex == null;\n            if (!isFirstRun_1) {\n                this.selectedTabChange.emit(this._createChangeEvent(indexToSelect));\n            }\n            // Changing these values after change detection has run\n            // since the checked content may contain references to them.\n            Promise.resolve().then(function () {\n                _this._tabs.forEach(function (tab, index) { return tab.isActive = index === indexToSelect; });\n                if (!isFirstRun_1) {\n                    _this.selectedIndexChange.emit(indexToSelect);\n                }\n            });\n        }\n        // Setup the position for each tab and optionally setup an origin on the next selected tab.\n        this._tabs.forEach(function (tab, index) {\n            tab.position = index - indexToSelect;\n            // If there is already a selected tab, then set up an origin for the next selected tab\n            // if it doesn't have one already.\n            if (_this._selectedIndex != null && tab.position == 0 && !tab.origin) {\n                tab.origin = indexToSelect - _this._selectedIndex;\n            }\n        });\n        if (this._selectedIndex !== indexToSelect) {\n            this._selectedIndex = indexToSelect;\n            this._changeDetectorRef.markForCheck();\n        }\n    };\n    /**\n     * @return {?}\n     */\n    MatTabGroup.prototype.ngAfterContentInit = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        this._subscribeToTabLabels();\n        // Subscribe to changes in the amount of tabs, in order to be\n        // able to re-render the content as new tabs are added or removed.\n        this._tabsSubscription = this._tabs.changes.subscribe(function () {\n            /** @type {?} */\n            var indexToSelect = _this._clampTabIndex(_this._indexToSelect);\n            // Maintain the previously-selected tab if a new tab is added or removed and there is no\n            // explicit change that selects a different tab.\n            if (indexToSelect === _this._selectedIndex) {\n                /** @type {?} */\n                var tabs = _this._tabs.toArray();\n                for (var i = 0; i < tabs.length; i++) {\n                    if (tabs[i].isActive) {\n                        // Assign both to the `_indexToSelect` and `_selectedIndex` so we don't fire a changed\n                        // event, otherwise the consumer may end up in an infinite loop in some edge cases like\n                        // adding a tab within the `selectedIndexChange` event.\n                        _this._indexToSelect = _this._selectedIndex = i;\n                        break;\n                    }\n                }\n            }\n            _this._subscribeToTabLabels();\n            _this._changeDetectorRef.markForCheck();\n        });\n    };\n    /**\n     * @return {?}\n     */\n    MatTabGroup.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this._tabsSubscription.unsubscribe();\n        this._tabLabelSubscription.unsubscribe();\n    };\n    /** Re-aligns the ink bar to the selected tab element. */\n    /**\n     * Re-aligns the ink bar to the selected tab element.\n     * @return {?}\n     */\n    MatTabGroup.prototype.realignInkBar = /**\n     * Re-aligns the ink bar to the selected tab element.\n     * @return {?}\n     */\n    function () {\n        if (this._tabHeader) {\n            this._tabHeader._alignInkBarToSelectedTab();\n        }\n    };\n    /**\n     * @param {?} index\n     * @return {?}\n     */\n    MatTabGroup.prototype._focusChanged = /**\n     * @param {?} index\n     * @return {?}\n     */\n    function (index) {\n        this.focusChange.emit(this._createChangeEvent(index));\n    };\n    /**\n     * @private\n     * @param {?} index\n     * @return {?}\n     */\n    MatTabGroup.prototype._createChangeEvent = /**\n     * @private\n     * @param {?} index\n     * @return {?}\n     */\n    function (index) {\n        /** @type {?} */\n        var event = new MatTabChangeEvent;\n        event.index = index;\n        if (this._tabs && this._tabs.length) {\n            event.tab = this._tabs.toArray()[index];\n        }\n        return event;\n    };\n    /**\n     * Subscribes to changes in the tab labels. This is needed, because the @Input for the label is\n     * on the MatTab component, whereas the data binding is inside the MatTabGroup. In order for the\n     * binding to be updated, we need to subscribe to changes in it and trigger change detection\n     * manually.\n     */\n    /**\n     * Subscribes to changes in the tab labels. This is needed, because the \\@Input for the label is\n     * on the MatTab component, whereas the data binding is inside the MatTabGroup. In order for the\n     * binding to be updated, we need to subscribe to changes in it and trigger change detection\n     * manually.\n     * @private\n     * @return {?}\n     */\n    MatTabGroup.prototype._subscribeToTabLabels = /**\n     * Subscribes to changes in the tab labels. This is needed, because the \\@Input for the label is\n     * on the MatTab component, whereas the data binding is inside the MatTabGroup. In order for the\n     * binding to be updated, we need to subscribe to changes in it and trigger change detection\n     * manually.\n     * @private\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        if (this._tabLabelSubscription) {\n            this._tabLabelSubscription.unsubscribe();\n        }\n        this._tabLabelSubscription = rxjs.merge.apply(void 0, this._tabs.map(function (tab) { return tab._stateChanges; })).subscribe(function () { return _this._changeDetectorRef.markForCheck(); });\n    };\n    /** Clamps the given index to the bounds of 0 and the tabs length. */\n    /**\n     * Clamps the given index to the bounds of 0 and the tabs length.\n     * @private\n     * @param {?} index\n     * @return {?}\n     */\n    MatTabGroup.prototype._clampTabIndex = /**\n     * Clamps the given index to the bounds of 0 and the tabs length.\n     * @private\n     * @param {?} index\n     * @return {?}\n     */\n    function (index) {\n        // Note the `|| 0`, which ensures that values like NaN can't get through\n        // and which would otherwise throw the component into an infinite loop\n        // (since Math.max(NaN, 0) === NaN).\n        return Math.min(this._tabs.length - 1, Math.max(index || 0, 0));\n    };\n    /** Returns a unique id for each tab label element */\n    /**\n     * Returns a unique id for each tab label element\n     * @param {?} i\n     * @return {?}\n     */\n    MatTabGroup.prototype._getTabLabelId = /**\n     * Returns a unique id for each tab label element\n     * @param {?} i\n     * @return {?}\n     */\n    function (i) {\n        return \"mat-tab-label-\" + this._groupId + \"-\" + i;\n    };\n    /** Returns a unique id for each tab content element */\n    /**\n     * Returns a unique id for each tab content element\n     * @param {?} i\n     * @return {?}\n     */\n    MatTabGroup.prototype._getTabContentId = /**\n     * Returns a unique id for each tab content element\n     * @param {?} i\n     * @return {?}\n     */\n    function (i) {\n        return \"mat-tab-content-\" + this._groupId + \"-\" + i;\n    };\n    /**\n     * Sets the height of the body wrapper to the height of the activating tab if dynamic\n     * height property is true.\n     */\n    /**\n     * Sets the height of the body wrapper to the height of the activating tab if dynamic\n     * height property is true.\n     * @param {?} tabHeight\n     * @return {?}\n     */\n    MatTabGroup.prototype._setTabBodyWrapperHeight = /**\n     * Sets the height of the body wrapper to the height of the activating tab if dynamic\n     * height property is true.\n     * @param {?} tabHeight\n     * @return {?}\n     */\n    function (tabHeight) {\n        if (!this._dynamicHeight || !this._tabBodyWrapperHeight) {\n            return;\n        }\n        /** @type {?} */\n        var wrapper = this._tabBodyWrapper.nativeElement;\n        wrapper.style.height = this._tabBodyWrapperHeight + 'px';\n        // This conditional forces the browser to paint the height so that\n        // the animation to the new height can have an origin.\n        if (this._tabBodyWrapper.nativeElement.offsetHeight) {\n            wrapper.style.height = tabHeight + 'px';\n        }\n    };\n    /** Removes the height of the tab body wrapper. */\n    /**\n     * Removes the height of the tab body wrapper.\n     * @return {?}\n     */\n    MatTabGroup.prototype._removeTabBodyWrapperHeight = /**\n     * Removes the height of the tab body wrapper.\n     * @return {?}\n     */\n    function () {\n        /** @type {?} */\n        var wrapper = this._tabBodyWrapper.nativeElement;\n        this._tabBodyWrapperHeight = wrapper.clientHeight;\n        wrapper.style.height = '';\n        this.animationDone.emit();\n    };\n    /** Handle click events, setting new selected index if appropriate. */\n    /**\n     * Handle click events, setting new selected index if appropriate.\n     * @param {?} tab\n     * @param {?} tabHeader\n     * @param {?} index\n     * @return {?}\n     */\n    MatTabGroup.prototype._handleClick = /**\n     * Handle click events, setting new selected index if appropriate.\n     * @param {?} tab\n     * @param {?} tabHeader\n     * @param {?} index\n     * @return {?}\n     */\n    function (tab, tabHeader, index) {\n        if (!tab.disabled) {\n            this.selectedIndex = tabHeader.focusIndex = index;\n        }\n    };\n    /** Retrieves the tabindex for the tab. */\n    /**\n     * Retrieves the tabindex for the tab.\n     * @param {?} tab\n     * @param {?} idx\n     * @return {?}\n     */\n    MatTabGroup.prototype._getTabIndex = /**\n     * Retrieves the tabindex for the tab.\n     * @param {?} tab\n     * @param {?} idx\n     * @return {?}\n     */\n    function (tab, idx) {\n        if (tab.disabled) {\n            return null;\n        }\n        return this.selectedIndex === idx ? 0 : -1;\n    };\n    MatTabGroup.decorators = [\n        { type: core.Component, args: [{selector: 'mat-tab-group',\n                    exportAs: 'matTabGroup',\n                    template: \"<mat-tab-header #tabHeader [selectedIndex]=\\\"selectedIndex\\\" [disableRipple]=\\\"disableRipple\\\" (indexFocused)=\\\"_focusChanged($event)\\\" (selectFocusedIndex)=\\\"selectedIndex = $event\\\"><div class=\\\"mat-tab-label\\\" role=\\\"tab\\\" matTabLabelWrapper mat-ripple cdkMonitorElementFocus *ngFor=\\\"let tab of _tabs; let i = index\\\" [id]=\\\"_getTabLabelId(i)\\\" [attr.tabIndex]=\\\"_getTabIndex(tab, i)\\\" [attr.aria-posinset]=\\\"i + 1\\\" [attr.aria-setsize]=\\\"_tabs.length\\\" [attr.aria-controls]=\\\"_getTabContentId(i)\\\" [attr.aria-selected]=\\\"selectedIndex == i\\\" [attr.aria-label]=\\\"tab.ariaLabel || null\\\" [attr.aria-labelledby]=\\\"(!tab.ariaLabel && tab.ariaLabelledby) ? tab.ariaLabelledby : null\\\" [class.mat-tab-label-active]=\\\"selectedIndex == i\\\" [disabled]=\\\"tab.disabled\\\" [matRippleDisabled]=\\\"tab.disabled || disableRipple\\\" (click)=\\\"_handleClick(tab, tabHeader, i)\\\"><div class=\\\"mat-tab-label-content\\\"><ng-template [ngIf]=\\\"tab.templateLabel\\\"><ng-template [cdkPortalOutlet]=\\\"tab.templateLabel\\\"></ng-template></ng-template><ng-template [ngIf]=\\\"!tab.templateLabel\\\">{{tab.textLabel}}</ng-template></div></div></mat-tab-header><div class=\\\"mat-tab-body-wrapper\\\" #tabBodyWrapper><mat-tab-body role=\\\"tabpanel\\\" *ngFor=\\\"let tab of _tabs; let i = index\\\" [id]=\\\"_getTabContentId(i)\\\" [attr.aria-labelledby]=\\\"_getTabLabelId(i)\\\" [class.mat-tab-body-active]=\\\"selectedIndex == i\\\" [content]=\\\"tab.content\\\" [position]=\\\"tab.position\\\" [origin]=\\\"tab.origin\\\" [animationDuration]=\\\"animationDuration\\\" (_onCentered)=\\\"_removeTabBodyWrapperHeight()\\\" (_onCentering)=\\\"_setTabBodyWrapperHeight($event)\\\"></mat-tab-body></div>\",\n                    styles: [\".mat-tab-group{display:flex;flex-direction:column}.mat-tab-group.mat-tab-group-inverted-header{flex-direction:column-reverse}.mat-tab-label{height:48px;padding:0 24px;cursor:pointer;box-sizing:border-box;opacity:.6;min-width:160px;text-align:center;display:inline-flex;justify-content:center;align-items:center;white-space:nowrap;position:relative}.mat-tab-label:focus{outline:0}.mat-tab-label:focus:not(.mat-tab-disabled){opacity:1}@media (-ms-high-contrast:active){.mat-tab-label:focus{outline:dotted 2px}}.mat-tab-label.mat-tab-disabled{cursor:default}@media (-ms-high-contrast:active){.mat-tab-label.mat-tab-disabled{opacity:.5}}.mat-tab-label .mat-tab-label-content{display:inline-flex;justify-content:center;align-items:center;white-space:nowrap}@media (-ms-high-contrast:active){.mat-tab-label{opacity:1}}@media (max-width:599px){.mat-tab-label{padding:0 12px}}@media (max-width:959px){.mat-tab-label{padding:0 12px}}.mat-tab-group[mat-stretch-tabs]>.mat-tab-header .mat-tab-label{flex-basis:0;flex-grow:1}.mat-tab-body-wrapper{position:relative;overflow:hidden;display:flex;transition:height .5s cubic-bezier(.35,0,.25,1)}.mat-tab-body{top:0;left:0;right:0;bottom:0;position:absolute;display:block;overflow:hidden;flex-basis:100%}.mat-tab-body.mat-tab-body-active{position:relative;overflow-x:hidden;overflow-y:auto;z-index:1;flex-grow:1}.mat-tab-group.mat-tab-group-dynamic-height .mat-tab-body.mat-tab-body-active{overflow-y:hidden}\"],\n                    encapsulation: core.ViewEncapsulation.None,\n                    changeDetection: core.ChangeDetectionStrategy.OnPush,\n                    inputs: ['color', 'disableRipple'],\n                    host: {\n                        'class': 'mat-tab-group',\n                        '[class.mat-tab-group-dynamic-height]': 'dynamicHeight',\n                        '[class.mat-tab-group-inverted-header]': 'headerPosition === \"below\"',\n                    },\n                },] },\n    ];\n    /** @nocollapse */\n    MatTabGroup.ctorParameters = function () { return [\n        { type: core.ElementRef },\n        { type: core.ChangeDetectorRef },\n        { type: undefined, decorators: [{ type: core.Inject, args: [MAT_TABS_CONFIG,] }, { type: core.Optional }] }\n    ]; };\n    MatTabGroup.propDecorators = {\n        _tabs: [{ type: core.ContentChildren, args: [MatTab,] }],\n        _tabBodyWrapper: [{ type: core.ViewChild, args: ['tabBodyWrapper',] }],\n        _tabHeader: [{ type: core.ViewChild, args: ['tabHeader',] }],\n        dynamicHeight: [{ type: core.Input }],\n        selectedIndex: [{ type: core.Input }],\n        headerPosition: [{ type: core.Input }],\n        animationDuration: [{ type: core.Input }],\n        backgroundColor: [{ type: core.Input }],\n        selectedIndexChange: [{ type: core.Output }],\n        focusChange: [{ type: core.Output }],\n        animationDone: [{ type: core.Output }],\n        selectedTabChange: [{ type: core.Output }]\n    };\n    return MatTabGroup;\n}(_MatTabGroupMixinBase));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n// Boilerplate for applying mixins to MatTabNav.\n/**\n * \\@docs-private\n */\nvar   \n// Boilerplate for applying mixins to MatTabNav.\n/**\n * \\@docs-private\n */\nMatTabNavBase = /** @class */ (function () {\n    function MatTabNavBase(_elementRef) {\n        this._elementRef = _elementRef;\n    }\n    return MatTabNavBase;\n}());\n/** @type {?} */\nvar _MatTabNavMixinBase = core$1.mixinDisableRipple(core$1.mixinColor(MatTabNavBase, 'primary'));\n/**\n * Navigation component matching the styles of the tab group header.\n * Provides anchored navigation with animated ink bar.\n */\nvar MatTabNav = /** @class */ (function (_super) {\n    __extends(MatTabNav, _super);\n    function MatTabNav(elementRef, _dir, _ngZone, _changeDetectorRef, _viewportRuler) {\n        var _this = _super.call(this, elementRef) || this;\n        _this._dir = _dir;\n        _this._ngZone = _ngZone;\n        _this._changeDetectorRef = _changeDetectorRef;\n        _this._viewportRuler = _viewportRuler;\n        /**\n         * Subject that emits when the component has been destroyed.\n         */\n        _this._onDestroy = new rxjs.Subject();\n        return _this;\n    }\n    Object.defineProperty(MatTabNav.prototype, \"backgroundColor\", {\n        /** Background color of the tab nav. */\n        get: /**\n         * Background color of the tab nav.\n         * @return {?}\n         */\n        function () { return this._backgroundColor; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) {\n            /** @type {?} */\n            var nativeElement = this._elementRef.nativeElement;\n            nativeElement.classList.remove(\"mat-background-\" + this.backgroundColor);\n            if (value) {\n                nativeElement.classList.add(\"mat-background-\" + value);\n            }\n            this._backgroundColor = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Notifies the component that the active link has been changed.\n     * @breaking-change 8.0.0 `element` parameter to be removed.\n     */\n    /**\n     * Notifies the component that the active link has been changed.\n     * \\@breaking-change 8.0.0 `element` parameter to be removed.\n     * @param {?} element\n     * @return {?}\n     */\n    MatTabNav.prototype.updateActiveLink = /**\n     * Notifies the component that the active link has been changed.\n     * \\@breaking-change 8.0.0 `element` parameter to be removed.\n     * @param {?} element\n     * @return {?}\n     */\n    function (element) {\n        // Note: keeping the `element` for backwards-compat, but isn't being used for anything.\n        // @breaking-change 8.0.0\n        this._activeLinkChanged = !!element;\n        this._changeDetectorRef.markForCheck();\n    };\n    /**\n     * @return {?}\n     */\n    MatTabNav.prototype.ngAfterContentInit = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        this._ngZone.runOutsideAngular(function () {\n            /** @type {?} */\n            var dirChange = _this._dir ? _this._dir.change : rxjs.of(null);\n            return rxjs.merge(dirChange, _this._viewportRuler.change(10))\n                .pipe(operators.takeUntil(_this._onDestroy))\n                .subscribe(function () { return _this._alignInkBar(); });\n        });\n    };\n    /** Checks if the active link has been changed and, if so, will update the ink bar. */\n    /**\n     * Checks if the active link has been changed and, if so, will update the ink bar.\n     * @return {?}\n     */\n    MatTabNav.prototype.ngAfterContentChecked = /**\n     * Checks if the active link has been changed and, if so, will update the ink bar.\n     * @return {?}\n     */\n    function () {\n        if (this._activeLinkChanged) {\n            /** @type {?} */\n            var activeTab = this._tabLinks.find(function (tab) { return tab.active; });\n            this._activeLinkElement = activeTab ? activeTab._elementRef : null;\n            this._alignInkBar();\n            this._activeLinkChanged = false;\n        }\n    };\n    /**\n     * @return {?}\n     */\n    MatTabNav.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this._onDestroy.next();\n        this._onDestroy.complete();\n    };\n    /** Aligns the ink bar to the active link. */\n    /**\n     * Aligns the ink bar to the active link.\n     * @return {?}\n     */\n    MatTabNav.prototype._alignInkBar = /**\n     * Aligns the ink bar to the active link.\n     * @return {?}\n     */\n    function () {\n        if (this._activeLinkElement) {\n            this._inkBar.show();\n            this._inkBar.alignToElement(this._activeLinkElement.nativeElement);\n        }\n        else {\n            this._inkBar.hide();\n        }\n    };\n    MatTabNav.decorators = [\n        { type: core.Component, args: [{selector: '[mat-tab-nav-bar]',\n                    exportAs: 'matTabNavBar, matTabNav',\n                    inputs: ['color', 'disableRipple'],\n                    template: \"<div class=\\\"mat-tab-links\\\" (cdkObserveContent)=\\\"_alignInkBar()\\\"><ng-content></ng-content><mat-ink-bar></mat-ink-bar></div>\",\n                    styles: [\".mat-tab-nav-bar{overflow:hidden;position:relative;flex-shrink:0}.mat-tab-links{position:relative;display:flex}[mat-align-tabs=center] .mat-tab-links{justify-content:center}[mat-align-tabs=end] .mat-tab-links{justify-content:flex-end}.mat-tab-link{height:48px;padding:0 24px;cursor:pointer;box-sizing:border-box;opacity:.6;min-width:160px;text-align:center;display:inline-flex;justify-content:center;align-items:center;white-space:nowrap;vertical-align:top;text-decoration:none;position:relative;overflow:hidden;-webkit-tap-highlight-color:transparent}.mat-tab-link:focus{outline:0}.mat-tab-link:focus:not(.mat-tab-disabled){opacity:1}@media (-ms-high-contrast:active){.mat-tab-link:focus{outline:dotted 2px}}.mat-tab-link.mat-tab-disabled{cursor:default}@media (-ms-high-contrast:active){.mat-tab-link.mat-tab-disabled{opacity:.5}}.mat-tab-link .mat-tab-label-content{display:inline-flex;justify-content:center;align-items:center;white-space:nowrap}@media (-ms-high-contrast:active){.mat-tab-link{opacity:1}}[mat-stretch-tabs] .mat-tab-link{flex-basis:0;flex-grow:1}.mat-tab-link.mat-tab-disabled{pointer-events:none}@media (max-width:599px){.mat-tab-link{min-width:72px}}.mat-ink-bar{position:absolute;bottom:0;height:2px;transition:.5s cubic-bezier(.35,0,.25,1)}.mat-tab-group-inverted-header .mat-ink-bar{bottom:auto;top:0}@media (-ms-high-contrast:active){.mat-ink-bar{outline:solid 2px;height:0}}\"],\n                    host: { 'class': 'mat-tab-nav-bar' },\n                    encapsulation: core.ViewEncapsulation.None,\n                    changeDetection: core.ChangeDetectionStrategy.OnPush,\n                },] },\n    ];\n    /** @nocollapse */\n    MatTabNav.ctorParameters = function () { return [\n        { type: core.ElementRef },\n        { type: bidi.Directionality, decorators: [{ type: core.Optional }] },\n        { type: core.NgZone },\n        { type: core.ChangeDetectorRef },\n        { type: scrolling.ViewportRuler }\n    ]; };\n    MatTabNav.propDecorators = {\n        _inkBar: [{ type: core.ViewChild, args: [MatInkBar,] }],\n        _tabLinks: [{ type: core.ContentChildren, args: [core.forwardRef(function () { return MatTabLink; }), { descendants: true },] }],\n        backgroundColor: [{ type: core.Input }]\n    };\n    return MatTabNav;\n}(_MatTabNavMixinBase));\n// Boilerplate for applying mixins to MatTabLink.\nvar   \n// Boilerplate for applying mixins to MatTabLink.\nMatTabLinkBase = /** @class */ (function () {\n    function MatTabLinkBase() {\n    }\n    return MatTabLinkBase;\n}());\n/** @type {?} */\nvar _MatTabLinkMixinBase = core$1.mixinTabIndex(core$1.mixinDisableRipple(core$1.mixinDisabled(MatTabLinkBase)));\n/**\n * Link inside of a `mat-tab-nav-bar`.\n */\nvar MatTabLink = /** @class */ (function (_super) {\n    __extends(MatTabLink, _super);\n    function MatTabLink(_tabNavBar, _elementRef, ngZone, platform$$1, globalRippleOptions, tabIndex, _focusMonitor) {\n        var _this = _super.call(this) || this;\n        _this._tabNavBar = _tabNavBar;\n        _this._elementRef = _elementRef;\n        _this._focusMonitor = _focusMonitor;\n        /**\n         * Whether the tab link is active or not.\n         */\n        _this._isActive = false;\n        _this._tabLinkRipple = new core$1.RippleRenderer(_this, ngZone, _elementRef, platform$$1);\n        _this._tabLinkRipple.setupTriggerEvents(_elementRef.nativeElement);\n        _this.rippleConfig = globalRippleOptions || {};\n        _this.tabIndex = parseInt(tabIndex) || 0;\n        if (_focusMonitor) {\n            _focusMonitor.monitor(_elementRef);\n        }\n        return _this;\n    }\n    Object.defineProperty(MatTabLink.prototype, \"active\", {\n        /** Whether the link is active. */\n        get: /**\n         * Whether the link is active.\n         * @return {?}\n         */\n        function () { return this._isActive; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) {\n            if (value !== this._isActive) {\n                this._isActive = value;\n                this._tabNavBar.updateActiveLink(this._elementRef);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatTabLink.prototype, \"rippleDisabled\", {\n        /**\n         * Whether ripples are disabled on interaction.\n         * @docs-private\n         */\n        get: /**\n         * Whether ripples are disabled on interaction.\n         * \\@docs-private\n         * @return {?}\n         */\n        function () {\n            return this.disabled || this.disableRipple || this._tabNavBar.disableRipple ||\n                !!this.rippleConfig.disabled;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    MatTabLink.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this._tabLinkRipple._removeTriggerEvents();\n        if (this._focusMonitor) {\n            this._focusMonitor.stopMonitoring(this._elementRef);\n        }\n    };\n    MatTabLink.decorators = [\n        { type: core.Directive, args: [{\n                    selector: '[mat-tab-link], [matTabLink]',\n                    exportAs: 'matTabLink',\n                    inputs: ['disabled', 'disableRipple', 'tabIndex'],\n                    host: {\n                        'class': 'mat-tab-link',\n                        '[attr.aria-current]': 'active',\n                        '[attr.aria-disabled]': 'disabled.toString()',\n                        '[attr.tabIndex]': 'tabIndex',\n                        '[class.mat-tab-disabled]': 'disabled',\n                        '[class.mat-tab-label-active]': 'active',\n                    }\n                },] },\n    ];\n    /** @nocollapse */\n    MatTabLink.ctorParameters = function () { return [\n        { type: MatTabNav },\n        { type: core.ElementRef },\n        { type: core.NgZone },\n        { type: platform.Platform },\n        { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [core$1.MAT_RIPPLE_GLOBAL_OPTIONS,] }] },\n        { type: String, decorators: [{ type: core.Attribute, args: ['tabindex',] }] },\n        { type: a11y.FocusMonitor }\n    ]; };\n    MatTabLink.propDecorators = {\n        active: [{ type: core.Input }]\n    };\n    return MatTabLink;\n}(_MatTabLinkMixinBase));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar MatTabsModule = /** @class */ (function () {\n    function MatTabsModule() {\n    }\n    MatTabsModule.decorators = [\n        { type: core.NgModule, args: [{\n                    imports: [\n                        common.CommonModule,\n                        core$1.MatCommonModule,\n                        portal.PortalModule,\n                        core$1.MatRippleModule,\n                        observers.ObserversModule,\n                        a11y.A11yModule,\n                    ],\n                    // Don't export all components because some are only to be used internally.\n                    exports: [\n                        core$1.MatCommonModule,\n                        MatTabGroup,\n                        MatTabLabel,\n                        MatTab,\n                        MatTabNav,\n                        MatTabLink,\n                        MatTabContent,\n                    ],\n                    declarations: [\n                        MatTabGroup,\n                        MatTabLabel,\n                        MatTab,\n                        MatInkBar,\n                        MatTabLabelWrapper,\n                        MatTabNav,\n                        MatTabLink,\n                        MatTabBody,\n                        MatTabBodyPortal,\n                        MatTabHeader,\n                        MatTabContent,\n                    ],\n                },] },\n    ];\n    return MatTabsModule;\n}());\n\nexports.MatInkBar = MatInkBar;\nexports._MAT_INK_BAR_POSITIONER = _MAT_INK_BAR_POSITIONER;\nexports.MatTabBody = MatTabBody;\nexports.MatTabBodyPortal = MatTabBodyPortal;\nexports.MatTabHeader = MatTabHeader;\nexports.MatTabLabelWrapper = MatTabLabelWrapper;\nexports.MatTab = MatTab;\nexports.MatTabLabel = MatTabLabel;\nexports.MatTabNav = MatTabNav;\nexports.MatTabLink = MatTabLink;\nexports.MatTabContent = MatTabContent;\nexports.MatTabsModule = MatTabsModule;\nexports.MatTabChangeEvent = MatTabChangeEvent;\nexports.MAT_TABS_CONFIG = MAT_TABS_CONFIG;\nexports.MatTabGroupBase = MatTabGroupBase;\nexports._MatTabGroupMixinBase = _MatTabGroupMixinBase;\nexports.MatTabGroup = MatTabGroup;\nexports.matTabsAnimations = matTabsAnimations;\nexports.ɵa21 = _MAT_INK_BAR_POSITIONER_FACTORY;\nexports.ɵf21 = MatTabBase;\nexports.ɵg21 = _MatTabMixinBase;\nexports.ɵb21 = MatTabHeaderBase;\nexports.ɵc21 = _MatTabHeaderMixinBase;\nexports.ɵd21 = MatTabLabelWrapperBase;\nexports.ɵe21 = _MatTabLabelWrapperMixinBase;\nexports.ɵj21 = MatTabLinkBase;\nexports.ɵh21 = MatTabNavBase;\nexports.ɵk21 = _MatTabLinkMixinBase;\nexports.ɵi21 = _MatTabNavMixinBase;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}