{"ast":null,"code":"import { Subject, Observable, merge, ReplaySubject, combineLatest, fromEvent } from 'rxjs';\nimport { DOCUMENT } from '@angular/common';\nimport autoScroll from '@mattlewis92/dom-autoscroller';\nimport { Injectable, Directive, ElementRef, Input, Renderer2, Output, EventEmitter, NgZone, Inject, ViewContainerRef, Optional, NgModule, defineInjectable } from '@angular/core';\nimport { map, mergeMap, takeUntil, take, takeLast, pairwise, share, filter, count, startWith, distinctUntilChanged } from 'rxjs/operators';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\nimport * as ɵngcc0 from '@angular/core';\n\nclass DraggableHelper {\n  constructor() {\n    this.currentDrag = new Subject();\n  }\n\n}\n\nDraggableHelper.ɵfac = function DraggableHelper_Factory(t) {\n  return new (t || DraggableHelper)();\n};\n\nDraggableHelper.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n  token: DraggableHelper,\n  factory: DraggableHelper.ɵfac,\n  providedIn: 'root'\n});\n/** @nocollapse */\n\nDraggableHelper.ngInjectableDef = defineInjectable({\n  factory: function DraggableHelper_Factory() {\n    return new DraggableHelper();\n  },\n  token: DraggableHelper,\n  providedIn: \"root\"\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DraggableHelper, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [];\n  }, null);\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * If the window isn't scrollable, then place this on the scrollable container that draggable elements are inside. e.g.\n * ```html\n * <div style=\"overflow: scroll\" mwlDraggableScrollContainer>\n * <div mwlDraggable>Drag me!</div>\n * </div>\n * ```\n */\n\n\nclass DraggableScrollContainerDirective {\n  /**\n   * @hidden\n   * @param {?} elementRef\n   */\n  constructor(elementRef) {\n    this.elementRef = elementRef;\n    /**\n     * Trigger the DragStart after a long touch in scrollable container when true\n     * @deprecated will be removed in v5 (use [touchStartLongPress]=\"{delay: 300, delta: 30}\" on the mwlDraggable element instead)\n     */\n\n    this.activeLongPressDrag = false;\n    /**\n     * Configuration of a long touch\n     * Duration in ms of a long touch before activating DragStart\n     * Delta of the\n     * @deprecated will be removed in v5 (use [touchStartLongPress]=\"{delay: 300, delta: 30}\" on the mwlDraggable element instead)\n     */\n\n    this.longPressConfig = {\n      duration: 300,\n      delta: 30\n    };\n  }\n\n}\n\nDraggableScrollContainerDirective.ɵfac = function DraggableScrollContainerDirective_Factory(t) {\n  return new (t || DraggableScrollContainerDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef));\n};\n\nDraggableScrollContainerDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n  type: DraggableScrollContainerDirective,\n  selectors: [[\"\", \"mwlDraggableScrollContainer\", \"\"]],\n  inputs: {\n    activeLongPressDrag: \"activeLongPressDrag\",\n    longPressConfig: \"longPressConfig\"\n  }\n});\n/** @nocollapse */\n\nDraggableScrollContainerDirective.ctorParameters = () => [{\n  type: ElementRef\n}];\n\nDraggableScrollContainerDirective.propDecorators = {\n  activeLongPressDrag: [{\n    type: Input\n  }],\n  longPressConfig: [{\n    type: Input\n  }]\n};\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DraggableScrollContainerDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[mwlDraggableScrollContainer]'\n    }]\n  }], function () {\n    return [{\n      type: ɵngcc0.ElementRef\n    }];\n  }, {\n    activeLongPressDrag: [{\n      type: Input\n    }],\n    longPressConfig: [{\n      type: Input\n    }]\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} renderer\n * @param {?} element\n * @param {?} classToAdd\n * @return {?}\n */\n\n\nfunction addClass(renderer, element, classToAdd) {\n  if (classToAdd) {\n    classToAdd.split(' ').forEach(\n    /**\n    * @param {?} className\n    * @return {?}\n    */\n    className => renderer.addClass(element.nativeElement, className));\n  }\n}\n/**\n * @param {?} renderer\n * @param {?} element\n * @param {?} classToRemove\n * @return {?}\n */\n\n\nfunction removeClass(renderer, element, classToRemove) {\n  if (classToRemove) {\n    classToRemove.split(' ').forEach(\n    /**\n    * @param {?} className\n    * @return {?}\n    */\n    className => renderer.removeClass(element.nativeElement, className));\n  }\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nclass DraggableDirective {\n  /**\n   * @hidden\n   * @param {?} element\n   * @param {?} renderer\n   * @param {?} draggableHelper\n   * @param {?} zone\n   * @param {?} vcr\n   * @param {?} scrollContainer\n   * @param {?} document\n   */\n  constructor(element, renderer, draggableHelper, zone, vcr, scrollContainer, document) {\n    this.element = element;\n    this.renderer = renderer;\n    this.draggableHelper = draggableHelper;\n    this.zone = zone;\n    this.vcr = vcr;\n    this.scrollContainer = scrollContainer;\n    this.document = document;\n    /**\n     * The axis along which the element is draggable\n     */\n\n    this.dragAxis = {\n      x: true,\n      y: true\n    };\n    /**\n     * Snap all drags to an x / y grid\n     */\n\n    this.dragSnapGrid = {};\n    /**\n     * Show a ghost element that shows the drag when dragging\n     */\n\n    this.ghostDragEnabled = true;\n    /**\n     * Show the original element when ghostDragEnabled is true\n     */\n\n    this.showOriginalElementWhileDragging = false;\n    /**\n     * The cursor to use when hovering over a draggable element\n     */\n\n    this.dragCursor = '';\n    /*\n       * Options used to control the behaviour of auto scrolling: https://www.npmjs.com/package/dom-autoscroller\n       */\n\n    this.autoScroll = {\n      margin: 20\n    };\n    /**\n     * Called when the element can be dragged along one axis and has the mouse or pointer device pressed on it\n     */\n\n    this.dragPointerDown = new EventEmitter();\n    /**\n     * Called when the element has started to be dragged.\n     * Only called after at least one mouse or touch move event.\n     * If you call $event.cancelDrag$.emit() it will cancel the current drag\n     */\n\n    this.dragStart = new EventEmitter();\n    /**\n     * Called after the ghost element has been created\n     */\n\n    this.ghostElementCreated = new EventEmitter();\n    /**\n     * Called when the element is being dragged\n     */\n\n    this.dragging = new EventEmitter();\n    /**\n     * Called after the element is dragged\n     */\n\n    this.dragEnd = new EventEmitter();\n    /**\n     * @hidden\n     */\n\n    this.pointerDown$ = new Subject();\n    /**\n     * @hidden\n     */\n\n    this.pointerMove$ = new Subject();\n    /**\n     * @hidden\n     */\n\n    this.pointerUp$ = new Subject();\n    this.eventListenerSubscriptions = {};\n    this.destroy$ = new Subject();\n    this.timeLongPress = {\n      timerBegin: 0,\n      timerEnd: 0\n    };\n  }\n  /**\n   * @return {?}\n   */\n\n\n  ngOnInit() {\n    this.checkEventListeners();\n    /** @type {?} */\n\n    const pointerDragged$ = this.pointerDown$.pipe(filter(\n    /**\n    * @return {?}\n    */\n    () => this.canDrag()), mergeMap(\n    /**\n    * @param {?} pointerDownEvent\n    * @return {?}\n    */\n    pointerDownEvent => {\n      // fix for https://github.com/mattlewis92/angular-draggable-droppable/issues/61\n      // stop mouse events propagating up the chain\n      if (pointerDownEvent.event.stopPropagation && !this.scrollContainer) {\n        pointerDownEvent.event.stopPropagation();\n      } // hack to prevent text getting selected in safari while dragging\n\n      /** @type {?} */\n\n\n      const globalDragStyle = this.renderer.createElement('style');\n      this.renderer.setAttribute(globalDragStyle, 'type', 'text/css');\n      this.renderer.appendChild(globalDragStyle, this.renderer.createText(`\n          body * {\n           -moz-user-select: none;\n           -ms-user-select: none;\n           -webkit-user-select: none;\n           user-select: none;\n          }\n        `));\n      requestAnimationFrame(\n      /**\n      * @return {?}\n      */\n      () => {\n        this.document.head.appendChild(globalDragStyle);\n      });\n      /** @type {?} */\n\n      const startScrollPosition = this.getScrollPosition();\n      /** @type {?} */\n\n      const scrollContainerScroll$ = new Observable(\n      /**\n      * @param {?} observer\n      * @return {?}\n      */\n      observer => {\n        /** @type {?} */\n        const scrollContainer = this.scrollContainer ? this.scrollContainer.elementRef.nativeElement : 'window';\n        return this.renderer.listen(scrollContainer, 'scroll',\n        /**\n        * @param {?} e\n        * @return {?}\n        */\n        e => observer.next(e));\n      }).pipe(startWith(startScrollPosition), map(\n      /**\n      * @return {?}\n      */\n      () => this.getScrollPosition()));\n      /** @type {?} */\n\n      const currentDrag$ = new Subject();\n      /** @type {?} */\n\n      const cancelDrag$ = new ReplaySubject();\n      this.zone.run(\n      /**\n      * @return {?}\n      */\n      () => {\n        this.dragPointerDown.next({\n          x: 0,\n          y: 0\n        });\n      });\n      /** @type {?} */\n\n      const dragComplete$ = merge(this.pointerUp$, this.pointerDown$, cancelDrag$, this.destroy$).pipe(share());\n      /** @type {?} */\n\n      const pointerMove = combineLatest([this.pointerMove$, scrollContainerScroll$]).pipe(map(\n      /**\n      * @param {?} __0\n      * @return {?}\n      */\n      ([pointerMoveEvent, scroll]) => {\n        return {\n          currentDrag$,\n          transformX: pointerMoveEvent.clientX - pointerDownEvent.clientX,\n          transformY: pointerMoveEvent.clientY - pointerDownEvent.clientY,\n          clientX: pointerMoveEvent.clientX,\n          clientY: pointerMoveEvent.clientY,\n          scrollLeft: scroll.left,\n          scrollTop: scroll.top,\n          target: pointerMoveEvent.event.target\n        };\n      }), map(\n      /**\n      * @param {?} moveData\n      * @return {?}\n      */\n      moveData => {\n        if (this.dragSnapGrid.x) {\n          moveData.transformX = Math.round(moveData.transformX / this.dragSnapGrid.x) * this.dragSnapGrid.x;\n        }\n\n        if (this.dragSnapGrid.y) {\n          moveData.transformY = Math.round(moveData.transformY / this.dragSnapGrid.y) * this.dragSnapGrid.y;\n        }\n\n        return moveData;\n      }), map(\n      /**\n      * @param {?} moveData\n      * @return {?}\n      */\n      moveData => {\n        if (!this.dragAxis.x) {\n          moveData.transformX = 0;\n        }\n\n        if (!this.dragAxis.y) {\n          moveData.transformY = 0;\n        }\n\n        return moveData;\n      }), map(\n      /**\n      * @param {?} moveData\n      * @return {?}\n      */\n      moveData => {\n        /** @type {?} */\n        const scrollX = moveData.scrollLeft - startScrollPosition.left;\n        /** @type {?} */\n\n        const scrollY = moveData.scrollTop - startScrollPosition.top;\n        return Object.assign({}, moveData, {\n          x: moveData.transformX + scrollX,\n          y: moveData.transformY + scrollY\n        });\n      }), filter(\n      /**\n      * @param {?} __0\n      * @return {?}\n      */\n      ({\n        x,\n        y,\n        transformX,\n        transformY\n      }) => !this.validateDrag || this.validateDrag({\n        x,\n        y,\n        transform: {\n          x: transformX,\n          y: transformY\n        }\n      })), takeUntil(dragComplete$), share());\n      /** @type {?} */\n\n      const dragStarted$ = pointerMove.pipe(take(1), share());\n      /** @type {?} */\n\n      const dragEnded$ = pointerMove.pipe(takeLast(1), share());\n      dragStarted$.subscribe(\n      /**\n      * @param {?} __0\n      * @return {?}\n      */\n      ({\n        clientX,\n        clientY,\n        x,\n        y\n      }) => {\n        this.zone.run(\n        /**\n        * @return {?}\n        */\n        () => {\n          this.dragStart.next({\n            cancelDrag$\n          });\n        });\n        this.scroller = autoScroll([this.scrollContainer ? this.scrollContainer.elementRef.nativeElement : this.document.defaultView], Object.assign({}, this.autoScroll, {\n          /**\n          * @return {?}\n          */\n          autoScroll() {\n            return true;\n          }\n\n        }));\n        addClass(this.renderer, this.element, this.dragActiveClass);\n\n        if (this.ghostDragEnabled) {\n          /** @type {?} */\n          const rect = this.element.nativeElement.getBoundingClientRect();\n          /** @type {?} */\n\n          const clone =\n          /** @type {?} */\n          this.element.nativeElement.cloneNode(true);\n\n          if (!this.showOriginalElementWhileDragging) {\n            this.renderer.setStyle(this.element.nativeElement, 'visibility', 'hidden');\n          }\n\n          if (this.ghostElementAppendTo) {\n            this.ghostElementAppendTo.appendChild(clone);\n          } else {\n            /** @type {?} */\n            this.element.nativeElement.parentNode.insertBefore(clone, this.element.nativeElement.nextSibling);\n          }\n\n          this.ghostElement = clone;\n          this.document.body.style.cursor = this.dragCursor;\n          this.setElementStyles(clone, {\n            position: 'fixed',\n            top: `${rect.top}px`,\n            left: `${rect.left}px`,\n            width: `${rect.width}px`,\n            height: `${rect.height}px`,\n            cursor: this.dragCursor,\n            margin: '0',\n            willChange: 'transform',\n            pointerEvents: 'none'\n          });\n\n          if (this.ghostElementTemplate) {\n            /** @type {?} */\n            const viewRef = this.vcr.createEmbeddedView(this.ghostElementTemplate);\n            clone.innerHTML = '';\n            viewRef.rootNodes.filter(\n            /**\n            * @param {?} node\n            * @return {?}\n            */\n            node => node instanceof Node).forEach(\n            /**\n            * @param {?} node\n            * @return {?}\n            */\n            node => {\n              clone.appendChild(node);\n            });\n            dragEnded$.subscribe(\n            /**\n            * @return {?}\n            */\n            () => {\n              this.vcr.remove(this.vcr.indexOf(viewRef));\n            });\n          }\n\n          this.zone.run(\n          /**\n          * @return {?}\n          */\n          () => {\n            this.ghostElementCreated.emit({\n              clientX: clientX - x,\n              clientY: clientY - y,\n              element: clone\n            });\n          });\n          dragEnded$.subscribe(\n          /**\n          * @return {?}\n          */\n          () => {\n            /** @type {?} */\n            clone.parentElement.removeChild(clone);\n            this.ghostElement = null;\n            this.renderer.setStyle(this.element.nativeElement, 'visibility', '');\n          });\n        }\n\n        this.draggableHelper.currentDrag.next(currentDrag$);\n      });\n      dragEnded$.pipe(mergeMap(\n      /**\n      * @param {?} dragEndData\n      * @return {?}\n      */\n      dragEndData => {\n        /** @type {?} */\n        const dragEndData$ = cancelDrag$.pipe(count(), take(1), map(\n        /**\n        * @param {?} calledCount\n        * @return {?}\n        */\n        calledCount => Object.assign({}, dragEndData, {\n          dragCancelled: calledCount > 0\n        })));\n        cancelDrag$.complete();\n        return dragEndData$;\n      })).subscribe(\n      /**\n      * @param {?} __0\n      * @return {?}\n      */\n      ({\n        x,\n        y,\n        dragCancelled\n      }) => {\n        this.scroller.destroy();\n        this.zone.run(\n        /**\n        * @return {?}\n        */\n        () => {\n          this.dragEnd.next({\n            x,\n            y,\n            dragCancelled\n          });\n        });\n        removeClass(this.renderer, this.element, this.dragActiveClass);\n        currentDrag$.complete();\n      });\n      merge(dragComplete$, dragEnded$).pipe(take(1)).subscribe(\n      /**\n      * @return {?}\n      */\n      () => {\n        requestAnimationFrame(\n        /**\n        * @return {?}\n        */\n        () => {\n          this.document.head.removeChild(globalDragStyle);\n        });\n      });\n      return pointerMove;\n    }), share());\n    merge(pointerDragged$.pipe(take(1), map(\n    /**\n    * @param {?} value\n    * @return {?}\n    */\n    value => [, value])), pointerDragged$.pipe(pairwise())).pipe(filter(\n    /**\n    * @param {?} __0\n    * @return {?}\n    */\n    ([previous, next]) => {\n      if (!previous) {\n        return true;\n      }\n\n      return previous.x !== next.x || previous.y !== next.y;\n    }), map(\n    /**\n    * @param {?} __0\n    * @return {?}\n    */\n    ([previous, next]) => next)).subscribe(\n    /**\n    * @param {?} __0\n    * @return {?}\n    */\n    ({\n      x,\n      y,\n      currentDrag$,\n      clientX,\n      clientY,\n      transformX,\n      transformY,\n      target\n    }) => {\n      this.zone.run(\n      /**\n      * @return {?}\n      */\n      () => {\n        this.dragging.next({\n          x,\n          y\n        });\n      });\n      requestAnimationFrame(\n      /**\n      * @return {?}\n      */\n      () => {\n        if (this.ghostElement) {\n          /** @type {?} */\n          const transform = `translate3d(${transformX}px, ${transformY}px, 0px)`;\n          this.setElementStyles(this.ghostElement, {\n            transform,\n            '-webkit-transform': transform,\n            '-ms-transform': transform,\n            '-moz-transform': transform,\n            '-o-transform': transform\n          });\n        }\n      });\n      currentDrag$.next({\n        clientX,\n        clientY,\n        dropData: this.dropData,\n        target\n      });\n    });\n  }\n  /**\n   * @param {?} changes\n   * @return {?}\n   */\n\n\n  ngOnChanges(changes) {\n    if (changes.dragAxis) {\n      this.checkEventListeners();\n    }\n  }\n  /**\n   * @return {?}\n   */\n\n\n  ngOnDestroy() {\n    this.unsubscribeEventListeners();\n    this.pointerDown$.complete();\n    this.pointerMove$.complete();\n    this.pointerUp$.complete();\n    this.destroy$.next();\n  }\n  /**\n   * @private\n   * @return {?}\n   */\n\n\n  checkEventListeners() {\n    /** @type {?} */\n    const canDrag = this.canDrag();\n    /** @type {?} */\n\n    const hasEventListeners = Object.keys(this.eventListenerSubscriptions).length > 0;\n\n    if (canDrag && !hasEventListeners) {\n      this.zone.runOutsideAngular(\n      /**\n      * @return {?}\n      */\n      () => {\n        this.eventListenerSubscriptions.mousedown = this.renderer.listen(this.element.nativeElement, 'mousedown',\n        /**\n        * @param {?} event\n        * @return {?}\n        */\n        event => {\n          this.onMouseDown(event);\n        });\n        this.eventListenerSubscriptions.mouseup = this.renderer.listen('document', 'mouseup',\n        /**\n        * @param {?} event\n        * @return {?}\n        */\n        event => {\n          this.onMouseUp(event);\n        });\n        this.eventListenerSubscriptions.touchstart = this.renderer.listen(this.element.nativeElement, 'touchstart',\n        /**\n        * @param {?} event\n        * @return {?}\n        */\n        event => {\n          this.onTouchStart(event);\n        });\n        this.eventListenerSubscriptions.touchend = this.renderer.listen('document', 'touchend',\n        /**\n        * @param {?} event\n        * @return {?}\n        */\n        event => {\n          this.onTouchEnd(event);\n        });\n        this.eventListenerSubscriptions.touchcancel = this.renderer.listen('document', 'touchcancel',\n        /**\n        * @param {?} event\n        * @return {?}\n        */\n        event => {\n          this.onTouchEnd(event);\n        });\n        this.eventListenerSubscriptions.mouseenter = this.renderer.listen(this.element.nativeElement, 'mouseenter',\n        /**\n        * @return {?}\n        */\n        () => {\n          this.onMouseEnter();\n        });\n        this.eventListenerSubscriptions.mouseleave = this.renderer.listen(this.element.nativeElement, 'mouseleave',\n        /**\n        * @return {?}\n        */\n        () => {\n          this.onMouseLeave();\n        });\n      });\n    } else if (!canDrag && hasEventListeners) {\n      this.unsubscribeEventListeners();\n    }\n  }\n  /**\n   * @private\n   * @param {?} event\n   * @return {?}\n   */\n\n\n  onMouseDown(event) {\n    if (event.button === 0) {\n      if (!this.eventListenerSubscriptions.mousemove) {\n        this.eventListenerSubscriptions.mousemove = this.renderer.listen('document', 'mousemove',\n        /**\n        * @param {?} mouseMoveEvent\n        * @return {?}\n        */\n        mouseMoveEvent => {\n          this.pointerMove$.next({\n            event: mouseMoveEvent,\n            clientX: mouseMoveEvent.clientX,\n            clientY: mouseMoveEvent.clientY\n          });\n        });\n      }\n\n      this.pointerDown$.next({\n        event,\n        clientX: event.clientX,\n        clientY: event.clientY\n      });\n    }\n  }\n  /**\n   * @private\n   * @param {?} event\n   * @return {?}\n   */\n\n\n  onMouseUp(event) {\n    if (event.button === 0) {\n      if (this.eventListenerSubscriptions.mousemove) {\n        this.eventListenerSubscriptions.mousemove();\n        delete this.eventListenerSubscriptions.mousemove;\n      }\n\n      this.pointerUp$.next({\n        event,\n        clientX: event.clientX,\n        clientY: event.clientY\n      });\n    }\n  }\n  /**\n   * @private\n   * @param {?} event\n   * @return {?}\n   */\n\n\n  onTouchStart(event) {\n    /** @type {?} */\n    let startScrollPosition;\n    /** @type {?} */\n\n    let isDragActivated;\n    /** @type {?} */\n\n    let hasContainerScrollbar;\n\n    if (this.scrollContainer && this.scrollContainer.activeLongPressDrag || this.touchStartLongPress) {\n      this.timeLongPress.timerBegin = Date.now();\n      isDragActivated = false;\n      hasContainerScrollbar = this.hasScrollbar();\n      startScrollPosition = this.getScrollPosition();\n    }\n\n    if (!this.eventListenerSubscriptions.touchmove) {\n      /** @type {?} */\n      const contextMenuListener = fromEvent(this.document, 'contextmenu').subscribe(\n      /**\n      * @param {?} e\n      * @return {?}\n      */\n      e => {\n        e.preventDefault();\n      });\n      /** @type {?} */\n\n      const touchMoveListener = fromEvent(this.document, 'touchmove', {\n        passive: false\n      }).subscribe(\n      /**\n      * @param {?} touchMoveEvent\n      * @return {?}\n      */\n      touchMoveEvent => {\n        if ((this.scrollContainer && this.scrollContainer.activeLongPressDrag || this.touchStartLongPress) && !isDragActivated && hasContainerScrollbar) {\n          isDragActivated = this.shouldBeginDrag(event, touchMoveEvent, startScrollPosition);\n        }\n\n        if ((!this.scrollContainer || !this.scrollContainer.activeLongPressDrag) && !this.touchStartLongPress || !hasContainerScrollbar || isDragActivated) {\n          touchMoveEvent.preventDefault();\n          this.pointerMove$.next({\n            event: touchMoveEvent,\n            clientX: touchMoveEvent.targetTouches[0].clientX,\n            clientY: touchMoveEvent.targetTouches[0].clientY\n          });\n        }\n      });\n\n      this.eventListenerSubscriptions.touchmove =\n      /**\n      * @return {?}\n      */\n      () => {\n        contextMenuListener.unsubscribe();\n        touchMoveListener.unsubscribe();\n      };\n    }\n\n    this.pointerDown$.next({\n      event,\n      clientX: event.touches[0].clientX,\n      clientY: event.touches[0].clientY\n    });\n  }\n  /**\n   * @private\n   * @param {?} event\n   * @return {?}\n   */\n\n\n  onTouchEnd(event) {\n    if (this.eventListenerSubscriptions.touchmove) {\n      this.eventListenerSubscriptions.touchmove();\n      delete this.eventListenerSubscriptions.touchmove;\n\n      if (this.scrollContainer && this.scrollContainer.activeLongPressDrag || this.touchStartLongPress) {\n        this.enableScroll();\n      }\n    }\n\n    this.pointerUp$.next({\n      event,\n      clientX: event.changedTouches[0].clientX,\n      clientY: event.changedTouches[0].clientY\n    });\n  }\n  /**\n   * @private\n   * @return {?}\n   */\n\n\n  onMouseEnter() {\n    this.setCursor(this.dragCursor);\n  }\n  /**\n   * @private\n   * @return {?}\n   */\n\n\n  onMouseLeave() {\n    this.setCursor('');\n  }\n  /**\n   * @private\n   * @return {?}\n   */\n\n\n  canDrag() {\n    return this.dragAxis.x || this.dragAxis.y;\n  }\n  /**\n   * @private\n   * @param {?} value\n   * @return {?}\n   */\n\n\n  setCursor(value) {\n    if (!this.eventListenerSubscriptions.mousemove) {\n      this.renderer.setStyle(this.element.nativeElement, 'cursor', value);\n    }\n  }\n  /**\n   * @private\n   * @return {?}\n   */\n\n\n  unsubscribeEventListeners() {\n    Object.keys(this.eventListenerSubscriptions).forEach(\n    /**\n    * @param {?} type\n    * @return {?}\n    */\n    type => {\n      /** @type {?} */\n      this.eventListenerSubscriptions[type]();\n      delete\n      /** @type {?} */\n      this.eventListenerSubscriptions[type];\n    });\n  }\n  /**\n   * @private\n   * @param {?} element\n   * @param {?} styles\n   * @return {?}\n   */\n\n\n  setElementStyles(element, styles) {\n    Object.keys(styles).forEach(\n    /**\n    * @param {?} key\n    * @return {?}\n    */\n    key => {\n      this.renderer.setStyle(element, key, styles[key]);\n    });\n  }\n  /**\n   * @private\n   * @return {?}\n   */\n\n\n  getScrollElement() {\n    if (this.scrollContainer) {\n      return this.scrollContainer.elementRef.nativeElement;\n    } else {\n      return this.document.body;\n    }\n  }\n  /**\n   * @private\n   * @return {?}\n   */\n\n\n  getScrollPosition() {\n    if (this.scrollContainer) {\n      return {\n        top: this.scrollContainer.elementRef.nativeElement.scrollTop,\n        left: this.scrollContainer.elementRef.nativeElement.scrollLeft\n      };\n    } else {\n      return {\n        top: window.pageYOffset || this.document.documentElement.scrollTop,\n        left: window.pageXOffset || this.document.documentElement.scrollLeft\n      };\n    }\n  }\n  /**\n   * @private\n   * @param {?} event\n   * @param {?} touchMoveEvent\n   * @param {?} startScrollPosition\n   * @return {?}\n   */\n\n\n  shouldBeginDrag(event, touchMoveEvent, startScrollPosition) {\n    /** @type {?} */\n    const moveScrollPosition = this.getScrollPosition();\n    /** @type {?} */\n\n    const deltaScroll = {\n      top: Math.abs(moveScrollPosition.top - startScrollPosition.top),\n      left: Math.abs(moveScrollPosition.left - startScrollPosition.left)\n    };\n    /** @type {?} */\n\n    const deltaX = Math.abs(touchMoveEvent.targetTouches[0].clientX - event.touches[0].clientX) - deltaScroll.left;\n    /** @type {?} */\n\n    const deltaY = Math.abs(touchMoveEvent.targetTouches[0].clientY - event.touches[0].clientY) - deltaScroll.top;\n    /** @type {?} */\n\n    const deltaTotal = deltaX + deltaY;\n    /** @type {?} */\n\n    const longPressConfig = this.touchStartLongPress ? this.touchStartLongPress :\n    /* istanbul ignore next */\n    {\n      delta: this.scrollContainer.longPressConfig.delta,\n      delay: this.scrollContainer.longPressConfig.duration\n    };\n\n    if (deltaTotal > longPressConfig.delta || deltaScroll.top > 0 || deltaScroll.left > 0) {\n      this.timeLongPress.timerBegin = Date.now();\n    }\n\n    this.timeLongPress.timerEnd = Date.now();\n    /** @type {?} */\n\n    const duration = this.timeLongPress.timerEnd - this.timeLongPress.timerBegin;\n\n    if (duration >= longPressConfig.delay) {\n      this.disableScroll();\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * @private\n   * @return {?}\n   */\n\n\n  enableScroll() {\n    if (this.scrollContainer) {\n      this.renderer.setStyle(this.scrollContainer.elementRef.nativeElement, 'overflow', '');\n    }\n\n    this.renderer.setStyle(this.document.body, 'overflow', '');\n  }\n  /**\n   * @private\n   * @return {?}\n   */\n\n\n  disableScroll() {\n    /* istanbul ignore next */\n    if (this.scrollContainer) {\n      this.renderer.setStyle(this.scrollContainer.elementRef.nativeElement, 'overflow', 'hidden');\n    }\n\n    this.renderer.setStyle(this.document.body, 'overflow', 'hidden');\n  }\n  /**\n   * @private\n   * @return {?}\n   */\n\n\n  hasScrollbar() {\n    /** @type {?} */\n    const scrollContainer = this.getScrollElement();\n    /** @type {?} */\n\n    const containerHasHorizontalScroll = scrollContainer.scrollWidth > scrollContainer.clientWidth;\n    /** @type {?} */\n\n    const containerHasVerticalScroll = scrollContainer.scrollHeight > scrollContainer.clientHeight;\n    return containerHasHorizontalScroll || containerHasVerticalScroll;\n  }\n\n}\n\nDraggableDirective.ɵfac = function DraggableDirective_Factory(t) {\n  return new (t || DraggableDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(DraggableHelper), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(DraggableScrollContainerDirective, 8), ɵngcc0.ɵɵdirectiveInject(DOCUMENT));\n};\n\nDraggableDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n  type: DraggableDirective,\n  selectors: [[\"\", \"mwlDraggable\", \"\"]],\n  inputs: {\n    dragAxis: \"dragAxis\",\n    dragSnapGrid: \"dragSnapGrid\",\n    ghostDragEnabled: \"ghostDragEnabled\",\n    showOriginalElementWhileDragging: \"showOriginalElementWhileDragging\",\n    dragCursor: \"dragCursor\",\n    autoScroll: \"autoScroll\",\n    dropData: \"dropData\",\n    validateDrag: \"validateDrag\",\n    dragActiveClass: \"dragActiveClass\",\n    ghostElementAppendTo: \"ghostElementAppendTo\",\n    ghostElementTemplate: \"ghostElementTemplate\",\n    touchStartLongPress: \"touchStartLongPress\"\n  },\n  outputs: {\n    dragPointerDown: \"dragPointerDown\",\n    dragStart: \"dragStart\",\n    ghostElementCreated: \"ghostElementCreated\",\n    dragging: \"dragging\",\n    dragEnd: \"dragEnd\"\n  },\n  features: [ɵngcc0.ɵɵNgOnChangesFeature]\n});\n/** @nocollapse */\n\nDraggableDirective.ctorParameters = () => [{\n  type: ElementRef\n}, {\n  type: Renderer2\n}, {\n  type: DraggableHelper\n}, {\n  type: NgZone\n}, {\n  type: ViewContainerRef\n}, {\n  type: DraggableScrollContainerDirective,\n  decorators: [{\n    type: Optional\n  }]\n}, {\n  type: undefined,\n  decorators: [{\n    type: Inject,\n    args: [DOCUMENT]\n  }]\n}];\n\nDraggableDirective.propDecorators = {\n  dropData: [{\n    type: Input\n  }],\n  dragAxis: [{\n    type: Input\n  }],\n  dragSnapGrid: [{\n    type: Input\n  }],\n  ghostDragEnabled: [{\n    type: Input\n  }],\n  showOriginalElementWhileDragging: [{\n    type: Input\n  }],\n  validateDrag: [{\n    type: Input\n  }],\n  dragCursor: [{\n    type: Input\n  }],\n  dragActiveClass: [{\n    type: Input\n  }],\n  ghostElementAppendTo: [{\n    type: Input\n  }],\n  ghostElementTemplate: [{\n    type: Input\n  }],\n  touchStartLongPress: [{\n    type: Input\n  }],\n  autoScroll: [{\n    type: Input\n  }],\n  dragPointerDown: [{\n    type: Output\n  }],\n  dragStart: [{\n    type: Output\n  }],\n  ghostElementCreated: [{\n    type: Output\n  }],\n  dragging: [{\n    type: Output\n  }],\n  dragEnd: [{\n    type: Output\n  }]\n};\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DraggableDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[mwlDraggable]'\n    }]\n  }], function () {\n    return [{\n      type: ɵngcc0.ElementRef\n    }, {\n      type: ɵngcc0.Renderer2\n    }, {\n      type: DraggableHelper\n    }, {\n      type: ɵngcc0.NgZone\n    }, {\n      type: ɵngcc0.ViewContainerRef\n    }, {\n      type: DraggableScrollContainerDirective,\n      decorators: [{\n        type: Optional\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [DOCUMENT]\n      }]\n    }];\n  }, {\n    dragAxis: [{\n      type: Input\n    }],\n    dragSnapGrid: [{\n      type: Input\n    }],\n    ghostDragEnabled: [{\n      type: Input\n    }],\n    showOriginalElementWhileDragging: [{\n      type: Input\n    }],\n    dragCursor: [{\n      type: Input\n    }],\n    autoScroll: [{\n      type: Input\n    }],\n    dragPointerDown: [{\n      type: Output\n    }],\n    dragStart: [{\n      type: Output\n    }],\n    ghostElementCreated: [{\n      type: Output\n    }],\n    dragging: [{\n      type: Output\n    }],\n    dragEnd: [{\n      type: Output\n    }],\n    dropData: [{\n      type: Input\n    }],\n    validateDrag: [{\n      type: Input\n    }],\n    dragActiveClass: [{\n      type: Input\n    }],\n    ghostElementAppendTo: [{\n      type: Input\n    }],\n    ghostElementTemplate: [{\n      type: Input\n    }],\n    touchStartLongPress: [{\n      type: Input\n    }]\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} clientX\n * @param {?} clientY\n * @param {?} rect\n * @return {?}\n */\n\n\nfunction isCoordinateWithinRectangle(clientX, clientY, rect) {\n  return clientX >= rect.left && clientX <= rect.right && clientY >= rect.top && clientY <= rect.bottom;\n}\n\nclass DroppableDirective {\n  /**\n   * @param {?} element\n   * @param {?} draggableHelper\n   * @param {?} zone\n   * @param {?} renderer\n   * @param {?} scrollContainer\n   */\n  constructor(element, draggableHelper, zone, renderer, scrollContainer) {\n    this.element = element;\n    this.draggableHelper = draggableHelper;\n    this.zone = zone;\n    this.renderer = renderer;\n    this.scrollContainer = scrollContainer;\n    /**\n     * Called when a draggable element starts overlapping the element\n     */\n\n    this.dragEnter = new EventEmitter();\n    /**\n     * Called when a draggable element stops overlapping the element\n     */\n\n    this.dragLeave = new EventEmitter();\n    /**\n     * Called when a draggable element is moved over the element\n     */\n\n    this.dragOver = new EventEmitter();\n    /**\n     * Called when a draggable element is dropped on this element\n     */\n\n    this.drop = new EventEmitter(); // tslint:disable-line no-output-named-after-standard-event\n  }\n  /**\n   * @return {?}\n   */\n\n\n  ngOnInit() {\n    this.currentDragSubscription = this.draggableHelper.currentDrag.subscribe(\n    /**\n    * @param {?} drag$\n    * @return {?}\n    */\n    drag$ => {\n      addClass(this.renderer, this.element, this.dragActiveClass);\n      /** @type {?} */\n\n      const droppableElement = {\n        updateCache: true\n      };\n      /** @type {?} */\n\n      const deregisterScrollListener = this.renderer.listen(this.scrollContainer ? this.scrollContainer.elementRef.nativeElement : 'window', 'scroll',\n      /**\n      * @return {?}\n      */\n      () => {\n        droppableElement.updateCache = true;\n      });\n      /** @type {?} */\n\n      let currentDragDropData;\n      /** @type {?} */\n\n      const overlaps$ = drag$.pipe(map(\n      /**\n      * @param {?} __0\n      * @return {?}\n      */\n      ({\n        clientX,\n        clientY,\n        dropData,\n        target\n      }) => {\n        currentDragDropData = dropData;\n\n        if (droppableElement.updateCache) {\n          droppableElement.rect = this.element.nativeElement.getBoundingClientRect();\n\n          if (this.scrollContainer) {\n            droppableElement.scrollContainerRect = this.scrollContainer.elementRef.nativeElement.getBoundingClientRect();\n          }\n\n          droppableElement.updateCache = false;\n        }\n        /** @type {?} */\n\n\n        const isWithinElement = isCoordinateWithinRectangle(clientX, clientY,\n        /** @type {?} */\n        droppableElement.rect);\n        /** @type {?} */\n\n        const isDropAllowed = !this.validateDrop || this.validateDrop({\n          clientX,\n          clientY,\n          target\n        });\n\n        if (droppableElement.scrollContainerRect) {\n          return isWithinElement && isDropAllowed && isCoordinateWithinRectangle(clientX, clientY,\n          /** @type {?} */\n          droppableElement.scrollContainerRect);\n        } else {\n          return isWithinElement && isDropAllowed;\n        }\n      }));\n      /** @type {?} */\n\n      const overlapsChanged$ = overlaps$.pipe(distinctUntilChanged());\n      /** @type {?} */\n\n      let dragOverActive;\n      overlapsChanged$.pipe(filter(\n      /**\n      * @param {?} overlapsNow\n      * @return {?}\n      */\n      overlapsNow => overlapsNow)).subscribe(\n      /**\n      * @return {?}\n      */\n      () => {\n        dragOverActive = true;\n        addClass(this.renderer, this.element, this.dragOverClass);\n        this.zone.run(\n        /**\n        * @return {?}\n        */\n        () => {\n          this.dragEnter.next({\n            dropData: currentDragDropData\n          });\n        });\n      });\n      overlaps$.pipe(filter(\n      /**\n      * @param {?} overlapsNow\n      * @return {?}\n      */\n      overlapsNow => overlapsNow)).subscribe(\n      /**\n      * @return {?}\n      */\n      () => {\n        this.zone.run(\n        /**\n        * @return {?}\n        */\n        () => {\n          this.dragOver.next({\n            dropData: currentDragDropData\n          });\n        });\n      });\n      overlapsChanged$.pipe(pairwise(), filter(\n      /**\n      * @param {?} __0\n      * @return {?}\n      */\n      ([didOverlap, overlapsNow]) => didOverlap && !overlapsNow)).subscribe(\n      /**\n      * @return {?}\n      */\n      () => {\n        dragOverActive = false;\n        removeClass(this.renderer, this.element, this.dragOverClass);\n        this.zone.run(\n        /**\n        * @return {?}\n        */\n        () => {\n          this.dragLeave.next({\n            dropData: currentDragDropData\n          });\n        });\n      });\n      drag$.subscribe({\n        complete:\n        /**\n        * @return {?}\n        */\n        () => {\n          deregisterScrollListener();\n          removeClass(this.renderer, this.element, this.dragActiveClass);\n\n          if (dragOverActive) {\n            removeClass(this.renderer, this.element, this.dragOverClass);\n            this.zone.run(\n            /**\n            * @return {?}\n            */\n            () => {\n              this.drop.next({\n                dropData: currentDragDropData\n              });\n            });\n          }\n        }\n      });\n    });\n  }\n  /**\n   * @return {?}\n   */\n\n\n  ngOnDestroy() {\n    if (this.currentDragSubscription) {\n      this.currentDragSubscription.unsubscribe();\n    }\n  }\n\n}\n\nDroppableDirective.ɵfac = function DroppableDirective_Factory(t) {\n  return new (t || DroppableDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(DraggableHelper), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(DraggableScrollContainerDirective, 8));\n};\n\nDroppableDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n  type: DroppableDirective,\n  selectors: [[\"\", \"mwlDroppable\", \"\"]],\n  inputs: {\n    dragOverClass: \"dragOverClass\",\n    dragActiveClass: \"dragActiveClass\",\n    validateDrop: \"validateDrop\"\n  },\n  outputs: {\n    dragEnter: \"dragEnter\",\n    dragLeave: \"dragLeave\",\n    dragOver: \"dragOver\",\n    drop: \"drop\"\n  }\n});\n/** @nocollapse */\n\nDroppableDirective.ctorParameters = () => [{\n  type: ElementRef\n}, {\n  type: DraggableHelper\n}, {\n  type: NgZone\n}, {\n  type: Renderer2\n}, {\n  type: DraggableScrollContainerDirective,\n  decorators: [{\n    type: Optional\n  }]\n}];\n\nDroppableDirective.propDecorators = {\n  dragOverClass: [{\n    type: Input\n  }],\n  dragActiveClass: [{\n    type: Input\n  }],\n  validateDrop: [{\n    type: Input\n  }],\n  dragEnter: [{\n    type: Output\n  }],\n  dragLeave: [{\n    type: Output\n  }],\n  dragOver: [{\n    type: Output\n  }],\n  drop: [{\n    type: Output\n  }]\n};\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DroppableDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[mwlDroppable]'\n    }]\n  }], function () {\n    return [{\n      type: ɵngcc0.ElementRef\n    }, {\n      type: DraggableHelper\n    }, {\n      type: ɵngcc0.NgZone\n    }, {\n      type: ɵngcc0.Renderer2\n    }, {\n      type: DraggableScrollContainerDirective,\n      decorators: [{\n        type: Optional\n      }]\n    }];\n  }, {\n    dragEnter: [{\n      type: Output\n    }],\n    dragLeave: [{\n      type: Output\n    }],\n    dragOver: [{\n      type: Output\n    }],\n    drop: [{\n      type: Output\n    }],\n    dragOverClass: [{\n      type: Input\n    }],\n    dragActiveClass: [{\n      type: Input\n    }],\n    validateDrop: [{\n      type: Input\n    }]\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nclass DragAndDropModule {}\n\nDragAndDropModule.ɵfac = function DragAndDropModule_Factory(t) {\n  return new (t || DragAndDropModule)();\n};\n\nDragAndDropModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n  type: DragAndDropModule\n});\nDragAndDropModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DragAndDropModule, [{\n    type: NgModule,\n    args: [{\n      declarations: [DraggableDirective, DroppableDirective, DraggableScrollContainerDirective],\n      exports: [DraggableDirective, DroppableDirective, DraggableScrollContainerDirective]\n    }]\n  }], null, null);\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(DragAndDropModule, {\n    declarations: [DraggableDirective, DroppableDirective, DraggableScrollContainerDirective],\n    exports: [DraggableDirective, DroppableDirective, DraggableScrollContainerDirective]\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nexport { DragAndDropModule, DraggableHelper as ɵc, DraggableScrollContainerDirective as ɵd, DraggableDirective as ɵb, DroppableDirective as ɵa };","map":{"version":3,"names":["Subject","Observable","merge","ReplaySubject","combineLatest","fromEvent","DOCUMENT","autoScroll","Injectable","Directive","ElementRef","Input","Renderer2","Output","EventEmitter","NgZone","Inject","ViewContainerRef","Optional","NgModule","defineInjectable","map","mergeMap","takeUntil","take","takeLast","pairwise","share","filter","count","startWith","distinctUntilChanged","ɵngcc0","DraggableHelper","constructor","currentDrag","ɵfac","DraggableHelper_Factory","t","ɵprov","ɵɵdefineInjectable","token","factory","providedIn","ngInjectableDef","ngDevMode","ɵsetClassMetadata","type","args","DraggableScrollContainerDirective","elementRef","activeLongPressDrag","longPressConfig","duration","delta","DraggableScrollContainerDirective_Factory","ɵɵdirectiveInject","ɵdir","ɵɵdefineDirective","selectors","inputs","ctorParameters","propDecorators","selector","addClass","renderer","element","classToAdd","split","forEach","className","nativeElement","removeClass","classToRemove","DraggableDirective","draggableHelper","zone","vcr","scrollContainer","document","dragAxis","x","y","dragSnapGrid","ghostDragEnabled","showOriginalElementWhileDragging","dragCursor","margin","dragPointerDown","dragStart","ghostElementCreated","dragging","dragEnd","pointerDown$","pointerMove$","pointerUp$","eventListenerSubscriptions","destroy$","timeLongPress","timerBegin","timerEnd","ngOnInit","checkEventListeners","pointerDragged$","pipe","canDrag","pointerDownEvent","event","stopPropagation","globalDragStyle","createElement","setAttribute","appendChild","createText","requestAnimationFrame","head","startScrollPosition","getScrollPosition","scrollContainerScroll$","observer","listen","e","next","currentDrag$","cancelDrag$","run","dragComplete$","pointerMove","pointerMoveEvent","scroll","transformX","clientX","transformY","clientY","scrollLeft","left","scrollTop","top","target","moveData","Math","round","scrollX","scrollY","Object","assign","validateDrag","transform","dragStarted$","dragEnded$","subscribe","scroller","defaultView","dragActiveClass","rect","getBoundingClientRect","clone","cloneNode","setStyle","ghostElementAppendTo","parentNode","insertBefore","nextSibling","ghostElement","body","style","cursor","setElementStyles","position","width","height","willChange","pointerEvents","ghostElementTemplate","viewRef","createEmbeddedView","innerHTML","rootNodes","node","Node","remove","indexOf","emit","parentElement","removeChild","dragEndData","dragEndData$","calledCount","dragCancelled","complete","destroy","value","previous","dropData","ngOnChanges","changes","ngOnDestroy","unsubscribeEventListeners","hasEventListeners","keys","length","runOutsideAngular","mousedown","onMouseDown","mouseup","onMouseUp","touchstart","onTouchStart","touchend","onTouchEnd","touchcancel","mouseenter","onMouseEnter","mouseleave","onMouseLeave","button","mousemove","mouseMoveEvent","isDragActivated","hasContainerScrollbar","touchStartLongPress","Date","now","hasScrollbar","touchmove","contextMenuListener","preventDefault","touchMoveListener","passive","touchMoveEvent","shouldBeginDrag","targetTouches","unsubscribe","touches","enableScroll","changedTouches","setCursor","styles","key","getScrollElement","window","pageYOffset","documentElement","pageXOffset","moveScrollPosition","deltaScroll","abs","deltaX","deltaY","deltaTotal","delay","disableScroll","containerHasHorizontalScroll","scrollWidth","clientWidth","containerHasVerticalScroll","scrollHeight","clientHeight","DraggableDirective_Factory","outputs","features","ɵɵNgOnChangesFeature","decorators","undefined","isCoordinateWithinRectangle","right","bottom","DroppableDirective","dragEnter","dragLeave","dragOver","drop","currentDragSubscription","drag$","droppableElement","updateCache","deregisterScrollListener","currentDragDropData","overlaps$","scrollContainerRect","isWithinElement","isDropAllowed","validateDrop","overlapsChanged$","dragOverActive","overlapsNow","dragOverClass","didOverlap","DroppableDirective_Factory","DragAndDropModule","DragAndDropModule_Factory","ɵmod","ɵɵdefineNgModule","ɵinj","ɵɵdefineInjector","declarations","exports","ngJitMode","ɵɵsetNgModuleScope","ɵc","ɵd","ɵb","ɵa"],"sources":["C:/Users/Utilizador/Desktop/PVGym/PVGymAngularClient/ClientApp/node_modules/angular-draggable-droppable/__ivy_ngcc__/fesm2015/angular-draggable-droppable.js"],"sourcesContent":["import { Subject, Observable, merge, ReplaySubject, combineLatest, fromEvent } from 'rxjs';\nimport { DOCUMENT } from '@angular/common';\nimport autoScroll from '@mattlewis92/dom-autoscroller';\nimport { Injectable, Directive, ElementRef, Input, Renderer2, Output, EventEmitter, NgZone, Inject, ViewContainerRef, Optional, NgModule, defineInjectable } from '@angular/core';\nimport { map, mergeMap, takeUntil, take, takeLast, pairwise, share, filter, count, startWith, distinctUntilChanged } from 'rxjs/operators';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nimport * as ɵngcc0 from '@angular/core';\nclass DraggableHelper {\n    constructor() {\n        this.currentDrag = new Subject();\n    }\n}\nDraggableHelper.ɵfac = function DraggableHelper_Factory(t) { return new (t || DraggableHelper)(); };\nDraggableHelper.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: DraggableHelper, factory: DraggableHelper.ɵfac, providedIn: 'root' });\n/** @nocollapse */ DraggableHelper.ngInjectableDef = defineInjectable({ factory: function DraggableHelper_Factory() { return new DraggableHelper(); }, token: DraggableHelper, providedIn: \"root\" });\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DraggableHelper, [{\n        type: Injectable,\n        args: [{\n                providedIn: 'root'\n            }]\n    }], function () { return []; }, null); })();\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * If the window isn't scrollable, then place this on the scrollable container that draggable elements are inside. e.g.\n * ```html\n * <div style=\"overflow: scroll\" mwlDraggableScrollContainer>\n * <div mwlDraggable>Drag me!</div>\n * </div>\n * ```\n */\nclass DraggableScrollContainerDirective {\n    /**\n     * @hidden\n     * @param {?} elementRef\n     */\n    constructor(elementRef) {\n        this.elementRef = elementRef;\n        /**\n         * Trigger the DragStart after a long touch in scrollable container when true\n         * @deprecated will be removed in v5 (use [touchStartLongPress]=\"{delay: 300, delta: 30}\" on the mwlDraggable element instead)\n         */\n        this.activeLongPressDrag = false;\n        /**\n         * Configuration of a long touch\n         * Duration in ms of a long touch before activating DragStart\n         * Delta of the\n         * @deprecated will be removed in v5 (use [touchStartLongPress]=\"{delay: 300, delta: 30}\" on the mwlDraggable element instead)\n         */\n        this.longPressConfig = { duration: 300, delta: 30 };\n    }\n}\nDraggableScrollContainerDirective.ɵfac = function DraggableScrollContainerDirective_Factory(t) { return new (t || DraggableScrollContainerDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };\nDraggableScrollContainerDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: DraggableScrollContainerDirective, selectors: [[\"\", \"mwlDraggableScrollContainer\", \"\"]], inputs: { activeLongPressDrag: \"activeLongPressDrag\", longPressConfig: \"longPressConfig\" } });\n/** @nocollapse */\nDraggableScrollContainerDirective.ctorParameters = () => [\n    { type: ElementRef }\n];\nDraggableScrollContainerDirective.propDecorators = {\n    activeLongPressDrag: [{ type: Input }],\n    longPressConfig: [{ type: Input }]\n};\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DraggableScrollContainerDirective, [{\n        type: Directive,\n        args: [{\n                selector: '[mwlDraggableScrollContainer]'\n            }]\n    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { activeLongPressDrag: [{\n            type: Input\n        }], longPressConfig: [{\n            type: Input\n        }] }); })();\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} renderer\n * @param {?} element\n * @param {?} classToAdd\n * @return {?}\n */\nfunction addClass(renderer, element, classToAdd) {\n    if (classToAdd) {\n        classToAdd\n            .split(' ')\n            .forEach((/**\n         * @param {?} className\n         * @return {?}\n         */\n        (className) => renderer.addClass(element.nativeElement, className)));\n    }\n}\n/**\n * @param {?} renderer\n * @param {?} element\n * @param {?} classToRemove\n * @return {?}\n */\nfunction removeClass(renderer, element, classToRemove) {\n    if (classToRemove) {\n        classToRemove\n            .split(' ')\n            .forEach((/**\n         * @param {?} className\n         * @return {?}\n         */\n        (className) => renderer.removeClass(element.nativeElement, className)));\n    }\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass DraggableDirective {\n    /**\n     * @hidden\n     * @param {?} element\n     * @param {?} renderer\n     * @param {?} draggableHelper\n     * @param {?} zone\n     * @param {?} vcr\n     * @param {?} scrollContainer\n     * @param {?} document\n     */\n    constructor(element, renderer, draggableHelper, zone, vcr, scrollContainer, document) {\n        this.element = element;\n        this.renderer = renderer;\n        this.draggableHelper = draggableHelper;\n        this.zone = zone;\n        this.vcr = vcr;\n        this.scrollContainer = scrollContainer;\n        this.document = document;\n        /**\n         * The axis along which the element is draggable\n         */\n        this.dragAxis = { x: true, y: true };\n        /**\n         * Snap all drags to an x / y grid\n         */\n        this.dragSnapGrid = {};\n        /**\n         * Show a ghost element that shows the drag when dragging\n         */\n        this.ghostDragEnabled = true;\n        /**\n         * Show the original element when ghostDragEnabled is true\n         */\n        this.showOriginalElementWhileDragging = false;\n        /**\n         * The cursor to use when hovering over a draggable element\n         */\n        this.dragCursor = '';\n        /*\n           * Options used to control the behaviour of auto scrolling: https://www.npmjs.com/package/dom-autoscroller\n           */\n        this.autoScroll = {\n            margin: 20,\n        };\n        /**\n         * Called when the element can be dragged along one axis and has the mouse or pointer device pressed on it\n         */\n        this.dragPointerDown = new EventEmitter();\n        /**\n         * Called when the element has started to be dragged.\n         * Only called after at least one mouse or touch move event.\n         * If you call $event.cancelDrag$.emit() it will cancel the current drag\n         */\n        this.dragStart = new EventEmitter();\n        /**\n         * Called after the ghost element has been created\n         */\n        this.ghostElementCreated = new EventEmitter();\n        /**\n         * Called when the element is being dragged\n         */\n        this.dragging = new EventEmitter();\n        /**\n         * Called after the element is dragged\n         */\n        this.dragEnd = new EventEmitter();\n        /**\n         * @hidden\n         */\n        this.pointerDown$ = new Subject();\n        /**\n         * @hidden\n         */\n        this.pointerMove$ = new Subject();\n        /**\n         * @hidden\n         */\n        this.pointerUp$ = new Subject();\n        this.eventListenerSubscriptions = {};\n        this.destroy$ = new Subject();\n        this.timeLongPress = { timerBegin: 0, timerEnd: 0 };\n    }\n    /**\n     * @return {?}\n     */\n    ngOnInit() {\n        this.checkEventListeners();\n        /** @type {?} */\n        const pointerDragged$ = this.pointerDown$.pipe(filter((/**\n         * @return {?}\n         */\n        () => this.canDrag())), mergeMap((/**\n         * @param {?} pointerDownEvent\n         * @return {?}\n         */\n        (pointerDownEvent) => {\n            // fix for https://github.com/mattlewis92/angular-draggable-droppable/issues/61\n            // stop mouse events propagating up the chain\n            if (pointerDownEvent.event.stopPropagation && !this.scrollContainer) {\n                pointerDownEvent.event.stopPropagation();\n            }\n            // hack to prevent text getting selected in safari while dragging\n            /** @type {?} */\n            const globalDragStyle = this.renderer.createElement('style');\n            this.renderer.setAttribute(globalDragStyle, 'type', 'text/css');\n            this.renderer.appendChild(globalDragStyle, this.renderer.createText(`\n          body * {\n           -moz-user-select: none;\n           -ms-user-select: none;\n           -webkit-user-select: none;\n           user-select: none;\n          }\n        `));\n            requestAnimationFrame((/**\n             * @return {?}\n             */\n            () => {\n                this.document.head.appendChild(globalDragStyle);\n            }));\n            /** @type {?} */\n            const startScrollPosition = this.getScrollPosition();\n            /** @type {?} */\n            const scrollContainerScroll$ = new Observable((/**\n             * @param {?} observer\n             * @return {?}\n             */\n            (observer) => {\n                /** @type {?} */\n                const scrollContainer = this.scrollContainer\n                    ? this.scrollContainer.elementRef.nativeElement\n                    : 'window';\n                return this.renderer.listen(scrollContainer, 'scroll', (/**\n                 * @param {?} e\n                 * @return {?}\n                 */\n                (e) => observer.next(e)));\n            })).pipe(startWith(startScrollPosition), map((/**\n             * @return {?}\n             */\n            () => this.getScrollPosition())));\n            /** @type {?} */\n            const currentDrag$ = new Subject();\n            /** @type {?} */\n            const cancelDrag$ = new ReplaySubject();\n            this.zone.run((/**\n             * @return {?}\n             */\n            () => {\n                this.dragPointerDown.next({ x: 0, y: 0 });\n            }));\n            /** @type {?} */\n            const dragComplete$ = merge(this.pointerUp$, this.pointerDown$, cancelDrag$, this.destroy$).pipe(share());\n            /** @type {?} */\n            const pointerMove = combineLatest([\n                this.pointerMove$,\n                scrollContainerScroll$,\n            ]).pipe(map((/**\n             * @param {?} __0\n             * @return {?}\n             */\n            ([pointerMoveEvent, scroll]) => {\n                return {\n                    currentDrag$,\n                    transformX: pointerMoveEvent.clientX - pointerDownEvent.clientX,\n                    transformY: pointerMoveEvent.clientY - pointerDownEvent.clientY,\n                    clientX: pointerMoveEvent.clientX,\n                    clientY: pointerMoveEvent.clientY,\n                    scrollLeft: scroll.left,\n                    scrollTop: scroll.top,\n                    target: pointerMoveEvent.event.target,\n                };\n            })), map((/**\n             * @param {?} moveData\n             * @return {?}\n             */\n            (moveData) => {\n                if (this.dragSnapGrid.x) {\n                    moveData.transformX =\n                        Math.round(moveData.transformX / this.dragSnapGrid.x) *\n                            this.dragSnapGrid.x;\n                }\n                if (this.dragSnapGrid.y) {\n                    moveData.transformY =\n                        Math.round(moveData.transformY / this.dragSnapGrid.y) *\n                            this.dragSnapGrid.y;\n                }\n                return moveData;\n            })), map((/**\n             * @param {?} moveData\n             * @return {?}\n             */\n            (moveData) => {\n                if (!this.dragAxis.x) {\n                    moveData.transformX = 0;\n                }\n                if (!this.dragAxis.y) {\n                    moveData.transformY = 0;\n                }\n                return moveData;\n            })), map((/**\n             * @param {?} moveData\n             * @return {?}\n             */\n            (moveData) => {\n                /** @type {?} */\n                const scrollX = moveData.scrollLeft - startScrollPosition.left;\n                /** @type {?} */\n                const scrollY = moveData.scrollTop - startScrollPosition.top;\n                return Object.assign({}, moveData, { x: moveData.transformX + scrollX, y: moveData.transformY + scrollY });\n            })), filter((/**\n             * @param {?} __0\n             * @return {?}\n             */\n            ({ x, y, transformX, transformY }) => !this.validateDrag ||\n                this.validateDrag({\n                    x,\n                    y,\n                    transform: { x: transformX, y: transformY },\n                }))), takeUntil(dragComplete$), share());\n            /** @type {?} */\n            const dragStarted$ = pointerMove.pipe(take(1), share());\n            /** @type {?} */\n            const dragEnded$ = pointerMove.pipe(takeLast(1), share());\n            dragStarted$.subscribe((/**\n             * @param {?} __0\n             * @return {?}\n             */\n            ({ clientX, clientY, x, y }) => {\n                this.zone.run((/**\n                 * @return {?}\n                 */\n                () => {\n                    this.dragStart.next({ cancelDrag$ });\n                }));\n                this.scroller = autoScroll([\n                    this.scrollContainer\n                        ? this.scrollContainer.elementRef.nativeElement\n                        : this.document.defaultView,\n                ], Object.assign({}, this.autoScroll, { /**\n                     * @return {?}\n                     */\n                    autoScroll() {\n                        return true;\n                    } }));\n                addClass(this.renderer, this.element, this.dragActiveClass);\n                if (this.ghostDragEnabled) {\n                    /** @type {?} */\n                    const rect = this.element.nativeElement.getBoundingClientRect();\n                    /** @type {?} */\n                    const clone = (/** @type {?} */ (this.element.nativeElement.cloneNode(true)));\n                    if (!this.showOriginalElementWhileDragging) {\n                        this.renderer.setStyle(this.element.nativeElement, 'visibility', 'hidden');\n                    }\n                    if (this.ghostElementAppendTo) {\n                        this.ghostElementAppendTo.appendChild(clone);\n                    }\n                    else {\n                        (/** @type {?} */ (this.element.nativeElement.parentNode)).insertBefore(clone, this.element.nativeElement.nextSibling);\n                    }\n                    this.ghostElement = clone;\n                    this.document.body.style.cursor = this.dragCursor;\n                    this.setElementStyles(clone, {\n                        position: 'fixed',\n                        top: `${rect.top}px`,\n                        left: `${rect.left}px`,\n                        width: `${rect.width}px`,\n                        height: `${rect.height}px`,\n                        cursor: this.dragCursor,\n                        margin: '0',\n                        willChange: 'transform',\n                        pointerEvents: 'none',\n                    });\n                    if (this.ghostElementTemplate) {\n                        /** @type {?} */\n                        const viewRef = this.vcr.createEmbeddedView(this.ghostElementTemplate);\n                        clone.innerHTML = '';\n                        viewRef.rootNodes\n                            .filter((/**\n                         * @param {?} node\n                         * @return {?}\n                         */\n                        (node) => node instanceof Node))\n                            .forEach((/**\n                         * @param {?} node\n                         * @return {?}\n                         */\n                        (node) => {\n                            clone.appendChild(node);\n                        }));\n                        dragEnded$.subscribe((/**\n                         * @return {?}\n                         */\n                        () => {\n                            this.vcr.remove(this.vcr.indexOf(viewRef));\n                        }));\n                    }\n                    this.zone.run((/**\n                     * @return {?}\n                     */\n                    () => {\n                        this.ghostElementCreated.emit({\n                            clientX: clientX - x,\n                            clientY: clientY - y,\n                            element: clone,\n                        });\n                    }));\n                    dragEnded$.subscribe((/**\n                     * @return {?}\n                     */\n                    () => {\n                        (/** @type {?} */ (clone.parentElement)).removeChild(clone);\n                        this.ghostElement = null;\n                        this.renderer.setStyle(this.element.nativeElement, 'visibility', '');\n                    }));\n                }\n                this.draggableHelper.currentDrag.next(currentDrag$);\n            }));\n            dragEnded$\n                .pipe(mergeMap((/**\n             * @param {?} dragEndData\n             * @return {?}\n             */\n            (dragEndData) => {\n                /** @type {?} */\n                const dragEndData$ = cancelDrag$.pipe(count(), take(1), map((/**\n                 * @param {?} calledCount\n                 * @return {?}\n                 */\n                (calledCount) => (Object.assign({}, dragEndData, { dragCancelled: calledCount > 0 })))));\n                cancelDrag$.complete();\n                return dragEndData$;\n            })))\n                .subscribe((/**\n             * @param {?} __0\n             * @return {?}\n             */\n            ({ x, y, dragCancelled }) => {\n                this.scroller.destroy();\n                this.zone.run((/**\n                 * @return {?}\n                 */\n                () => {\n                    this.dragEnd.next({ x, y, dragCancelled });\n                }));\n                removeClass(this.renderer, this.element, this.dragActiveClass);\n                currentDrag$.complete();\n            }));\n            merge(dragComplete$, dragEnded$)\n                .pipe(take(1))\n                .subscribe((/**\n             * @return {?}\n             */\n            () => {\n                requestAnimationFrame((/**\n                 * @return {?}\n                 */\n                () => {\n                    this.document.head.removeChild(globalDragStyle);\n                }));\n            }));\n            return pointerMove;\n        })), share());\n        merge(pointerDragged$.pipe(take(1), map((/**\n         * @param {?} value\n         * @return {?}\n         */\n        (value) => [, value]))), pointerDragged$.pipe(pairwise()))\n            .pipe(filter((/**\n         * @param {?} __0\n         * @return {?}\n         */\n        ([previous, next]) => {\n            if (!previous) {\n                return true;\n            }\n            return previous.x !== next.x || previous.y !== next.y;\n        })), map((/**\n         * @param {?} __0\n         * @return {?}\n         */\n        ([previous, next]) => next)))\n            .subscribe((/**\n         * @param {?} __0\n         * @return {?}\n         */\n        ({ x, y, currentDrag$, clientX, clientY, transformX, transformY, target, }) => {\n            this.zone.run((/**\n             * @return {?}\n             */\n            () => {\n                this.dragging.next({ x, y });\n            }));\n            requestAnimationFrame((/**\n             * @return {?}\n             */\n            () => {\n                if (this.ghostElement) {\n                    /** @type {?} */\n                    const transform = `translate3d(${transformX}px, ${transformY}px, 0px)`;\n                    this.setElementStyles(this.ghostElement, {\n                        transform,\n                        '-webkit-transform': transform,\n                        '-ms-transform': transform,\n                        '-moz-transform': transform,\n                        '-o-transform': transform,\n                    });\n                }\n            }));\n            currentDrag$.next({\n                clientX,\n                clientY,\n                dropData: this.dropData,\n                target,\n            });\n        }));\n    }\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n    ngOnChanges(changes) {\n        if (changes.dragAxis) {\n            this.checkEventListeners();\n        }\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this.unsubscribeEventListeners();\n        this.pointerDown$.complete();\n        this.pointerMove$.complete();\n        this.pointerUp$.complete();\n        this.destroy$.next();\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n    checkEventListeners() {\n        /** @type {?} */\n        const canDrag = this.canDrag();\n        /** @type {?} */\n        const hasEventListeners = Object.keys(this.eventListenerSubscriptions).length > 0;\n        if (canDrag && !hasEventListeners) {\n            this.zone.runOutsideAngular((/**\n             * @return {?}\n             */\n            () => {\n                this.eventListenerSubscriptions.mousedown = this.renderer.listen(this.element.nativeElement, 'mousedown', (/**\n                 * @param {?} event\n                 * @return {?}\n                 */\n                (event) => {\n                    this.onMouseDown(event);\n                }));\n                this.eventListenerSubscriptions.mouseup = this.renderer.listen('document', 'mouseup', (/**\n                 * @param {?} event\n                 * @return {?}\n                 */\n                (event) => {\n                    this.onMouseUp(event);\n                }));\n                this.eventListenerSubscriptions.touchstart = this.renderer.listen(this.element.nativeElement, 'touchstart', (/**\n                 * @param {?} event\n                 * @return {?}\n                 */\n                (event) => {\n                    this.onTouchStart(event);\n                }));\n                this.eventListenerSubscriptions.touchend = this.renderer.listen('document', 'touchend', (/**\n                 * @param {?} event\n                 * @return {?}\n                 */\n                (event) => {\n                    this.onTouchEnd(event);\n                }));\n                this.eventListenerSubscriptions.touchcancel = this.renderer.listen('document', 'touchcancel', (/**\n                 * @param {?} event\n                 * @return {?}\n                 */\n                (event) => {\n                    this.onTouchEnd(event);\n                }));\n                this.eventListenerSubscriptions.mouseenter = this.renderer.listen(this.element.nativeElement, 'mouseenter', (/**\n                 * @return {?}\n                 */\n                () => {\n                    this.onMouseEnter();\n                }));\n                this.eventListenerSubscriptions.mouseleave = this.renderer.listen(this.element.nativeElement, 'mouseleave', (/**\n                 * @return {?}\n                 */\n                () => {\n                    this.onMouseLeave();\n                }));\n            }));\n        }\n        else if (!canDrag && hasEventListeners) {\n            this.unsubscribeEventListeners();\n        }\n    }\n    /**\n     * @private\n     * @param {?} event\n     * @return {?}\n     */\n    onMouseDown(event) {\n        if (event.button === 0) {\n            if (!this.eventListenerSubscriptions.mousemove) {\n                this.eventListenerSubscriptions.mousemove = this.renderer.listen('document', 'mousemove', (/**\n                 * @param {?} mouseMoveEvent\n                 * @return {?}\n                 */\n                (mouseMoveEvent) => {\n                    this.pointerMove$.next({\n                        event: mouseMoveEvent,\n                        clientX: mouseMoveEvent.clientX,\n                        clientY: mouseMoveEvent.clientY,\n                    });\n                }));\n            }\n            this.pointerDown$.next({\n                event,\n                clientX: event.clientX,\n                clientY: event.clientY,\n            });\n        }\n    }\n    /**\n     * @private\n     * @param {?} event\n     * @return {?}\n     */\n    onMouseUp(event) {\n        if (event.button === 0) {\n            if (this.eventListenerSubscriptions.mousemove) {\n                this.eventListenerSubscriptions.mousemove();\n                delete this.eventListenerSubscriptions.mousemove;\n            }\n            this.pointerUp$.next({\n                event,\n                clientX: event.clientX,\n                clientY: event.clientY,\n            });\n        }\n    }\n    /**\n     * @private\n     * @param {?} event\n     * @return {?}\n     */\n    onTouchStart(event) {\n        /** @type {?} */\n        let startScrollPosition;\n        /** @type {?} */\n        let isDragActivated;\n        /** @type {?} */\n        let hasContainerScrollbar;\n        if ((this.scrollContainer && this.scrollContainer.activeLongPressDrag) ||\n            this.touchStartLongPress) {\n            this.timeLongPress.timerBegin = Date.now();\n            isDragActivated = false;\n            hasContainerScrollbar = this.hasScrollbar();\n            startScrollPosition = this.getScrollPosition();\n        }\n        if (!this.eventListenerSubscriptions.touchmove) {\n            /** @type {?} */\n            const contextMenuListener = fromEvent(this.document, 'contextmenu').subscribe((/**\n             * @param {?} e\n             * @return {?}\n             */\n            (e) => {\n                e.preventDefault();\n            }));\n            /** @type {?} */\n            const touchMoveListener = fromEvent(this.document, 'touchmove', {\n                passive: false,\n            }).subscribe((/**\n             * @param {?} touchMoveEvent\n             * @return {?}\n             */\n            (touchMoveEvent) => {\n                if (((this.scrollContainer && this.scrollContainer.activeLongPressDrag) ||\n                    this.touchStartLongPress) &&\n                    !isDragActivated &&\n                    hasContainerScrollbar) {\n                    isDragActivated = this.shouldBeginDrag(event, touchMoveEvent, startScrollPosition);\n                }\n                if (((!this.scrollContainer ||\n                    !this.scrollContainer.activeLongPressDrag) &&\n                    !this.touchStartLongPress) ||\n                    !hasContainerScrollbar ||\n                    isDragActivated) {\n                    touchMoveEvent.preventDefault();\n                    this.pointerMove$.next({\n                        event: touchMoveEvent,\n                        clientX: touchMoveEvent.targetTouches[0].clientX,\n                        clientY: touchMoveEvent.targetTouches[0].clientY,\n                    });\n                }\n            }));\n            this.eventListenerSubscriptions.touchmove = (/**\n             * @return {?}\n             */\n            () => {\n                contextMenuListener.unsubscribe();\n                touchMoveListener.unsubscribe();\n            });\n        }\n        this.pointerDown$.next({\n            event,\n            clientX: event.touches[0].clientX,\n            clientY: event.touches[0].clientY,\n        });\n    }\n    /**\n     * @private\n     * @param {?} event\n     * @return {?}\n     */\n    onTouchEnd(event) {\n        if (this.eventListenerSubscriptions.touchmove) {\n            this.eventListenerSubscriptions.touchmove();\n            delete this.eventListenerSubscriptions.touchmove;\n            if ((this.scrollContainer && this.scrollContainer.activeLongPressDrag) ||\n                this.touchStartLongPress) {\n                this.enableScroll();\n            }\n        }\n        this.pointerUp$.next({\n            event,\n            clientX: event.changedTouches[0].clientX,\n            clientY: event.changedTouches[0].clientY,\n        });\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n    onMouseEnter() {\n        this.setCursor(this.dragCursor);\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n    onMouseLeave() {\n        this.setCursor('');\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n    canDrag() {\n        return this.dragAxis.x || this.dragAxis.y;\n    }\n    /**\n     * @private\n     * @param {?} value\n     * @return {?}\n     */\n    setCursor(value) {\n        if (!this.eventListenerSubscriptions.mousemove) {\n            this.renderer.setStyle(this.element.nativeElement, 'cursor', value);\n        }\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n    unsubscribeEventListeners() {\n        Object.keys(this.eventListenerSubscriptions).forEach((/**\n         * @param {?} type\n         * @return {?}\n         */\n        (type) => {\n            ((/** @type {?} */ (this))).eventListenerSubscriptions[type]();\n            delete ((/** @type {?} */ (this))).eventListenerSubscriptions[type];\n        }));\n    }\n    /**\n     * @private\n     * @param {?} element\n     * @param {?} styles\n     * @return {?}\n     */\n    setElementStyles(element, styles) {\n        Object.keys(styles).forEach((/**\n         * @param {?} key\n         * @return {?}\n         */\n        (key) => {\n            this.renderer.setStyle(element, key, styles[key]);\n        }));\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n    getScrollElement() {\n        if (this.scrollContainer) {\n            return this.scrollContainer.elementRef.nativeElement;\n        }\n        else {\n            return this.document.body;\n        }\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n    getScrollPosition() {\n        if (this.scrollContainer) {\n            return {\n                top: this.scrollContainer.elementRef.nativeElement.scrollTop,\n                left: this.scrollContainer.elementRef.nativeElement.scrollLeft,\n            };\n        }\n        else {\n            return {\n                top: window.pageYOffset || this.document.documentElement.scrollTop,\n                left: window.pageXOffset || this.document.documentElement.scrollLeft,\n            };\n        }\n    }\n    /**\n     * @private\n     * @param {?} event\n     * @param {?} touchMoveEvent\n     * @param {?} startScrollPosition\n     * @return {?}\n     */\n    shouldBeginDrag(event, touchMoveEvent, startScrollPosition) {\n        /** @type {?} */\n        const moveScrollPosition = this.getScrollPosition();\n        /** @type {?} */\n        const deltaScroll = {\n            top: Math.abs(moveScrollPosition.top - startScrollPosition.top),\n            left: Math.abs(moveScrollPosition.left - startScrollPosition.left),\n        };\n        /** @type {?} */\n        const deltaX = Math.abs(touchMoveEvent.targetTouches[0].clientX - event.touches[0].clientX) - deltaScroll.left;\n        /** @type {?} */\n        const deltaY = Math.abs(touchMoveEvent.targetTouches[0].clientY - event.touches[0].clientY) - deltaScroll.top;\n        /** @type {?} */\n        const deltaTotal = deltaX + deltaY;\n        /** @type {?} */\n        const longPressConfig = this.touchStartLongPress\n            ? this.touchStartLongPress\n            : /* istanbul ignore next */\n                {\n                    delta: this.scrollContainer.longPressConfig.delta,\n                    delay: this.scrollContainer.longPressConfig.duration,\n                };\n        if (deltaTotal > longPressConfig.delta ||\n            deltaScroll.top > 0 ||\n            deltaScroll.left > 0) {\n            this.timeLongPress.timerBegin = Date.now();\n        }\n        this.timeLongPress.timerEnd = Date.now();\n        /** @type {?} */\n        const duration = this.timeLongPress.timerEnd - this.timeLongPress.timerBegin;\n        if (duration >= longPressConfig.delay) {\n            this.disableScroll();\n            return true;\n        }\n        return false;\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n    enableScroll() {\n        if (this.scrollContainer) {\n            this.renderer.setStyle(this.scrollContainer.elementRef.nativeElement, 'overflow', '');\n        }\n        this.renderer.setStyle(this.document.body, 'overflow', '');\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n    disableScroll() {\n        /* istanbul ignore next */\n        if (this.scrollContainer) {\n            this.renderer.setStyle(this.scrollContainer.elementRef.nativeElement, 'overflow', 'hidden');\n        }\n        this.renderer.setStyle(this.document.body, 'overflow', 'hidden');\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n    hasScrollbar() {\n        /** @type {?} */\n        const scrollContainer = this.getScrollElement();\n        /** @type {?} */\n        const containerHasHorizontalScroll = scrollContainer.scrollWidth > scrollContainer.clientWidth;\n        /** @type {?} */\n        const containerHasVerticalScroll = scrollContainer.scrollHeight > scrollContainer.clientHeight;\n        return containerHasHorizontalScroll || containerHasVerticalScroll;\n    }\n}\nDraggableDirective.ɵfac = function DraggableDirective_Factory(t) { return new (t || DraggableDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(DraggableHelper), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(DraggableScrollContainerDirective, 8), ɵngcc0.ɵɵdirectiveInject(DOCUMENT)); };\nDraggableDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: DraggableDirective, selectors: [[\"\", \"mwlDraggable\", \"\"]], inputs: { dragAxis: \"dragAxis\", dragSnapGrid: \"dragSnapGrid\", ghostDragEnabled: \"ghostDragEnabled\", showOriginalElementWhileDragging: \"showOriginalElementWhileDragging\", dragCursor: \"dragCursor\", autoScroll: \"autoScroll\", dropData: \"dropData\", validateDrag: \"validateDrag\", dragActiveClass: \"dragActiveClass\", ghostElementAppendTo: \"ghostElementAppendTo\", ghostElementTemplate: \"ghostElementTemplate\", touchStartLongPress: \"touchStartLongPress\" }, outputs: { dragPointerDown: \"dragPointerDown\", dragStart: \"dragStart\", ghostElementCreated: \"ghostElementCreated\", dragging: \"dragging\", dragEnd: \"dragEnd\" }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });\n/** @nocollapse */\nDraggableDirective.ctorParameters = () => [\n    { type: ElementRef },\n    { type: Renderer2 },\n    { type: DraggableHelper },\n    { type: NgZone },\n    { type: ViewContainerRef },\n    { type: DraggableScrollContainerDirective, decorators: [{ type: Optional }] },\n    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }\n];\nDraggableDirective.propDecorators = {\n    dropData: [{ type: Input }],\n    dragAxis: [{ type: Input }],\n    dragSnapGrid: [{ type: Input }],\n    ghostDragEnabled: [{ type: Input }],\n    showOriginalElementWhileDragging: [{ type: Input }],\n    validateDrag: [{ type: Input }],\n    dragCursor: [{ type: Input }],\n    dragActiveClass: [{ type: Input }],\n    ghostElementAppendTo: [{ type: Input }],\n    ghostElementTemplate: [{ type: Input }],\n    touchStartLongPress: [{ type: Input }],\n    autoScroll: [{ type: Input }],\n    dragPointerDown: [{ type: Output }],\n    dragStart: [{ type: Output }],\n    ghostElementCreated: [{ type: Output }],\n    dragging: [{ type: Output }],\n    dragEnd: [{ type: Output }]\n};\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DraggableDirective, [{\n        type: Directive,\n        args: [{\n                selector: '[mwlDraggable]'\n            }]\n    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: DraggableHelper }, { type: ɵngcc0.NgZone }, { type: ɵngcc0.ViewContainerRef }, { type: DraggableScrollContainerDirective, decorators: [{\n                type: Optional\n            }] }, { type: undefined, decorators: [{\n                type: Inject,\n                args: [DOCUMENT]\n            }] }]; }, { dragAxis: [{\n            type: Input\n        }], dragSnapGrid: [{\n            type: Input\n        }], ghostDragEnabled: [{\n            type: Input\n        }], showOriginalElementWhileDragging: [{\n            type: Input\n        }], dragCursor: [{\n            type: Input\n        }], autoScroll: [{\n            type: Input\n        }], dragPointerDown: [{\n            type: Output\n        }], dragStart: [{\n            type: Output\n        }], ghostElementCreated: [{\n            type: Output\n        }], dragging: [{\n            type: Output\n        }], dragEnd: [{\n            type: Output\n        }], dropData: [{\n            type: Input\n        }], validateDrag: [{\n            type: Input\n        }], dragActiveClass: [{\n            type: Input\n        }], ghostElementAppendTo: [{\n            type: Input\n        }], ghostElementTemplate: [{\n            type: Input\n        }], touchStartLongPress: [{\n            type: Input\n        }] }); })();\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} clientX\n * @param {?} clientY\n * @param {?} rect\n * @return {?}\n */\nfunction isCoordinateWithinRectangle(clientX, clientY, rect) {\n    return (clientX >= rect.left &&\n        clientX <= rect.right &&\n        clientY >= rect.top &&\n        clientY <= rect.bottom);\n}\nclass DroppableDirective {\n    /**\n     * @param {?} element\n     * @param {?} draggableHelper\n     * @param {?} zone\n     * @param {?} renderer\n     * @param {?} scrollContainer\n     */\n    constructor(element, draggableHelper, zone, renderer, scrollContainer) {\n        this.element = element;\n        this.draggableHelper = draggableHelper;\n        this.zone = zone;\n        this.renderer = renderer;\n        this.scrollContainer = scrollContainer;\n        /**\n         * Called when a draggable element starts overlapping the element\n         */\n        this.dragEnter = new EventEmitter();\n        /**\n         * Called when a draggable element stops overlapping the element\n         */\n        this.dragLeave = new EventEmitter();\n        /**\n         * Called when a draggable element is moved over the element\n         */\n        this.dragOver = new EventEmitter();\n        /**\n         * Called when a draggable element is dropped on this element\n         */\n        this.drop = new EventEmitter(); // tslint:disable-line no-output-named-after-standard-event\n    }\n    /**\n     * @return {?}\n     */\n    ngOnInit() {\n        this.currentDragSubscription = this.draggableHelper.currentDrag.subscribe((/**\n         * @param {?} drag$\n         * @return {?}\n         */\n        (drag$) => {\n            addClass(this.renderer, this.element, this.dragActiveClass);\n            /** @type {?} */\n            const droppableElement = {\n                updateCache: true,\n            };\n            /** @type {?} */\n            const deregisterScrollListener = this.renderer.listen(this.scrollContainer\n                ? this.scrollContainer.elementRef.nativeElement\n                : 'window', 'scroll', (/**\n             * @return {?}\n             */\n            () => {\n                droppableElement.updateCache = true;\n            }));\n            /** @type {?} */\n            let currentDragDropData;\n            /** @type {?} */\n            const overlaps$ = drag$.pipe(map((/**\n             * @param {?} __0\n             * @return {?}\n             */\n            ({ clientX, clientY, dropData, target }) => {\n                currentDragDropData = dropData;\n                if (droppableElement.updateCache) {\n                    droppableElement.rect = this.element.nativeElement.getBoundingClientRect();\n                    if (this.scrollContainer) {\n                        droppableElement.scrollContainerRect = this.scrollContainer.elementRef.nativeElement.getBoundingClientRect();\n                    }\n                    droppableElement.updateCache = false;\n                }\n                /** @type {?} */\n                const isWithinElement = isCoordinateWithinRectangle(clientX, clientY, (/** @type {?} */ (droppableElement.rect)));\n                /** @type {?} */\n                const isDropAllowed = !this.validateDrop ||\n                    this.validateDrop({ clientX, clientY, target });\n                if (droppableElement.scrollContainerRect) {\n                    return (isWithinElement &&\n                        isDropAllowed &&\n                        isCoordinateWithinRectangle(clientX, clientY, (/** @type {?} */ (droppableElement.scrollContainerRect))));\n                }\n                else {\n                    return isWithinElement && isDropAllowed;\n                }\n            })));\n            /** @type {?} */\n            const overlapsChanged$ = overlaps$.pipe(distinctUntilChanged());\n            /** @type {?} */\n            let dragOverActive;\n            overlapsChanged$\n                .pipe(filter((/**\n             * @param {?} overlapsNow\n             * @return {?}\n             */\n            (overlapsNow) => overlapsNow)))\n                .subscribe((/**\n             * @return {?}\n             */\n            () => {\n                dragOverActive = true;\n                addClass(this.renderer, this.element, this.dragOverClass);\n                this.zone.run((/**\n                 * @return {?}\n                 */\n                () => {\n                    this.dragEnter.next({\n                        dropData: currentDragDropData,\n                    });\n                }));\n            }));\n            overlaps$.pipe(filter((/**\n             * @param {?} overlapsNow\n             * @return {?}\n             */\n            (overlapsNow) => overlapsNow))).subscribe((/**\n             * @return {?}\n             */\n            () => {\n                this.zone.run((/**\n                 * @return {?}\n                 */\n                () => {\n                    this.dragOver.next({\n                        dropData: currentDragDropData,\n                    });\n                }));\n            }));\n            overlapsChanged$\n                .pipe(pairwise(), filter((/**\n             * @param {?} __0\n             * @return {?}\n             */\n            ([didOverlap, overlapsNow]) => didOverlap && !overlapsNow)))\n                .subscribe((/**\n             * @return {?}\n             */\n            () => {\n                dragOverActive = false;\n                removeClass(this.renderer, this.element, this.dragOverClass);\n                this.zone.run((/**\n                 * @return {?}\n                 */\n                () => {\n                    this.dragLeave.next({\n                        dropData: currentDragDropData,\n                    });\n                }));\n            }));\n            drag$.subscribe({\n                complete: (/**\n                 * @return {?}\n                 */\n                () => {\n                    deregisterScrollListener();\n                    removeClass(this.renderer, this.element, this.dragActiveClass);\n                    if (dragOverActive) {\n                        removeClass(this.renderer, this.element, this.dragOverClass);\n                        this.zone.run((/**\n                         * @return {?}\n                         */\n                        () => {\n                            this.drop.next({\n                                dropData: currentDragDropData,\n                            });\n                        }));\n                    }\n                }),\n            });\n        }));\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        if (this.currentDragSubscription) {\n            this.currentDragSubscription.unsubscribe();\n        }\n    }\n}\nDroppableDirective.ɵfac = function DroppableDirective_Factory(t) { return new (t || DroppableDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(DraggableHelper), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(DraggableScrollContainerDirective, 8)); };\nDroppableDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: DroppableDirective, selectors: [[\"\", \"mwlDroppable\", \"\"]], inputs: { dragOverClass: \"dragOverClass\", dragActiveClass: \"dragActiveClass\", validateDrop: \"validateDrop\" }, outputs: { dragEnter: \"dragEnter\", dragLeave: \"dragLeave\", dragOver: \"dragOver\", drop: \"drop\" } });\n/** @nocollapse */\nDroppableDirective.ctorParameters = () => [\n    { type: ElementRef },\n    { type: DraggableHelper },\n    { type: NgZone },\n    { type: Renderer2 },\n    { type: DraggableScrollContainerDirective, decorators: [{ type: Optional }] }\n];\nDroppableDirective.propDecorators = {\n    dragOverClass: [{ type: Input }],\n    dragActiveClass: [{ type: Input }],\n    validateDrop: [{ type: Input }],\n    dragEnter: [{ type: Output }],\n    dragLeave: [{ type: Output }],\n    dragOver: [{ type: Output }],\n    drop: [{ type: Output }]\n};\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DroppableDirective, [{\n        type: Directive,\n        args: [{\n                selector: '[mwlDroppable]'\n            }]\n    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: DraggableHelper }, { type: ɵngcc0.NgZone }, { type: ɵngcc0.Renderer2 }, { type: DraggableScrollContainerDirective, decorators: [{\n                type: Optional\n            }] }]; }, { dragEnter: [{\n            type: Output\n        }], dragLeave: [{\n            type: Output\n        }], dragOver: [{\n            type: Output\n        }], drop: [{\n            type: Output\n        }], dragOverClass: [{\n            type: Input\n        }], dragActiveClass: [{\n            type: Input\n        }], validateDrop: [{\n            type: Input\n        }] }); })();\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass DragAndDropModule {\n}\nDragAndDropModule.ɵfac = function DragAndDropModule_Factory(t) { return new (t || DragAndDropModule)(); };\nDragAndDropModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: DragAndDropModule });\nDragAndDropModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({});\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DragAndDropModule, [{\n        type: NgModule,\n        args: [{\n                declarations: [\n                    DraggableDirective,\n                    DroppableDirective,\n                    DraggableScrollContainerDirective,\n                ],\n                exports: [\n                    DraggableDirective,\n                    DroppableDirective,\n                    DraggableScrollContainerDirective,\n                ]\n            }]\n    }], null, null); })();\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(DragAndDropModule, { declarations: [DraggableDirective, DroppableDirective, DraggableScrollContainerDirective], exports: [DraggableDirective, DroppableDirective, DraggableScrollContainerDirective] }); })();\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\nexport { DragAndDropModule, DraggableHelper as ɵc, DraggableScrollContainerDirective as ɵd, DraggableDirective as ɵb, DroppableDirective as ɵa };\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}