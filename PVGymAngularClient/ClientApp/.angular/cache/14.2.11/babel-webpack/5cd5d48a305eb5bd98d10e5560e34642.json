{"ast":null,"code":"// previous version:\n// https://github.com/angular-ui/bootstrap/blob/07c31d0731f7cb068a1932b8e01d2312b796b4ec/src/position/position.js\nvar Positioning = function () {\n  function Positioning() {}\n\n  Positioning.prototype.getAllStyles = function (element) {\n    return window.getComputedStyle(element);\n  };\n\n  Positioning.prototype.getStyle = function (element, prop) {\n    return this.getAllStyles(element)[prop];\n  };\n\n  Positioning.prototype.isStaticPositioned = function (element) {\n    return (this.getStyle(element, 'position') || 'static') === 'static';\n  };\n\n  Positioning.prototype.offsetParent = function (element) {\n    var offsetParentEl = element.offsetParent || document.documentElement;\n\n    while (offsetParentEl && offsetParentEl !== document.documentElement && this.isStaticPositioned(offsetParentEl)) {\n      offsetParentEl = offsetParentEl.offsetParent;\n    }\n\n    return offsetParentEl || document.documentElement;\n  };\n\n  Positioning.prototype.position = function (element, round) {\n    if (round === void 0) {\n      round = true;\n    }\n\n    var elPosition;\n    var parentOffset = {\n      width: 0,\n      height: 0,\n      top: 0,\n      bottom: 0,\n      left: 0,\n      right: 0\n    };\n\n    if (this.getStyle(element, 'position') === 'fixed') {\n      elPosition = element.getBoundingClientRect();\n    } else {\n      var offsetParentEl = this.offsetParent(element);\n      elPosition = this.offset(element, false);\n\n      if (offsetParentEl !== document.documentElement) {\n        parentOffset = this.offset(offsetParentEl, false);\n      }\n\n      parentOffset.top += offsetParentEl.clientTop;\n      parentOffset.left += offsetParentEl.clientLeft;\n    }\n\n    elPosition.top -= parentOffset.top;\n    elPosition.bottom -= parentOffset.top;\n    elPosition.left -= parentOffset.left;\n    elPosition.right -= parentOffset.left;\n\n    if (round) {\n      elPosition.top = Math.round(elPosition.top);\n      elPosition.bottom = Math.round(elPosition.bottom);\n      elPosition.left = Math.round(elPosition.left);\n      elPosition.right = Math.round(elPosition.right);\n    }\n\n    return elPosition;\n  };\n\n  Positioning.prototype.offset = function (element, round) {\n    if (round === void 0) {\n      round = true;\n    }\n\n    var elBcr = element.getBoundingClientRect();\n    var viewportOffset = {\n      top: window.pageYOffset - document.documentElement.clientTop,\n      left: window.pageXOffset - document.documentElement.clientLeft\n    };\n    var elOffset = {\n      height: elBcr.height || element.offsetHeight,\n      width: elBcr.width || element.offsetWidth,\n      top: elBcr.top + viewportOffset.top,\n      bottom: elBcr.bottom + viewportOffset.top,\n      left: elBcr.left + viewportOffset.left,\n      right: elBcr.right + viewportOffset.left\n    };\n\n    if (round) {\n      elOffset.height = Math.round(elOffset.height);\n      elOffset.width = Math.round(elOffset.width);\n      elOffset.top = Math.round(elOffset.top);\n      elOffset.bottom = Math.round(elOffset.bottom);\n      elOffset.left = Math.round(elOffset.left);\n      elOffset.right = Math.round(elOffset.right);\n    }\n\n    return elOffset;\n  };\n\n  Positioning.prototype.positionElements = function (hostElement, targetElement, placement, appendToBody) {\n    var hostElPosition = appendToBody ? this.offset(hostElement, false) : this.position(hostElement, false);\n    var targetElStyles = this.getAllStyles(targetElement);\n    var targetElBCR = targetElement.getBoundingClientRect();\n    var placementPrimary = placement.split('-')[0] || 'top';\n    var placementSecondary = placement.split('-')[1] || 'center';\n    var targetElPosition = {\n      'height': targetElBCR.height || targetElement.offsetHeight,\n      'width': targetElBCR.width || targetElement.offsetWidth,\n      'top': 0,\n      'bottom': targetElBCR.height || targetElement.offsetHeight,\n      'left': 0,\n      'right': targetElBCR.width || targetElement.offsetWidth\n    };\n\n    switch (placementPrimary) {\n      case 'top':\n        targetElPosition.top = hostElPosition.top - (targetElement.offsetHeight + parseFloat(targetElStyles.marginBottom));\n        break;\n\n      case 'bottom':\n        targetElPosition.top = hostElPosition.top + hostElPosition.height;\n        break;\n\n      case 'left':\n        targetElPosition.left = hostElPosition.left - (targetElement.offsetWidth + parseFloat(targetElStyles.marginRight));\n        break;\n\n      case 'right':\n        targetElPosition.left = hostElPosition.left + hostElPosition.width;\n        break;\n    }\n\n    switch (placementSecondary) {\n      case 'top':\n        targetElPosition.top = hostElPosition.top;\n        break;\n\n      case 'bottom':\n        targetElPosition.top = hostElPosition.top + hostElPosition.height - targetElement.offsetHeight;\n        break;\n\n      case 'left':\n        targetElPosition.left = hostElPosition.left;\n        break;\n\n      case 'right':\n        targetElPosition.left = hostElPosition.left + hostElPosition.width - targetElement.offsetWidth;\n        break;\n\n      case 'center':\n        if (placementPrimary === 'top' || placementPrimary === 'bottom') {\n          targetElPosition.left = hostElPosition.left + hostElPosition.width / 2 - targetElement.offsetWidth / 2;\n        } else {\n          targetElPosition.top = hostElPosition.top + hostElPosition.height / 2 - targetElement.offsetHeight / 2;\n        }\n\n        break;\n    }\n\n    targetElPosition.top = Math.round(targetElPosition.top);\n    targetElPosition.bottom = Math.round(targetElPosition.bottom);\n    targetElPosition.left = Math.round(targetElPosition.left);\n    targetElPosition.right = Math.round(targetElPosition.right);\n    return targetElPosition;\n  }; // get the availble placements of the target element in the viewport dependeing on the host element\n\n\n  Positioning.prototype.getAvailablePlacements = function (hostElement, targetElement) {\n    var availablePlacements = [];\n    var hostElemClientRect = hostElement.getBoundingClientRect();\n    var targetElemClientRect = targetElement.getBoundingClientRect();\n    var html = document.documentElement;\n    var windowHeight = window.innerHeight || html.clientHeight;\n    var windowWidth = window.innerWidth || html.clientWidth;\n    var hostElemClientRectHorCenter = hostElemClientRect.left + hostElemClientRect.width / 2;\n    var hostElemClientRectVerCenter = hostElemClientRect.top + hostElemClientRect.height / 2; // left: check if target width can be placed between host left and viewport start and also height of target is\n    // inside viewport\n\n    if (targetElemClientRect.width < hostElemClientRect.left) {\n      // check for left only\n      if (hostElemClientRectVerCenter > targetElemClientRect.height / 2 && windowHeight - hostElemClientRectVerCenter > targetElemClientRect.height / 2) {\n        availablePlacements.splice(availablePlacements.length, 1, 'left');\n      } // check for left-top and left-bottom\n\n\n      this.setSecondaryPlacementForLeftRight(hostElemClientRect, targetElemClientRect, 'left', availablePlacements);\n    } // top: target height is less than host top\n\n\n    if (targetElemClientRect.height < hostElemClientRect.top) {\n      if (hostElemClientRectHorCenter > targetElemClientRect.width / 2 && windowWidth - hostElemClientRectHorCenter > targetElemClientRect.width / 2) {\n        availablePlacements.splice(availablePlacements.length, 1, 'top');\n      }\n\n      this.setSecondaryPlacementForTopBottom(hostElemClientRect, targetElemClientRect, 'top', availablePlacements);\n    } // right: check if target width can be placed between host right and viewport end and also height of target is\n    // inside viewport\n\n\n    if (windowWidth - hostElemClientRect.right > targetElemClientRect.width) {\n      // check for right only\n      if (hostElemClientRectVerCenter > targetElemClientRect.height / 2 && windowHeight - hostElemClientRectVerCenter > targetElemClientRect.height / 2) {\n        availablePlacements.splice(availablePlacements.length, 1, 'right');\n      } // check for right-top and right-bottom\n\n\n      this.setSecondaryPlacementForLeftRight(hostElemClientRect, targetElemClientRect, 'right', availablePlacements);\n    } // bottom: check if there is enough space between host bottom and viewport end for target height\n\n\n    if (windowHeight - hostElemClientRect.bottom > targetElemClientRect.height) {\n      if (hostElemClientRectHorCenter > targetElemClientRect.width / 2 && windowWidth - hostElemClientRectHorCenter > targetElemClientRect.width / 2) {\n        availablePlacements.splice(availablePlacements.length, 1, 'bottom');\n      }\n\n      this.setSecondaryPlacementForTopBottom(hostElemClientRect, targetElemClientRect, 'bottom', availablePlacements);\n    }\n\n    return availablePlacements;\n  };\n  /**\n   * check if secondary placement for left and right are available i.e. left-top, left-bottom, right-top, right-bottom\n   * primaryplacement: left|right\n   * availablePlacementArr: array in which available placemets to be set\n   */\n\n\n  Positioning.prototype.setSecondaryPlacementForLeftRight = function (hostElemClientRect, targetElemClientRect, primaryPlacement, availablePlacementArr) {\n    var html = document.documentElement; // check for left-bottom\n\n    if (targetElemClientRect.height <= hostElemClientRect.bottom) {\n      availablePlacementArr.splice(availablePlacementArr.length, 1, primaryPlacement + '-bottom');\n    }\n\n    if ((window.innerHeight || html.clientHeight) - hostElemClientRect.top >= targetElemClientRect.height) {\n      availablePlacementArr.splice(availablePlacementArr.length, 1, primaryPlacement + '-top');\n    }\n  };\n  /**\n   * check if secondary placement for top and bottom are available i.e. top-left, top-right, bottom-left, bottom-right\n   * primaryplacement: top|bottom\n   * availablePlacementArr: array in which available placemets to be set\n   */\n\n\n  Positioning.prototype.setSecondaryPlacementForTopBottom = function (hostElemClientRect, targetElemClientRect, primaryPlacement, availablePlacementArr) {\n    var html = document.documentElement; // check for left-bottom\n\n    if ((window.innerWidth || html.clientWidth) - hostElemClientRect.left >= targetElemClientRect.width) {\n      availablePlacementArr.splice(availablePlacementArr.length, 1, primaryPlacement + '-left');\n    }\n\n    if (targetElemClientRect.width <= hostElemClientRect.right) {\n      availablePlacementArr.splice(availablePlacementArr.length, 1, primaryPlacement + '-right');\n    }\n  };\n\n  return Positioning;\n}();\n\nexport { Positioning };\nvar positionService = new Positioning();\n/*\n * Accept the placement array and applies the appropriate placement dependent on the viewport.\n * Returns the applied placement.\n * In case of auto placement, placements are selected in order\n *   'top', 'bottom', 'left', 'right',\n *   'top-left', 'top-right',\n *   'bottom-left', 'bottom-right',\n *   'left-top', 'left-bottom',\n *   'right-top', 'right-bottom'.\n * */\n\nexport function positionElements(hostElement, targetElement, placement, appendToBody) {\n  var placementVals = Array.isArray(placement) ? placement : [placement]; // replace auto placement with other placements\n\n  var hasAuto = placementVals.findIndex(function (val) {\n    return val === 'auto';\n  });\n\n  if (hasAuto >= 0) {\n    ['top', 'bottom', 'left', 'right', 'top-left', 'top-right', 'bottom-left', 'bottom-right', 'left-top', 'left-bottom', 'right-top', 'right-bottom'].forEach(function (obj) {\n      if (placementVals.find(function (val) {\n        return val.search('^' + obj) !== -1;\n      }) == null) {\n        placementVals.splice(hasAuto++, 1, obj);\n      }\n    });\n  } // coordinates where to position\n\n\n  var topVal = 0,\n      leftVal = 0;\n  var appliedPlacement; // get available placements\n\n  var availablePlacements = positionService.getAvailablePlacements(hostElement, targetElement);\n\n  var _loop_1 = function (item, index) {\n    // check if passed placement is present in the available placement or otherwise apply the last placement in the\n    // passed placement list\n    if (availablePlacements.find(function (val) {\n      return val === item;\n    }) != null || placementVals.length === index + 1) {\n      appliedPlacement = item;\n      var pos = positionService.positionElements(hostElement, targetElement, item, appendToBody);\n      topVal = pos.top;\n      leftVal = pos.left;\n      return \"break\";\n    }\n  }; // iterate over all the passed placements\n\n\n  for (var _i = 0, _a = toItemIndexes(placementVals); _i < _a.length; _i++) {\n    var _b = _a[_i],\n        item = _b.item,\n        index = _b.index;\n\n    var state_1 = _loop_1(item, index);\n\n    if (state_1 === \"break\") break;\n  }\n\n  targetElement.style.top = topVal + \"px\";\n  targetElement.style.left = leftVal + \"px\";\n  return appliedPlacement;\n} // function to get index and item of an array\n\nfunction toItemIndexes(a) {\n  return a.map(function (item, index) {\n    return {\n      item: item,\n      index: index\n    };\n  });\n}","map":{"version":3,"names":["Positioning","prototype","getAllStyles","element","window","getComputedStyle","getStyle","prop","isStaticPositioned","offsetParent","offsetParentEl","document","documentElement","position","round","elPosition","parentOffset","width","height","top","bottom","left","right","getBoundingClientRect","offset","clientTop","clientLeft","Math","elBcr","viewportOffset","pageYOffset","pageXOffset","elOffset","offsetHeight","offsetWidth","positionElements","hostElement","targetElement","placement","appendToBody","hostElPosition","targetElStyles","targetElBCR","placementPrimary","split","placementSecondary","targetElPosition","parseFloat","marginBottom","marginRight","getAvailablePlacements","availablePlacements","hostElemClientRect","targetElemClientRect","html","windowHeight","innerHeight","clientHeight","windowWidth","innerWidth","clientWidth","hostElemClientRectHorCenter","hostElemClientRectVerCenter","splice","length","setSecondaryPlacementForLeftRight","setSecondaryPlacementForTopBottom","primaryPlacement","availablePlacementArr","positionService","placementVals","Array","isArray","hasAuto","findIndex","val","forEach","obj","find","search","topVal","leftVal","appliedPlacement","_loop_1","item","index","pos","_i","_a","toItemIndexes","_b","state_1","style","a","map"],"sources":["C:/Users/Utilizador/Desktop/PVGym/PVGymAngularClient/ClientApp/node_modules/positioning/dist/positioning.js"],"sourcesContent":["// previous version:\n// https://github.com/angular-ui/bootstrap/blob/07c31d0731f7cb068a1932b8e01d2312b796b4ec/src/position/position.js\nvar Positioning = (function () {\n    function Positioning() {\n    }\n    Positioning.prototype.getAllStyles = function (element) { return window.getComputedStyle(element); };\n    Positioning.prototype.getStyle = function (element, prop) { return this.getAllStyles(element)[prop]; };\n    Positioning.prototype.isStaticPositioned = function (element) {\n        return (this.getStyle(element, 'position') || 'static') === 'static';\n    };\n    Positioning.prototype.offsetParent = function (element) {\n        var offsetParentEl = element.offsetParent || document.documentElement;\n        while (offsetParentEl && offsetParentEl !== document.documentElement && this.isStaticPositioned(offsetParentEl)) {\n            offsetParentEl = offsetParentEl.offsetParent;\n        }\n        return offsetParentEl || document.documentElement;\n    };\n    Positioning.prototype.position = function (element, round) {\n        if (round === void 0) { round = true; }\n        var elPosition;\n        var parentOffset = { width: 0, height: 0, top: 0, bottom: 0, left: 0, right: 0 };\n        if (this.getStyle(element, 'position') === 'fixed') {\n            elPosition = element.getBoundingClientRect();\n        }\n        else {\n            var offsetParentEl = this.offsetParent(element);\n            elPosition = this.offset(element, false);\n            if (offsetParentEl !== document.documentElement) {\n                parentOffset = this.offset(offsetParentEl, false);\n            }\n            parentOffset.top += offsetParentEl.clientTop;\n            parentOffset.left += offsetParentEl.clientLeft;\n        }\n        elPosition.top -= parentOffset.top;\n        elPosition.bottom -= parentOffset.top;\n        elPosition.left -= parentOffset.left;\n        elPosition.right -= parentOffset.left;\n        if (round) {\n            elPosition.top = Math.round(elPosition.top);\n            elPosition.bottom = Math.round(elPosition.bottom);\n            elPosition.left = Math.round(elPosition.left);\n            elPosition.right = Math.round(elPosition.right);\n        }\n        return elPosition;\n    };\n    Positioning.prototype.offset = function (element, round) {\n        if (round === void 0) { round = true; }\n        var elBcr = element.getBoundingClientRect();\n        var viewportOffset = {\n            top: window.pageYOffset - document.documentElement.clientTop,\n            left: window.pageXOffset - document.documentElement.clientLeft\n        };\n        var elOffset = {\n            height: elBcr.height || element.offsetHeight,\n            width: elBcr.width || element.offsetWidth,\n            top: elBcr.top + viewportOffset.top,\n            bottom: elBcr.bottom + viewportOffset.top,\n            left: elBcr.left + viewportOffset.left,\n            right: elBcr.right + viewportOffset.left\n        };\n        if (round) {\n            elOffset.height = Math.round(elOffset.height);\n            elOffset.width = Math.round(elOffset.width);\n            elOffset.top = Math.round(elOffset.top);\n            elOffset.bottom = Math.round(elOffset.bottom);\n            elOffset.left = Math.round(elOffset.left);\n            elOffset.right = Math.round(elOffset.right);\n        }\n        return elOffset;\n    };\n    Positioning.prototype.positionElements = function (hostElement, targetElement, placement, appendToBody) {\n        var hostElPosition = appendToBody ? this.offset(hostElement, false) : this.position(hostElement, false);\n        var targetElStyles = this.getAllStyles(targetElement);\n        var targetElBCR = targetElement.getBoundingClientRect();\n        var placementPrimary = placement.split('-')[0] || 'top';\n        var placementSecondary = placement.split('-')[1] || 'center';\n        var targetElPosition = {\n            'height': targetElBCR.height || targetElement.offsetHeight,\n            'width': targetElBCR.width || targetElement.offsetWidth,\n            'top': 0,\n            'bottom': targetElBCR.height || targetElement.offsetHeight,\n            'left': 0,\n            'right': targetElBCR.width || targetElement.offsetWidth\n        };\n        switch (placementPrimary) {\n            case 'top':\n                targetElPosition.top =\n                    hostElPosition.top - (targetElement.offsetHeight + parseFloat(targetElStyles.marginBottom));\n                break;\n            case 'bottom':\n                targetElPosition.top = hostElPosition.top + hostElPosition.height;\n                break;\n            case 'left':\n                targetElPosition.left =\n                    hostElPosition.left - (targetElement.offsetWidth + parseFloat(targetElStyles.marginRight));\n                break;\n            case 'right':\n                targetElPosition.left = hostElPosition.left + hostElPosition.width;\n                break;\n        }\n        switch (placementSecondary) {\n            case 'top':\n                targetElPosition.top = hostElPosition.top;\n                break;\n            case 'bottom':\n                targetElPosition.top = hostElPosition.top + hostElPosition.height - targetElement.offsetHeight;\n                break;\n            case 'left':\n                targetElPosition.left = hostElPosition.left;\n                break;\n            case 'right':\n                targetElPosition.left = hostElPosition.left + hostElPosition.width - targetElement.offsetWidth;\n                break;\n            case 'center':\n                if (placementPrimary === 'top' || placementPrimary === 'bottom') {\n                    targetElPosition.left = hostElPosition.left + hostElPosition.width / 2 - targetElement.offsetWidth / 2;\n                }\n                else {\n                    targetElPosition.top = hostElPosition.top + hostElPosition.height / 2 - targetElement.offsetHeight / 2;\n                }\n                break;\n        }\n        targetElPosition.top = Math.round(targetElPosition.top);\n        targetElPosition.bottom = Math.round(targetElPosition.bottom);\n        targetElPosition.left = Math.round(targetElPosition.left);\n        targetElPosition.right = Math.round(targetElPosition.right);\n        return targetElPosition;\n    };\n    // get the availble placements of the target element in the viewport dependeing on the host element\n    Positioning.prototype.getAvailablePlacements = function (hostElement, targetElement) {\n        var availablePlacements = [];\n        var hostElemClientRect = hostElement.getBoundingClientRect();\n        var targetElemClientRect = targetElement.getBoundingClientRect();\n        var html = document.documentElement;\n        var windowHeight = window.innerHeight || html.clientHeight;\n        var windowWidth = window.innerWidth || html.clientWidth;\n        var hostElemClientRectHorCenter = hostElemClientRect.left + hostElemClientRect.width / 2;\n        var hostElemClientRectVerCenter = hostElemClientRect.top + hostElemClientRect.height / 2;\n        // left: check if target width can be placed between host left and viewport start and also height of target is\n        // inside viewport\n        if (targetElemClientRect.width < hostElemClientRect.left) {\n            // check for left only\n            if (hostElemClientRectVerCenter > targetElemClientRect.height / 2 &&\n                windowHeight - hostElemClientRectVerCenter > targetElemClientRect.height / 2) {\n                availablePlacements.splice(availablePlacements.length, 1, 'left');\n            }\n            // check for left-top and left-bottom\n            this.setSecondaryPlacementForLeftRight(hostElemClientRect, targetElemClientRect, 'left', availablePlacements);\n        }\n        // top: target height is less than host top\n        if (targetElemClientRect.height < hostElemClientRect.top) {\n            if (hostElemClientRectHorCenter > targetElemClientRect.width / 2 &&\n                windowWidth - hostElemClientRectHorCenter > targetElemClientRect.width / 2) {\n                availablePlacements.splice(availablePlacements.length, 1, 'top');\n            }\n            this.setSecondaryPlacementForTopBottom(hostElemClientRect, targetElemClientRect, 'top', availablePlacements);\n        }\n        // right: check if target width can be placed between host right and viewport end and also height of target is\n        // inside viewport\n        if (windowWidth - hostElemClientRect.right > targetElemClientRect.width) {\n            // check for right only\n            if (hostElemClientRectVerCenter > targetElemClientRect.height / 2 &&\n                windowHeight - hostElemClientRectVerCenter > targetElemClientRect.height / 2) {\n                availablePlacements.splice(availablePlacements.length, 1, 'right');\n            }\n            // check for right-top and right-bottom\n            this.setSecondaryPlacementForLeftRight(hostElemClientRect, targetElemClientRect, 'right', availablePlacements);\n        }\n        // bottom: check if there is enough space between host bottom and viewport end for target height\n        if (windowHeight - hostElemClientRect.bottom > targetElemClientRect.height) {\n            if (hostElemClientRectHorCenter > targetElemClientRect.width / 2 &&\n                windowWidth - hostElemClientRectHorCenter > targetElemClientRect.width / 2) {\n                availablePlacements.splice(availablePlacements.length, 1, 'bottom');\n            }\n            this.setSecondaryPlacementForTopBottom(hostElemClientRect, targetElemClientRect, 'bottom', availablePlacements);\n        }\n        return availablePlacements;\n    };\n    /**\n     * check if secondary placement for left and right are available i.e. left-top, left-bottom, right-top, right-bottom\n     * primaryplacement: left|right\n     * availablePlacementArr: array in which available placemets to be set\n     */\n    Positioning.prototype.setSecondaryPlacementForLeftRight = function (hostElemClientRect, targetElemClientRect, primaryPlacement, availablePlacementArr) {\n        var html = document.documentElement;\n        // check for left-bottom\n        if (targetElemClientRect.height <= hostElemClientRect.bottom) {\n            availablePlacementArr.splice(availablePlacementArr.length, 1, primaryPlacement + '-bottom');\n        }\n        if ((window.innerHeight || html.clientHeight) - hostElemClientRect.top >= targetElemClientRect.height) {\n            availablePlacementArr.splice(availablePlacementArr.length, 1, primaryPlacement + '-top');\n        }\n    };\n    /**\n     * check if secondary placement for top and bottom are available i.e. top-left, top-right, bottom-left, bottom-right\n     * primaryplacement: top|bottom\n     * availablePlacementArr: array in which available placemets to be set\n     */\n    Positioning.prototype.setSecondaryPlacementForTopBottom = function (hostElemClientRect, targetElemClientRect, primaryPlacement, availablePlacementArr) {\n        var html = document.documentElement;\n        // check for left-bottom\n        if ((window.innerWidth || html.clientWidth) - hostElemClientRect.left >= targetElemClientRect.width) {\n            availablePlacementArr.splice(availablePlacementArr.length, 1, primaryPlacement + '-left');\n        }\n        if (targetElemClientRect.width <= hostElemClientRect.right) {\n            availablePlacementArr.splice(availablePlacementArr.length, 1, primaryPlacement + '-right');\n        }\n    };\n    return Positioning;\n}());\nexport { Positioning };\nvar positionService = new Positioning();\n/*\n * Accept the placement array and applies the appropriate placement dependent on the viewport.\n * Returns the applied placement.\n * In case of auto placement, placements are selected in order\n *   'top', 'bottom', 'left', 'right',\n *   'top-left', 'top-right',\n *   'bottom-left', 'bottom-right',\n *   'left-top', 'left-bottom',\n *   'right-top', 'right-bottom'.\n * */\nexport function positionElements(hostElement, targetElement, placement, appendToBody) {\n    var placementVals = Array.isArray(placement) ? placement : [placement];\n    // replace auto placement with other placements\n    var hasAuto = placementVals.findIndex(function (val) { return val === 'auto'; });\n    if (hasAuto >= 0) {\n        ['top', 'bottom', 'left', 'right', 'top-left', 'top-right', 'bottom-left', 'bottom-right', 'left-top',\n            'left-bottom', 'right-top', 'right-bottom',\n        ].forEach(function (obj) {\n            if (placementVals.find(function (val) { return val.search('^' + obj) !== -1; }) == null) {\n                placementVals.splice(hasAuto++, 1, obj);\n            }\n        });\n    }\n    // coordinates where to position\n    var topVal = 0, leftVal = 0;\n    var appliedPlacement;\n    // get available placements\n    var availablePlacements = positionService.getAvailablePlacements(hostElement, targetElement);\n    var _loop_1 = function (item, index) {\n        // check if passed placement is present in the available placement or otherwise apply the last placement in the\n        // passed placement list\n        if ((availablePlacements.find(function (val) { return val === item; }) != null) || (placementVals.length === index + 1)) {\n            appliedPlacement = item;\n            var pos = positionService.positionElements(hostElement, targetElement, item, appendToBody);\n            topVal = pos.top;\n            leftVal = pos.left;\n            return \"break\";\n        }\n    };\n    // iterate over all the passed placements\n    for (var _i = 0, _a = toItemIndexes(placementVals); _i < _a.length; _i++) {\n        var _b = _a[_i], item = _b.item, index = _b.index;\n        var state_1 = _loop_1(item, index);\n        if (state_1 === \"break\")\n            break;\n    }\n    targetElement.style.top = topVal + \"px\";\n    targetElement.style.left = leftVal + \"px\";\n    return appliedPlacement;\n}\n// function to get index and item of an array\nfunction toItemIndexes(a) {\n    return a.map(function (item, index) { return ({ item: item, index: index }); });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}